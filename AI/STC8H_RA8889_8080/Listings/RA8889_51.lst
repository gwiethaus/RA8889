C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE RA8889_51
OBJECT MODULE PLACED IN .\Objects\RA8889_51.obj
COMPILER INVOKED BY: D:\Program Files\Keil_v5\C51\BIN\C51.EXE RA8889_01_Kernel\RA8889_51.c COMPACT OMF2 ROM(COMPACT) OPT
                    -IMIZE(9,SPEED) BROWSE INCDIR(.\RA8889_01_Kernel) DEBUG PRINT(.\Listings\RA8889_51.lst) TABS(2) OBJECT(.\Objects\RA8889_5
                    -1.obj)

line level    source

   1          
   2          /************** RAIO Technology Inc. / Lcdvision Co., Ltd.***************
   3           * file     : RA8889_51.c
   4           * author   : BW.SU
   5           * version  : V1.2
   6           * date     : 2024/06/07
   7           * brief    :
   8           *          （1）延时函数，原代码所有us级别全部改为ms级别
   9           *          （2）修改部份Check_While_Busy判断逻辑
  10          ************************* bbs.lcdvision.com.cn **************************/
  11          
  12          #include "RA8889_51.h"
  13          #include "RA8889_MCU_IF.h"
  14          #include "UserDef.h"
  15          #include "delay.h"
  16          
  17          
  18          /*****************************************************************
  19            * @brief  RA8889初始化
  20            * @param  无
  21            * @retval 无
  22            * @note
  23            ****************************************************************/
  24          void RA8889_Initial(void)
  25          {
  26   1        unsigned char temp;
  27   1      
  28   1        Check_IC_ready();
  29   1        RA8889_SW_Reset();    //软件复位
  30   1        Check_IC_ready();
  31   1      
  32   1        RA8889_PLL(DRAM_FREQ, CORE_FREQ, SCAN_FREQ);
  33   1        RA8889_SDRAM_initial();
  34   1        
  35   1      
  36   1        /* LCD接口设定 */
  37   1        //**[01h]**//
  38   1          TFT_24bit();
  39   1      //  TFT_18bit();
  40   1      //  TFT_16bit();
  41   1      //  Without_TFT();
  42   1      
  43   1      
  44   1        /* MCU通信位设定 */
  45   1      //  0: 8-bit Parallel Host Data Bus.
  46   1      //  1: 16-bit Parallel Host Data Bus.
  47   1        #if defined(MCU_8bit_ColorDepth_8bpp) || defined(MCU_8bit_ColorDepth_16bpp) || defined(MCU_8bit_ColorDept
             -h_24bpp)
  48   1          Host_Bus_8bit();
  49   1        #endif
  50   1        #if defined(MCU_16bit_ColorDepth_16bpp) || defined(MCU_16bit_ColorDepth_24bpp_Mode_1) || defined(MCU_16bi
             -t_ColorDepth_24bpp_Mode_2)  
                  Host_Bus_16bit();
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 2   

                #endif
  53   1      
  54   1      
  55   1      
  56   1        /*=====[02h]寄存器=====*/
  57   1      
  58   1        /* 数据格式设定: MCU接口，色深 */
  59   1      //  0xb: Direct write for all 8 bits MPU I/F, 16 bits MPU I/F with 16bpp, 16 bits MPU I/F with 24bpp data m
             -ode 1 and serial host interface.                
  60   1      //  11b: Mask high byte of even data (ex. 16 bit MPU I/F with 24-bpp data mode 2)
  61   1        LCD_CmdWrite(0x02);       //02h.bit7~6寄存器
  62   1        temp = LCD_DataRead();
  63   1        #if defined(MCU_8bit_ColorDepth_8bpp) || defined(MCU_8bit_ColorDepth_16bpp) || defined(MCU_8bit_ColorDept
             -h_24bpp) || defined(MCU_16bit_ColorDepth_16bpp) || defined(MCU_16bit_ColorDepth_24bpp_Mode_1)  
  64   1            temp &= cClrb7;  
  65   1        #endif
  66   1        #ifdef MCU_16bit_ColorDepth_24bpp_Mode_2  
                  temp |= cSetb7;
                  temp |= cSetb6; 
                #endif
  70   1        LCD_DataWrite(temp);
  71   1      
  72   1      
  73   1        /* 显存写入方向设定 */
  74   1        MemWrite_Left_Right_Top_Down();
  75   1      //  MemWrite_Right_Left_Top_Down();
  76   1      //  MemRead_Down_Top_Left_Right();
  77   1      //  MemRead_Top_Down_Left_Right();
  78   1      
  79   1        /* 显示扫描方向设定 */
  80   1      //  HSCAN_L_to_R();
  81   1      //  VSCAN_T_to_B();
  82   1      //  HSCAN_R_to_L();
  83   1      //  VSCAN_B_to_T();
  84   1      
  85   1      
  86   1        /*=====[03h]寄存器=====*/ 
  87   1        Graphic_Mode();
  88   1      //  Text_Mode();
  89   1      
  90   1        /* Memory_Select_SDRAM */
  91   1        Memory_Select_SDRAM();
  92   1      
  93   1      
  94   1      //------------------------------------
  95   1      //** Set color depth, define in [UserDef.h] **//
  96   1      
  97   1        #ifdef MCU_8bit_ColorDepth_8bpp 
                  Select_Main_Window_8bpp();    //[10h] Set main window color depth
                  Memory_8bpp_Mode();       //[5Eh] Set active memory color depth
              
                  Select_PIP1_Window_8bpp();    //[11h] PIP 1 Window Color Depth
                  Select_PIP2_Window_8bpp();    //[11h] PIP 2 Window Color Depth
              
                  BTE_S0_Color_8bpp();      //[92h] Source_0 Color Depth
                  BTE_S1_Color_8bpp();      //[92h] Source_1 Color Depth
                  BTE_Destination_Color_8bpp(); //[92h] Destination Color Depth 
                  
                  IDEC_Destination_Color_8bpp();//
                #endif
 110   1      
 111   1        #if defined (MCU_8bit_ColorDepth_16bpp) || defined (MCU_16bit_ColorDepth_16bpp)
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 3   

                  Select_Main_Window_16bpp();   //[10h]Set main window color depth
                  Memory_16bpp_Mode();      //[5Eh]Set active memory color depth
              
                  Select_PIP1_Window_16bpp();   //[11h] PIP 1 Window Color Depth
                  Select_PIP2_Window_16bpp();   //[11h] PIP 2 Window Color Depth
              
                  BTE_S0_Color_16bpp();     //[92h] Source_0 Color Depth
                  BTE_S1_Color_16bpp();     //[92h] Source_1 Color Depth
                  BTE_Destination_Color_16bpp();  //[92h] Destination Color Depth  
                  
                  IDEC_Destination_Color_16bpp();//
                #endif
 124   1      
 125   1        #if defined (MCU_8bit_ColorDepth_24bpp) || defined (MCU_16bit_ColorDepth_24bpp_Mode_1) || defined (MCU_16
             -bit_ColorDepth_24bpp_Mode_2)  
 126   1          Select_Main_Window_24bpp();   //[10h]Set main window color depth
 127   1          Memory_24bpp_Mode();      //[5Eh]Set active memory color depth
 128   1      
 129   1          Select_PIP1_Window_24bpp();   //[11h] PIP 1 Window Color Depth
 130   1          Select_PIP2_Window_24bpp();   //[11h] PIP 2 Window Color Depth
 131   1      
 132   1          BTE_S0_Color_24bpp();     //[92h] Source_0 Color Depth
 133   1          BTE_S1_Color_24bpp();     //[92h] Source_1 Color Depth
 134   1          BTE_Destination_Color_24bpp();  //[92h] Destination Color Depth    
 135   1          
 136   1          IDEC_Destination_Color_24bpp();//
 137   1        #endif
 138   1      
 139   1        Select_Main_Window_24bpp();
 140   1        Memory_24bpp_Mode();
 141   1      
 142   1      //------------------------------------
 143   1      //**[12h]~[1Fh]]**//
 144   1        Set_LCD_Panel();
 145   1      
 146   1      //------------------------------------
 147   1      //**[20h][21h][22h][23h]**//
 148   1        Main_Image_Start_Address(0);
 149   1      //**[24h][25h]**//          
 150   1        Main_Image_Width(main_image_width);             
 151   1      //**[26h][27h][28h][29h]**//
 152   1        Main_Window_Start_XY(0,0);  
 153   1      //**[50h][51h][52h][53h]**//
 154   1        Canvas_Image_Start_address(0);
 155   1      //**[54h][55h]**//
 156   1        Canvas_image_width(canvas_image_width);
 157   1      //**[56h][57h][58h][59h]**//
 158   1        Active_Window_XY(0,0);
 159   1      //**[5Ah][5Bh][5Ch][5Dh]**//
 160   1        Active_Window_WH(LCD_Width,LCD_Height);
 161   1      
 162   1      //------------------------------------
 163   1      //**[5E]**//
 164   1        Memory_XY_Mode();
 165   1      //  Memory_Linear_Mode();
 166   1      
 167   1      //------------------------------------
 168   1      //**[5Fh][60h][61h][62h]**//
 169   1        Goto_Pixel_XY(0,0);    
 170   1      
 171   1        Display_ON();
 172   1      
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 4   

 173   1        Color_Bar_ON();
 174   1        delay_ms(500);
 175   1        Color_Bar_OFF();
 176   1      }
 177          
 178          
 179          
 180          
 181          
 182          
 183          
 184          /*================================================================*/
 185          //                  BOTTOM LEVEL API FUNCTIONS  
 186          /*================================================================*/
 187          
 188          void LCD_RegisterWrite(unsigned char Cmd,unsigned char Data)
 189          {
 190   1      //  Check_2D_Busy();
 191   1        LCD_CmdWrite(Cmd);
 192   1        LCD_DataWrite(Data);
 193   1      }  
 194          
 195          
 196          unsigned char LCD_RegisterRead(unsigned char Cmd)
 197          {
 198   1        unsigned char temp;
 199   1      //  Check_2D_Busy();
 200   1        LCD_CmdWrite(Cmd);
 201   1        temp=LCD_DataRead();
 202   1      
 203   1        return temp;
 204   1      }
 205          
 206          
 207          void RA8889_SW_Reset(void)
 208          {/*
 209   1      Software Reset
 210   1      0: Normal operation.
 211   1      1: Software Reset.
 212   1      Software Reset only reset internal state machine. Configuration
 213   1      Registers value wonˇt be reset. So all read-only flag in the
 214   1      register will return to its initial value. User should have proper
 215   1      action to make sure flag is in desired state.
 216   1      Note: The bit will auto clear after reset.
 217   1      */  
 218   1        unsigned short i;
 219   1        unsigned char temp;
 220   1        
 221   1        LCD_CmdWrite(0x00);
 222   1        temp = LCD_DataRead();
 223   1        temp |= 0x01;
 224   1        LCD_DataWrite(temp);
 225   1        delay_ms(1);      // it must wait 100us after Software_Reset.
 226   1          
 227   1      #ifdef Check_While_Busy
 228   1        while( LCD_RegisterRead(0x00)&0x01 );
 229   1      #else
                // Please according to your usage to modify delay(check) time.
                for(i=0;i<100;i++)
                {
                  if( (LCD_RegisterRead(0x00)&0x01)==0x00 ) {break;}
                }
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 5   

              #endif
 236   1      }
*** WARNING C280 IN LINE 218 OF RA8889_01_Kernel\RA8889_51.c: 'i': unreferenced local variable
 237          
 238          
 239          void Check_IC_ready(void)
 240          {
 241   1      /*  [Status Register] bit1
 242   1      Operation mode status
 243   1      0: Normal operation state
 244   1      1: Inhibit operation state
 245   1      Inhibit operation state means internal reset event keep running or
 246   1      initial display still running or chip enter power saving state.   
 247   1      */  
 248   1        unsigned short i;
 249   1          
 250   1      #ifdef Check_While_Busy
 251   1        while(LCD_StatusRead() & 0x02);
 252   1      #else
                // Please according to your usage to modify delay(check) time.
                for(i=0;i<1000;i++)
                {
                  if( (LCD_StatusRead()&0x02)==0x00 ){break;}
                }
              #endif  
 259   1      }
*** WARNING C280 IN LINE 248 OF RA8889_01_Kernel\RA8889_51.c: 'i': unreferenced local variable
 260          
 261          
 262          void Check_SDRAM_Ready(void)
 263          {
 264   1      /*  [Status Register] bit2
 265   1      SDRAM ready for access
 266   1      0: SDRAM is not ready for access
 267   1      1: SDRAM is ready for access    
 268   1      */  
 269   1        unsigned short i;
 270   1        
 271   1      #ifdef Check_While_Busy
 272   1        while( (LCD_StatusRead()&0x04) == 0x00 );
 273   1      #else
                // Please according to your usage to modify delay(check) time.
                for(i=0;i<1000;i++)
                {
                  if( (LCD_StatusRead()&0x04)==0x04 ){break;}
                }
              #endif  
 280   1      }
*** WARNING C280 IN LINE 269 OF RA8889_01_Kernel\RA8889_51.c: 'i': unreferenced local variable
 281          
 282          
 283          void Check_Mem_WR_FIFO_not_Full(void)
 284          {
 285   1          /*[Status Register] bit7
 286   1          Host Memory Write FIFO full
 287   1          0: Memory Write FIFO is not full.
 288   1          1: Memory Write FIFO is full.
 289   1          Only when Memory Write FIFO is not full, MPU may write another
 290   1          one pixel.
 291   1          */
 292   1        unsigned short i;
 293   1        
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 6   

 294   1      #ifdef Check_While_Busy
 295   1        while (LCD_StatusRead() & 0x80);
 296   1      #else
                // Please according to your usage to modify delay(check) time. // 依您的使用情r修改绦rg
                for(i=0;i<1000;i++)
                {
                  if( (LCD_StatusRead()&0x80)==0 ){break;}
                }
              #endif  
 303   1      }
*** WARNING C280 IN LINE 292 OF RA8889_01_Kernel\RA8889_51.c: 'i': unreferenced local variable
 304          
 305          
 306          void Check_Mem_WR_FIFO_Empty(void)
 307          {
 308   1          /*[Status Register] bit6
 309   1          Host Memory Write FIFO empty
 310   1          0: Memory Write FIFO is not empty.
 311   1          1: Memory Write FIFO is empty.
 312   1          When Memory Write FIFO is empty, MPU may write 8bpp data 64
 313   1          pixels, or 16bpp data 32 pixels, 24bpp data 16 pixels directly.
 314   1          */
 315   1        unsigned short i;
 316   1      
 317   1      #ifdef Check_While_Busy
 318   1        while ((LCD_StatusRead() & 0x40) == 0x00);
 319   1      #else
                // Please according to your usage to modify delay(check) time. // 依您的使用情r修改绦rg
                for(i=0;i<1000;i++)
                {
                  if ((LCD_StatusRead() & 0x40) == 0x40) { break; }
                }
              #endif  
 326   1      }
*** WARNING C280 IN LINE 315 OF RA8889_01_Kernel\RA8889_51.c: 'i': unreferenced local variable
 327          
 328          
 329          void Check_Mem_RD_FIFO_not_Full(void)
 330          {
 331   1          /*  [Status Register] bit5
 332   1          Host Memory Read FIFO full
 333   1          0: Memory Read FIFO is not full.
 334   1          1: Memory Read FIFO is full.
 335   1          When Memory Read FIFO is full, MPU may read 8bpp data 32
 336   1          pixels, or 16bpp data 16 pixels, 24bpp data 8 pixels directly.
 337   1          */
 338   1        unsigned short i;
 339   1      
 340   1      #ifdef Check_While_Busy
 341   1        while (LCD_StatusRead() & 0x20);
 342   1      #else
                // Please according to your usage to modify delay(check) time. // 依您的使用情r修改绦rg
                for(i=0;i<1000;i++)
                {
                  if ((LCD_StatusRead() & 0x20) == 0x00) { break; }
                }
              #endif  
 349   1      }
*** WARNING C280 IN LINE 338 OF RA8889_01_Kernel\RA8889_51.c: 'i': unreferenced local variable
 350          
 351          
 352          
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 7   

 353          void Check_Mem_RD_FIFO_Full(void)
 354          {
 355   1          /*  [Status Register] bit5
 356   1          Host Memory Read FIFO full
 357   1          0: Memory Read FIFO is not full.
 358   1          1: Memory Read FIFO is full.
 359   1          When Memory Read FIFO is full, MPU may read 8bpp data 32
 360   1          pixels, or 16bpp data 16 pixels, 24bpp data 8 pixels directly.
 361   1          */
 362   1        unsigned short i;
 363   1        
 364   1      #ifdef Check_While_Busy
 365   1        while ((LCD_StatusRead() & 0x20) == 0x00);
 366   1      #else
                // Please according to your usage to modify delay(check) time. // 依您的使用情r修改绦rg
                for(i=0;i<1000;i++)
                {
                  if ((LCD_StatusRead() & 0x20) == 0x20) { break; }
                }
              #endif  
 373   1      }
*** WARNING C280 IN LINE 362 OF RA8889_01_Kernel\RA8889_51.c: 'i': unreferenced local variable
 374          
 375          
 376          void Check_Mem_RD_FIFO_not_Empty(void)
 377          {
 378   1          /*  [Status Register] bit4
 379   1          Host Memory Read FIFO empty
 380   1          0: Memory Read FIFO is not empty.
 381   1          1: Memory Read FIFO is empty.
 382   1          */
 383   1        unsigned short i;
 384   1        
 385   1      #ifdef Check_While_Busy
 386   1          while (LCD_StatusRead() & 0x10);
 387   1      #else
                // Please according to your usage to modify delay(check) time. // 依您的使用情r修改绦rg
                for(i=0;i<1000;i++)
                {
                  if ((LCD_StatusRead() & 0x10) == 0x00) { break; }
                }
              #endif  
 394   1      }
*** WARNING C280 IN LINE 383 OF RA8889_01_Kernel\RA8889_51.c: 'i': unreferenced local variable
 395          
 396          
 397          void Check_2D_Busy(void)
 398          {
 399   1          /*  [Status Register] bit3
 400   1          Core task is busy
 401   1          Following task is running:
 402   1          BTE, Geometry engine, Serial flash DMA, Text write or Graphic write
 403   1          0: task is done or idle.
 404   1          1: task is busy.
 405   1          */
 406   1          unsigned short i, temp;
 407   1          // Please according to your usage to modify delay(check) time. // 依您的使用情r修改绦rg
 408   1      
 409   1      #ifdef Check_While_Busy
 410   1          // case1: using status register
 411   1          do{
 412   2              temp = LCD_StatusRead();
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 8   

 413   2          } while (temp & 0x08);
 414   1      #else
                  for (i = 0; i < 1000; i++)
                  {
                      if ((LCD_StatusRead() & 0x08) == 0x00) { break; }
                  }
              #endif
 420   1      }
*** WARNING C280 IN LINE 406 OF RA8889_01_Kernel\RA8889_51.c: 'i': unreferenced local variable
 421          
 422          
 423          unsigned char Power_Saving_Status(void)
 424          {
 425   1          /*  [Status Register] bit1
 426   1          Operation mode status
 427   1          0: Normal operation state
 428   1          1: Inhibit operation state
 429   1          Inhibit operation state means internal reset event keep running or
 430   1          initial display still running or chip enter power saving state.
 431   1          */
 432   1          unsigned char temp;
 433   1      
 434   1          if ((LCD_StatusRead() & 0x02) == 0x02)
 435   1              temp = 1;
 436   1          else
 437   1              temp = 0;
 438   1      
 439   1          return temp;
 440   1      }
 441          
 442          
 443          void Check_Power_is_Saving(void)
 444          {
 445   1          /*  [Status Register] bit1
 446   1          Operation mode status
 447   1          0: Normal operation state
 448   1          1: Inhibit operation state
 449   1          Inhibit operation state means internal reset event keep running or
 450   1          initial display still running or chip enter power saving state.
 451   1          */
 452   1        unsigned short i;
 453   1        
 454   1      #ifdef Check_While_Busy
 455   1        while ((LCD_StatusRead() & 0x02) == 0x00);
 456   1      #else
                // Please according to your usage to modify delay(check) time. // 依您的使用情r修改绦rg
                for (i = 0; i < 1000; i++)
                {
                  if ((LCD_StatusRead() & 0x02) == 0x02) { break; }
                }
              #endif    
 463   1      }
*** WARNING C280 IN LINE 452 OF RA8889_01_Kernel\RA8889_51.c: 'i': unreferenced local variable
 464          
 465          
 466          void Check_NO_Interrupt(void)
 467          {
 468   1          /*  [Status Register] bit0
 469   1          Interrupt pin state
 470   1          0: without interrupt active
 471   1          1: interrupt active
 472   1          */
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 9   

 473   1        unsigned short i;
 474   1        
 475   1      #ifdef Check_While_Busy
 476   1        while (LCD_StatusRead() & 0x01);
 477   1      #else
                // Please according to your usage to modify delay(check) time. // 依您的使用情r修改绦rg
                for (i = 0; i < 1000; i++)
                {
                  if ((LCD_StatusRead() & 0x01) == 0x00) { break; }
                }
              #endif  
 484   1      }
*** WARNING C280 IN LINE 473 OF RA8889_01_Kernel\RA8889_51.c: 'i': unreferenced local variable
 485          
 486          
 487          void Check_Interrupt_Occur(void)
 488          {
 489   1          /*  [Status Register] bit0
 490   1          Interrupt pin state
 491   1          0: without interrupt active
 492   1          1: interrupt active
 493   1          */
 494   1        unsigned short i;
 495   1        
 496   1      #ifdef Check_While_Busy
 497   1        while ((LCD_StatusRead() & 0x01) == 0x00);
 498   1      #else
                  // Please according to your usage to modify delay(check) time. // 依您的使用情r修改绦rg
                for (i = 0; i < 1000; i++)
                {
                  if ((LCD_StatusRead() & 0x01) == 0x01) { break; }
                }
              #endif  
 505   1      }
*** WARNING C280 IN LINE 494 OF RA8889_01_Kernel\RA8889_51.c: 'i': unreferenced local variable
 506          
 507          
 508          
 509          //void Set_LCD_Panel(void)
 510          //{
 511          //  //**[10h]**//
 512          //  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
 513          ////  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
 514          //  
 515          //  PCLK_Falling();
 516          ////  PCLK_Rising();
 517          
 518          //  VSCAN_T_to_B();
 519          //  PDATA_Set_RGB();
 520          
 521          //  HSYNC_Low_Active();
 522          //  VSYNC_Low_Active();
 523          //  DE_High_Active();
 524          ////  DE_Low_Active();
 525          
 526          //  LCD_HorizontalWidth_VerticalHeight(800,480);
 527          //  LCD_Horizontal_Non_Display(64);
 528          //  LCD_HSYNC_Start_Position(208);
 529          //  LCD_HSYNC_Pulse_Width(24);
 530          //  LCD_Vertical_Non_Display(16);
 531          //  LCD_VSYNC_Start_Position(22);
 532          //  LCD_VSYNC_Pulse_Width(16);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 10  

 533          //}
 534          
 535          
 536          
 537          
 538          
 539          
 540          //[01h][01h][01h][01h][01h][01h][01h][01h][01h][01h][01h][01h][01h][01h][01h][01h]
 541          void Enable_PLL(void)
 542          {
 543   1          /* 1: PLL enable; cannot change PLL parameter.*/
 544   1        unsigned char temp;
 545   1        unsigned short i;
 546   1      
 547   1        LCD_CmdWrite(0x01);
 548   1        temp = LCD_DataRead();
 549   1        temp |= cSetb7;
 550   1        LCD_DataWrite(temp);
 551   1      
 552   1        delay_ms(1); // PLL lock time = 1024 T OSC clocks, if OSC=10MHz, PLL lock time = 100 us.
 553   1      
 554   1      #ifdef Check_While_Busy
 555   1        while ((LCD_RegisterRead(0x01) & 0x80) != 0x80); // check PLL was ready.
 556   1      #else
                /*check PLL was ready ( Please according to your usage to modify. // 依您的使用情r修改)   */
                for (i = 0; i < 1000; i++)
                {
                  LCD_CmdWrite(0x01);
                  temp = LCD_DataRead();
                  if ((temp & 0x80) == 0x80) { break; }
                }
              #endif
 565   1      }
*** WARNING C280 IN LINE 545 OF RA8889_01_Kernel\RA8889_51.c: 'i': unreferenced local variable
 566          
 567          
 568          
 569          
 570          
 571          void Sent_XnWAIT_Status_When_CS_Low(void)
 572          { /*
 573   1           Mask XnWAIT on XnCS deassert
 574   1           0 : No mask
 575   1               XnWAIT keep assert if internal state keep busy and cannot
 576   1               accept next R/W cycle, no matter XnCS assert/deassert. If
 577   1               MCU cycle cannot be extended while XnWAIT keep low, user
 578   1               should poll XnWAIT and wait it goes high then start next
 579   1               access.
 580   1           1 : Mask
 581   1               XnWAIT deassert when XnCS deassert. Use in MCU cycle can
 582   1               be extended by XnWAIT automatically.
 583   1       */
 584   1          unsigned char temp;
 585   1          LCD_CmdWrite(0x01);
 586   1          temp = LCD_DataRead();
 587   1          temp |= cSetb6;
 588   1          LCD_DataWrite(temp);
 589   1      }
 590          void Sent_XnWAIT_Status_At_Any_Time(void)
 591          { /*
 592   1           Mask XnWAIT on XnCS deassert
 593   1           0 : No mask
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 11  

 594   1               XnWAIT keep assert if internal state keep busy and cannot
 595   1               accept next R/W cycle, no matter XnCS assert/deassert. If
 596   1               MCU cycle cannot be extended while XnWAIT keep low, user
 597   1               should poll XnWAIT and wait it goes high then start next
 598   1               access.
 599   1           1 : Mask
 600   1               XnWAIT deassert when XnCS deassert. Use in MCU cycle can
 601   1               be extended by XnWAIT automatically.
 602   1       */
 603   1          unsigned char temp;
 604   1          LCD_CmdWrite(0x01);
 605   1          temp = LCD_DataRead();
 606   1          temp &= cClrb6;
 607   1          LCD_DataWrite(temp);
 608   1      }
 609          void Key_Scan_Enable(void)
 610          {
 611   1          /*  0: Disable.
 612   1              1: Enable.*/
 613   1          unsigned char temp;
 614   1          LCD_CmdWrite(0x01);
 615   1          temp = LCD_DataRead();
 616   1          temp |= cSetb5;
 617   1          LCD_DataWrite(temp);
 618   1      }
 619          void Key_Scan_Disable(void)
 620          {
 621   1          /*  0: Disable.
 622   1              1: Enable.*/
 623   1          unsigned char temp;
 624   1          LCD_CmdWrite(0x01);
 625   1          temp = LCD_DataRead();
 626   1          temp &= cClrb5;
 627   1          LCD_DataWrite(temp);
 628   1      }
 629          void TFT_24bit(void) //
 630          {
 631   1          /*  TFT Panel I/F Output pin Setting
 632   1          00b: 24-bits TFT output.
 633   1          01b: 18-bits TFT output.
 634   1          10b: 16-bits TFT output.
 635   1          11b: w/o TFT output.
 636   1          Other unused TFT output pins are set as GPIO or Key function.*/
 637   1          unsigned char temp;
 638   1          LCD_CmdWrite(0x01);
 639   1          temp = LCD_DataRead();
 640   1          temp &= cClrb4;
 641   1          temp &= cClrb3;
 642   1          LCD_DataWrite(temp);
 643   1      }
 644          void TFT_18bit(void)
 645          {
 646   1          /*  TFT Panel I/F Output pin Setting
 647   1          00b: 24-bits TFT output.
 648   1          01b: 18-bits TFT output.
 649   1          10b: 16-bits TFT output.
 650   1          11b: w/o TFT output.
 651   1          Other unused TFT output pins are set as GPIO or Key function.*/
 652   1          unsigned char temp;
 653   1          LCD_CmdWrite(0x01);
 654   1          temp = LCD_DataRead();
 655   1          temp &= cClrb4;
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 12  

 656   1          temp |= cSetb3;
 657   1          LCD_DataWrite(temp);
 658   1      }
 659          void TFT_16bit(void)
 660          {
 661   1          /*  TFT Panel I/F Output pin Setting
 662   1          00b: 24-bits TFT output.
 663   1          01b: 18-bits TFT output.
 664   1          10b: 16-bits TFT output.
 665   1          11b: w/o TFT output.
 666   1          Other unused TFT output pins are set as GPIO or Key function.*/
 667   1          unsigned char temp;
 668   1          LCD_CmdWrite(0x01);
 669   1          temp = LCD_DataRead();
 670   1          temp |= cSetb4;
 671   1          temp &= cClrb3;
 672   1          LCD_DataWrite(temp);
 673   1      }
 674          void Without_TFT(void)
 675          {
 676   1          /*  TFT Panel I/F Output pin Setting
 677   1          00b: 24-bits TFT output.
 678   1          01b: 18-bits TFT output.
 679   1          10b: 16-bits TFT output.
 680   1          11b: w/o TFT output.
 681   1          Other unused TFT output pins are set as GPIO or Key function.*/
 682   1          unsigned char temp;
 683   1          LCD_CmdWrite(0x01);
 684   1          temp = LCD_DataRead();
 685   1          temp |= cSetb4;
 686   1          temp |= cSetb3;
 687   1          LCD_DataWrite(temp);
 688   1      }
 689          
 690          void RA8889_I2CM_Enable(void)
 691          {
 692   1          /*  I2C master Interface Enable/Disable
 693   1                  0: Disable (GPIO function)
 694   1                  1: Enable (I2C master function)*/
 695   1          unsigned char temp;
 696   1          LCD_CmdWrite(0x01);
 697   1          temp = LCD_DataRead();
 698   1          temp |= cSetb2;
 699   1          LCD_DataWrite(temp);
 700   1      }
 701          
 702          void RA8889_I2CM_Disable(void)
 703          {
 704   1          /*  I2C master Interface Enable/Disable
 705   1                  0: Disable (GPIO function)
 706   1                  1: Enable (I2C master function)*/
 707   1          unsigned char temp;
 708   1          LCD_CmdWrite(0x01);
 709   1          temp = LCD_DataRead();
 710   1          temp &= cClrb2;
 711   1          LCD_DataWrite(temp);
 712   1      }
 713          
 714          void Enable_SFlash_SPI(void)
 715          {
 716   1          /*  Serial Flash or SPI Interface Enable/Disable
 717   1                  0: Disable (GPIO function)
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 13  

 718   1                  1: Enable (SPI master function)
 719   1                  When SDR SDRAM 32bits bus function enable, this bit is ignored
 720   1                  & Serial flash pins become SDR SDRAM bus function.*/
 721   1          unsigned char temp;
 722   1          LCD_CmdWrite(0x01);
 723   1          temp = LCD_DataRead();
 724   1          temp |= cSetb1;
 725   1          LCD_DataWrite(temp);
 726   1      }
 727          
 728          void Disable_SFlash_SPI(void)
 729          {
 730   1          /*  Serial Flash or SPI Interface Enable/Disable
 731   1                  0: Disable (GPIO function)
 732   1                  1: Enable (SPI master function)
 733   1                  When SDR SDRAM 32bits bus function enable, this bit is ignored
 734   1                  & Serial flash pins become SDR SDRAM bus function.*/
 735   1          unsigned char temp;
 736   1          LCD_CmdWrite(0x01);
 737   1          temp = LCD_DataRead();
 738   1          temp &= cClrb1;
 739   1          LCD_DataWrite(temp);
 740   1      }
 741          void Host_Bus_8bit(void)
 742          {
 743   1          /*  Parallel Host Data Bus Width Selection
 744   1              0: 8-bit Parallel Host Data Bus.
 745   1              1: 16-bit Parallel Host Data Bus.*/
 746   1          unsigned char temp;
 747   1          LCD_CmdWrite(0x01);
 748   1          temp = LCD_DataRead();
 749   1          temp &= cClrb0;
 750   1          LCD_DataWrite(temp);
 751   1      }
 752          void Host_Bus_16bit(void)
 753          {
 754   1          /*  Parallel Host Data Bus Width Selection
 755   1              0: 8-bit Parallel Host Data Bus.
 756   1              1: 16-bit Parallel Host Data Bus.*/
 757   1          unsigned char temp;
 758   1          LCD_CmdWrite(0x01);
 759   1          temp = LCD_DataRead();
 760   1          temp |= cSetb0;
 761   1          LCD_DataWrite(temp);
 762   1      }
 763          
 764          //[02h][02h][02h][02h][02h][02h][02h][02h][02h][02h][02h][02h][02h][02h][02h][02h]
 765          
 766          void Data_Format_8b_8bpp(void)
 767          {
 768   1          /* MPU read/write data format when access memory data port.
 769   1          0xb: Direct write for
 770   1              all 8 bits MPU I/F,
 771   1              16 bits MPU I/F with 8bpp data mode 2,
 772   1              16 bits MPU I/F with 16bpp,
 773   1              16 bits MPU I/F with 24bpp data mode 1,
 774   1              and serial host interface.                */
 775   1          unsigned char temp;
 776   1          LCD_CmdWrite(0x02);
 777   1          temp = LCD_DataRead();
 778   1          temp &= cClrb7;
 779   1          LCD_DataWrite(temp);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 14  

 780   1      }
 781          void Data_Format_8b_16bpp(void)
 782          {
 783   1          /* MPU read/write data format when access memory data port.
 784   1          0xb: Direct write for
 785   1              all 8 bits MPU I/F,
 786   1              16 bits MPU I/F with 8bpp data mode 2,
 787   1              16 bits MPU I/F with 16bpp,
 788   1              16 bits MPU I/F with 24bpp data mode 1,
 789   1              and serial host interface.                */
 790   1          unsigned char temp;
 791   1          LCD_CmdWrite(0x02);
 792   1          temp = LCD_DataRead();
 793   1          temp &= cClrb7;
 794   1          LCD_DataWrite(temp);
 795   1      }
 796          void Data_Format_8b_24bpp(void)
 797          {
 798   1          /* MPU read/write data format when access memory data port.
 799   1          0xb: Direct write for
 800   1              all 8 bits MPU I/F,
 801   1              16 bits MPU I/F with 8bpp data mode 2,
 802   1              16 bits MPU I/F with 16bpp,
 803   1              16 bits MPU I/F with 24bpp data mode 1,
 804   1              and serial host interface.                */
 805   1          unsigned char temp;
 806   1          LCD_CmdWrite(0x02);
 807   1          temp = LCD_DataRead();
 808   1          temp &= cClrb7;
 809   1          LCD_DataWrite(temp);
 810   1      }
 811          
 812          void Data_Format_16b_8bpp(void)
 813          {
 814   1          /* MPU read/write data format when access memory data port.
 815   1          10b: Mask high byte of each data (ex. 16 bit MPU I/F with 8-bpp data mode 1)  */
 816   1          unsigned char temp;
 817   1          LCD_CmdWrite(0x02);
 818   1          temp = LCD_DataRead();
 819   1          temp |= cSetb7;
 820   1          temp &= cClrb6;
 821   1          LCD_DataWrite(temp);
 822   1      }
 823          void Data_Format_16b_16bpp(void)
 824          {
 825   1          /* MPU read/write data format when access memory data port.
 826   1          0xb: Direct write for
 827   1              all 8 bits MPU I/F,
 828   1              16 bits MPU I/F with 8bpp data mode 2,
 829   1              16 bits MPU I/F with 16bpp,
 830   1              16 bits MPU I/F with 24bpp data mode 1,
 831   1              and serial host interface.                */
 832   1          unsigned char temp;
 833   1          LCD_CmdWrite(0x02);
 834   1          temp = LCD_DataRead();
 835   1          temp &= cClrb7;
 836   1          //  temp |= cSetb6;
 837   1          LCD_DataWrite(temp);
 838   1      }
 839          void Data_Format_16b_24bpp_mode1(void)
 840          {
 841   1          /* MPU read/write data format when access memory data port.
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 15  

 842   1          0xb: Direct write for
 843   1              all 8 bits MPU I/F,
 844   1              16 bits MPU I/F with 8bpp data mode 2,
 845   1              16 bits MPU I/F with 16bpp,
 846   1              16 bits MPU I/F with 24bpp data mode 1,
 847   1              and serial host interface.                */
 848   1          unsigned char temp;
 849   1          LCD_CmdWrite(0x02);
 850   1          temp = LCD_DataRead();
 851   1          temp &= cClrb7;
 852   1          //  temp &= cClrb6;
 853   1          LCD_DataWrite(temp);
 854   1      }
 855          void Data_Format_16b_24bpp_mode2(void)
 856          {
 857   1          /* MPU read/write data format when access memory data port.
 858   1          11b: Mask high byte of even data (ex. 16 bit MPU I/F with 24-bpp data mode 2) */
 859   1          unsigned char temp;
 860   1          LCD_CmdWrite(0x02);
 861   1          temp = LCD_DataRead();
 862   1          temp |= cSetb7;
 863   1          temp |= cSetb6;
 864   1          LCD_DataWrite(temp);
 865   1      }
 866          
 867          void MemRead_Left_Right_Top_Down(void)
 868          {
 869   1          /* Host Read Memory Direction (Only for Graphic Mode)
 870   1          00b: Left .. Right then Top .. Bottom.
 871   1          Ignored if canvas in linear addressing mode.    */
 872   1          unsigned char temp;
 873   1          LCD_CmdWrite(0x02);
 874   1          temp = LCD_DataRead();
 875   1          temp &= cClrb5;
 876   1          temp &= cClrb4;
 877   1          LCD_DataWrite(temp);
 878   1      }
 879          void MemRead_Right_Left_Top_Down(void)
 880          {
 881   1          /* Host Read Memory Direction (Only for Graphic Mode)
 882   1          01b: Right .. Left then Top ..Bottom.
 883   1          Ignored if canvas in linear addressing mode.    */
 884   1          unsigned char temp;
 885   1          LCD_CmdWrite(0x02);
 886   1          temp = LCD_DataRead();
 887   1          temp &= cClrb5;
 888   1          temp |= cSetb4;
 889   1          LCD_DataWrite(temp);
 890   1      }
 891          void MemRead_Top_Down_Left_Right(void)
 892          {
 893   1          /* Host Read Memory Direction (Only for Graphic Mode)
 894   1          10b: Top .. Bottom then Left .. Right.
 895   1          Ignored if canvas in linear addressing mode.    */
 896   1          unsigned char temp;
 897   1          LCD_CmdWrite(0x02);
 898   1          temp = LCD_DataRead();
 899   1          temp |= cSetb5;
 900   1          temp &= cClrb4;
 901   1          LCD_DataWrite(temp);
 902   1      }
 903          void MemRead_Down_Top_Left_Right(void)
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 16  

 904          {
 905   1          /* Host Read Memory Direction (Only for Graphic Mode)
 906   1          11b: Bottom .. Top then Left .. Right.
 907   1          Ignored if canvas in linear addressing mode.    */
 908   1          unsigned char temp;
 909   1          LCD_CmdWrite(0x02);
 910   1          temp = LCD_DataRead();
 911   1          temp |= cSetb5;
 912   1          temp |= cSetb4;
 913   1          LCD_DataWrite(temp);
 914   1      }
 915          void MemWrite_Left_Right_Top_Down(void)
 916          {
 917   1          /* Host Write Memory Direction (Only for Graphic Mode)
 918   1          00b: Left .. Right then Top ..Bottom.
 919   1          Ignored if canvas in linear addressing mode.    */
 920   1          unsigned char temp;
 921   1          LCD_CmdWrite(0x02);
 922   1          temp = LCD_DataRead();
 923   1          temp &= cClrb2;
 924   1          temp &= cClrb1;
 925   1          LCD_DataWrite(temp);
 926   1      }
 927          void MemWrite_Right_Left_Top_Down(void)
 928          {
 929   1          /* Host Write Memory Direction (Only for Graphic Mode)
 930   1          01b: Right .. Left then Top .. Bottom.
 931   1          Ignored if canvas in linear addressing mode.    */
 932   1          unsigned char temp;
 933   1          LCD_CmdWrite(0x02);
 934   1          temp = LCD_DataRead();
 935   1          temp &= cClrb2;
 936   1          temp |= cSetb1;
 937   1          LCD_DataWrite(temp);
 938   1      }
 939          void MemWrite_Top_Down_Left_Right(void)
 940          {
 941   1          /* Host Write Memory Direction (Only for Graphic Mode)
 942   1          10b: Top .. Bottom then Left .. Right.
 943   1          Ignored if canvas in linear addressing mode.    */
 944   1          unsigned char temp;
 945   1          LCD_CmdWrite(0x02);
 946   1          temp = LCD_DataRead();
 947   1          temp |= cSetb2;
 948   1          temp &= cClrb1;
 949   1          LCD_DataWrite(temp);
 950   1      }
 951          void MemWrite_Down_Top_Left_Right(void)
 952          {
 953   1          /* Host Write Memory Direction (Only for Graphic Mode)
 954   1          11b: Bottom .. Top then Left .. Right.
 955   1          Ignored if canvas in linear addressing mode.    */
 956   1          unsigned char temp;
 957   1          LCD_CmdWrite(0x02);
 958   1          temp = LCD_DataRead();
 959   1          temp |= cSetb2;
 960   1          temp |= cSetb1;
 961   1          LCD_DataWrite(temp);
 962   1      }
 963          //[03h][03h][03h][03h][03h][03h][03h][03h][03h][03h][03h][03h][03h][03h][03h][03h]
 964          void Interrupt_Active_Low(void)
 965          {
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 17  

 966   1          /*  Output to MPU Interrupt active level
 967   1              0 : active low.
 968   1              1 : active high.            */
 969   1          unsigned char temp;
 970   1          LCD_CmdWrite(0x03);
 971   1          temp = LCD_DataRead();
 972   1          temp &= cClrb7;
 973   1          LCD_DataWrite(temp);
 974   1      }
 975          void Interrupt_Active_High(void)
 976          {
 977   1          /*  Output to MPU Interrupt active level
 978   1              0 : active low.
 979   1              1 : active high.            */
 980   1          unsigned char temp;
 981   1          LCD_CmdWrite(0x03);
 982   1          temp = LCD_DataRead();
 983   1          temp |= cSetb7;
 984   1          LCD_DataWrite(temp);
 985   1      }
 986          void ExtInterrupt_Debounce(void)
 987          {
 988   1          /*  External interrupt input (XPS[0] pin) de-bounce
 989   1              0 : without de-bounce
 990   1              1 : enable de-bounce (1024 OSC clock)     */
 991   1          unsigned char temp;
 992   1          LCD_CmdWrite(0x03);
 993   1          temp = LCD_DataRead();
 994   1          temp |= cSetb6;
 995   1          LCD_DataWrite(temp);
 996   1      }
 997          void ExtInterrupt_Nodebounce(void)
 998          {
 999   1          /*  External interrupt input (XPS[0] pin) de-bounce
1000   1              0 : without de-bounce
1001   1              1 : enable de-bounce (1024 OSC clock)     */
1002   1          unsigned char temp;
1003   1          LCD_CmdWrite(0x03);
1004   1          temp = LCD_DataRead();
1005   1          temp &= cClrb6;
1006   1          LCD_DataWrite(temp);
1007   1      }
1008          void ExtInterrupt_Input_Low_Level_Trigger(void)
1009          {
1010   1          /* External interrupt input (XPS[0] pin) trigger type
1011   1          00 : low level trigger
1012   1          */
1013   1          unsigned char temp;
1014   1          LCD_CmdWrite(0x03);
1015   1          temp = LCD_DataRead();
1016   1          temp &= cClrb5;
1017   1          temp &= cClrb4;
1018   1          LCD_DataWrite(temp);
1019   1      }
1020          void ExtInterrupt_Input_High_Level_Trigger(void)
1021          {
1022   1          /* External interrupt input (XPS[0] pin) trigger type
1023   1          01 : falling edge trigger
1024   1          */
1025   1          unsigned char temp;
1026   1          LCD_CmdWrite(0x03);
1027   1      
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 18  

1028   1          temp = LCD_DataRead();
1029   1          temp |= cSetb5;
1030   1          temp &= cClrb4;
1031   1          LCD_DataWrite(temp);
1032   1      }
1033          void ExtInterrupt_Input_Falling_Edge_Trigger(void)
1034          {
1035   1          /* External interrupt input (XPS[0] pin) trigger type
1036   1          10 : high level trigger
1037   1          */
1038   1          unsigned char temp;
1039   1          LCD_CmdWrite(0x03);
1040   1          temp = LCD_DataRead();
1041   1          temp &= cClrb5;
1042   1          temp |= cSetb4;
1043   1          LCD_DataWrite(temp);
1044   1      }
1045          void ExtInterrupt_Input_Rising_Edge_Trigger(void)
1046          {
1047   1          /* External interrupt input (XPS[0] pin) trigger type
1048   1          11 : rising edge trigger
1049   1          */
1050   1          unsigned char temp;
1051   1          LCD_CmdWrite(0x03);
1052   1          temp = LCD_DataRead();
1053   1          temp |= cSetb5;
1054   1          temp |= cSetb4;
1055   1          LCD_DataWrite(temp);
1056   1      }
1057          void LVDS_Format1(void) // RA8877 only
1058          {
1059   1          /* FPD-Link Data Format / LVDS Data Format
1060   1          0 : Format 1 (VESA format)
1061   1          1 : Format 2 (JEIDA format)         */
1062   1          unsigned char temp;
1063   1          LCD_CmdWrite(0x03);
1064   1          temp = LCD_DataRead();
1065   1          temp &= cClrb3;
1066   1          LCD_DataWrite(temp);
1067   1      }
1068          void LVDS_Format2(void) // RA8877 only
1069          {
1070   1          /* FPD-Link Data Format / LVDS Data Format
1071   1          0 : Format 1 (VESA format)
1072   1          1 : Format 2 (JEIDA format)         */
1073   1          unsigned char temp;
1074   1          LCD_CmdWrite(0x03);
1075   1          temp = LCD_DataRead();
1076   1          temp |= cSetb3;
1077   1          LCD_DataWrite(temp);
1078   1      }
1079          void Graphic_Mode(void)
1080          {
1081   1          unsigned char temp;
1082   1          LCD_CmdWrite(0x03);
1083   1          temp = LCD_DataRead();
1084   1          temp &= cClrb2;
1085   1          LCD_DataWrite(temp);
1086   1      }
1087          void Text_Mode(void)
1088          {
1089   1          unsigned char temp;
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 19  

1090   1          LCD_CmdWrite(0x03);
1091   1          temp = LCD_DataRead();
1092   1          temp |= cSetb2;
1093   1          LCD_DataWrite(temp);
1094   1      }
1095          void Memory_Select_SDRAM(void)
1096          {
1097   1          unsigned char temp;
1098   1      
1099   1          LCD_CmdWrite(0x03);
1100   1          temp = LCD_DataRead();
1101   1          temp &= cClrb1;
1102   1          temp &= cClrb0;
1103   1          LCD_DataWrite(temp);
1104   1      }
1105          void Memory_Select_Gamma_Table(void)
1106          {
1107   1          unsigned char temp;
1108   1          LCD_CmdWrite(0x03);
1109   1          temp = LCD_DataRead();
1110   1          temp &= cClrb1;
1111   1          temp |= cSetb0;
1112   1          LCD_DataWrite(temp);
1113   1      }
1114          void Memory_Select_Graphic_Cursor_RAM(void)
1115          {
1116   1          unsigned char temp;
1117   1          LCD_CmdWrite(0x03);
1118   1          temp = LCD_DataRead();
1119   1          temp |= cSetb1;
1120   1          temp &= cClrb0;
1121   1          LCD_DataWrite(temp);
1122   1      }
1123          void Memory_Select_Color_Palette_RAM(void)
1124          {
1125   1          unsigned char temp;
1126   1          LCD_CmdWrite(0x03);
1127   1          temp = LCD_DataRead();
1128   1          temp |= cSetb1;
1129   1          temp |= cSetb0;
1130   1          LCD_DataWrite(temp);
1131   1      }
1132          
1133          //[05h]=========================================================================
1134          //[06h]=========================================================================
1135          //[07h]=========================================================================
1136          //[08h]=========================================================================
1137          //[09h]=========================================================================
1138          //[0Ah]=========================================================================
1139          //[0Bh]=========================================================================
1140          
1141          void Enable_Resume_Interrupt(void)
1142          {
1143   1          /*
1144   1          Wakeup/resume Interrupt Enable
1145   1          0: Disable.
1146   1          1: Enable.
1147   1          */
1148   1          unsigned char temp;
1149   1          LCD_CmdWrite(0x0B);
1150   1          temp = LCD_DataRead();
1151   1          temp |= cSetb7;
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 20  

1152   1          LCD_DataWrite(temp);
1153   1      }
1154          void Disable_Resume_Interrupt(void)
1155          {
1156   1          /*
1157   1          Wakeup/resume Interrupt Enable
1158   1          0: Disable.
1159   1          1: Enable.
1160   1          */
1161   1          unsigned char temp;
1162   1          LCD_CmdWrite(0x0B);
1163   1          temp = LCD_DataRead();
1164   1          temp &= cClrb7;
1165   1          LCD_DataWrite(temp);
1166   1      }
1167          void Enable_ExtInterrupt_Input(void)
1168          {
1169   1          /*
1170   1          External Interrupt (PS[0] pin) Enable
1171   1          0: Disable.
1172   1          1: Enable.
1173   1          */
1174   1          unsigned char temp;
1175   1          LCD_CmdWrite(0x0B);
1176   1          temp = LCD_DataRead();
1177   1          temp |= cSetb6;
1178   1          LCD_DataWrite(temp);
1179   1      }
1180          void Disable_ExtInterrupt_Input(void)
1181          {
1182   1          /*
1183   1          External Interrupt (PS[0] pin) Enable
1184   1          0: Disable.
1185   1          1: Enable.
1186   1          */
1187   1          unsigned char temp;
1188   1          LCD_CmdWrite(0x0B);
1189   1          temp = LCD_DataRead();
1190   1          temp &= cClrb6;
1191   1          LCD_DataWrite(temp);
1192   1      }
1193          void Enable_I2CM_Interrupt(void)
1194          {
1195   1          /*
1196   1          I2C Master Interrupt Enable
1197   1          0: Disable.
1198   1          1: Enable.
1199   1          */
1200   1          unsigned char temp;
1201   1          LCD_CmdWrite(0x0B);
1202   1          temp = LCD_DataRead();
1203   1          temp |= cSetb5;
1204   1          LCD_DataWrite(temp);
1205   1      }
1206          void Disable_I2CM_Interrupt(void)
1207          {
1208   1          /*
1209   1          I2C Master Interrupt Enable
1210   1          0: Disable.
1211   1          1: Enable.
1212   1          */
1213   1          unsigned char temp;
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 21  

1214   1          LCD_CmdWrite(0x0B);
1215   1          temp = LCD_DataRead();
1216   1          temp &= cClrb5;
1217   1          LCD_DataWrite(temp);
1218   1      }
1219          void Enable_Vsync_Interrupt(void)
1220          {
1221   1          /*
1222   1          Vsync time base interrupt Enable Bit
1223   1          0: Disable Interrupt.
1224   1          1: Enable Interrupt.
1225   1          */
1226   1          unsigned char temp;
1227   1          LCD_CmdWrite(0x0B);
1228   1          temp = LCD_DataRead();
1229   1          temp |= cSetb4;
1230   1          LCD_DataWrite(temp);
1231   1      }
1232          void Disable_Vsync_Interrupt(void)
1233          {
1234   1          /*
1235   1          Vsync time base interrupt Enable Bit
1236   1          0: Disable Interrupt.
1237   1          1: Enable Interrupt.
1238   1          */
1239   1          unsigned char temp;
1240   1          LCD_CmdWrite(0x0B);
1241   1          temp = LCD_DataRead();
1242   1          temp &= cClrb4;
1243   1          LCD_DataWrite(temp);
1244   1      }
1245          void Enable_KeyScan_Interrupt(void)
1246          {
1247   1          /*
1248   1          Key Scan Interrupt Enable Bit
1249   1          0: Disable Key scan interrupt.
1250   1          1: Enable Key scan interrupt.
1251   1          */
1252   1          unsigned char temp;
1253   1          LCD_CmdWrite(0x0B);
1254   1          temp = LCD_DataRead();
1255   1          temp |= cSetb3;
1256   1          LCD_DataWrite(temp);
1257   1      }
1258          void Disable_KeyScan_Interrupt(void)
1259          {
1260   1          /*
1261   1          Key Scan Interrupt Enable Bit
1262   1          0: Disable Key scan interrupt.
1263   1          1: Enable Key scan interrupt.
1264   1          */
1265   1          unsigned char temp;
1266   1          LCD_CmdWrite(0x0B);
1267   1          temp = LCD_DataRead();
1268   1          temp &= cClrb3;
1269   1          LCD_DataWrite(temp);
1270   1      }
1271          void Enable_DMA_Draw_BTE_Interrupt(void)
1272          {
1273   1          /*
1274   1          Serial flash DMA Complete | Draw task finished | BTE Process
1275   1          Complete etc. Interrupt Enable
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 22  

1276   1          0: Disable Interrupt.
1277   1          1: Enable Interrupt.
1278   1          */
1279   1          unsigned char temp;
1280   1          LCD_CmdWrite(0x0B);
1281   1          temp = LCD_DataRead();
1282   1          temp |= cSetb2;
1283   1          LCD_DataWrite(temp);
1284   1      }
1285          void Disable_DMA_Draw_BTE_Interrupt(void)
1286          {
1287   1          /*
1288   1          Serial flash DMA Complete | Draw task finished | BTE Process
1289   1          Complete etc. Interrupt Enable
1290   1          0: Disable Interrupt.
1291   1          1: Enable Interrupt.
1292   1          */
1293   1          unsigned char temp;
1294   1          LCD_CmdWrite(0x0B);
1295   1          temp = LCD_DataRead();
1296   1          temp &= cClrb2;
1297   1          LCD_DataWrite(temp);
1298   1      }
1299          void Enable_PWM1_Interrupt(void)
1300          {
1301   1          /*
1302   1          PWM timer 1 Interrupt Enable Bit
1303   1          0: Disable Interrupt.
1304   1          1: Enable Interrupt.
1305   1          */
1306   1          unsigned char temp;
1307   1          LCD_CmdWrite(0x0B);
1308   1          temp = LCD_DataRead();
1309   1          temp |= cSetb1;
1310   1          LCD_DataWrite(temp);
1311   1      }
1312          void Disable_PWM1_Interrupt(void)
1313          {
1314   1          /*
1315   1          PWM timer 1 Interrupt Enable Bit
1316   1          0: Disable Interrupt.
1317   1          1: Enable Interrupt.
1318   1          */
1319   1          unsigned char temp;
1320   1          LCD_CmdWrite(0x0B);
1321   1          temp = LCD_DataRead();
1322   1          temp &= cClrb1;
1323   1          LCD_DataWrite(temp);
1324   1      }
1325          void Enable_PWM0_Interrupt(void)
1326          {
1327   1          /*
1328   1          PWM timer 0 Interrupt Enable Bit
1329   1          0: Disable Interrupt.
1330   1          1: Enable Interrupt.
1331   1          */
1332   1          unsigned char temp;
1333   1          LCD_CmdWrite(0x0B);
1334   1          temp = LCD_DataRead();
1335   1          temp |= cSetb0;
1336   1          LCD_DataWrite(temp);
1337   1      }
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 23  

1338          void Disable_PWM0_Interrupt(void)
1339          {
1340   1          /*
1341   1          PWM timer 0 Interrupt Enable Bit
1342   1          0: Disable Interrupt.
1343   1          1: Enable Interrupt.
1344   1          */
1345   1          unsigned char temp;
1346   1          LCD_CmdWrite(0x0B);
1347   1          temp = LCD_DataRead();
1348   1          temp &= cClrb0;
1349   1          LCD_DataWrite(temp);
1350   1      }
1351          
1352          //[0Ch]=========================================================================
1353          unsigned char Read_Interrupt_status(void)
1354          {
1355   1          /*
1356   1          [Bit7]Read Function ..Resume Interrupt Status
1357   1          0: No Resume interrupt happens.
1358   1          1: Resume interrupt happens.
1359   1          [Bit6]Read Function .. PS[0] pin Interrupt Status
1360   1          0: No PS[0] pin interrupt happens.
1361   1          1: PS[0] pin interrupt happens.
1362   1          [Bit5]Read Function .. I2C master Interrupt Status
1363   1          0: No I2C master interrupt happens.
1364   1          1: I2C master interrupt happens.
1365   1          [Bit4]Read Function .. Vsync Interrupt Status
1366   1          0: No interrupt happens.
1367   1          1: interrupt happens.
1368   1          [Bit3]Read Function ..Key Scan Interrupt Status
1369   1          0: No Key Scan interrupt happens.
1370   1          1: Key Scan interrupt happens.
1371   1          [Bit2]Read Function..Interrupt Status
1372   1          0: No interrupt happens.
1373   1          1: interrupt happens.
1374   1          [Bit1]Read Function..Interrupt Status
1375   1          0: No interrupt happens.
1376   1          1: interrupt happens.
1377   1          [Bit0]Read Function..Interrupt Status
1378   1          0: No interrupt happens.
1379   1          1: interrupt happens.
1380   1          */
1381   1          unsigned char temp;
1382   1          LCD_CmdWrite(0x0C);
1383   1          temp = LCD_DataRead();
1384   1          return temp;
1385   1      }
1386          
1387          void Check_Vsync_finished(void)
1388          {
1389   1          /*[Bit4]
1390   1          Vsync Time base interrupt flag
1391   1          Read Function .. Vsync Interrupt Status
1392   1          0: No interrupt happens.
1393   1          1: interrupt happens.
1394   1          */
1395   1          unsigned char temp;
1396   1          LCD_CmdWrite(0x0C);
1397   1          LCD_DataWrite(0x10);
1398   1          do {
1399   2              temp = LCD_DataRead();
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 24  

1400   2      
1401   2          } while ((temp & 0x10) == 0x00);
1402   1      }
1403          
1404          void Clear_Resume_Interrupt_Flag(void)
1405          {
1406   1          /*
1407   1          Resume Interrupt flag
1408   1          Write Function .. Resume Interrupt Clear Bit
1409   1          0: No operation.
1410   1          1: Clear Resume interrupt.
1411   1          */
1412   1          unsigned char temp;
1413   1          LCD_CmdWrite(0x0C);
1414   1          temp = LCD_DataRead();
1415   1          temp |= cSetb7;
1416   1          LCD_DataWrite(temp);
1417   1      }
1418          void Clear_ExtInterrupt_Input_Flag(void)
1419          {
1420   1          /*
1421   1          External Interrupt (PS[0] pin) flag
1422   1          Write Function .. PS[0] pin edge Interrupt Clear Bit
1423   1          0: No operation.
1424   1          1: Clear the PS[0] pin edge interrupt.
1425   1          */
1426   1          unsigned char temp;
1427   1          LCD_CmdWrite(0x0C);
1428   1          temp = LCD_DataRead();
1429   1          temp |= cSetb6;
1430   1          LCD_DataWrite(temp);
1431   1      }
1432          void Clear_I2CM_Interrupt_Flag(void)
1433          {
1434   1          /*
1435   1          I2C master Interrupt flag
1436   1          Write Function.. I2C master Interrupt Clear Bit
1437   1          0: No operation.
1438   1          1: Clear the I2C master interrupt.
1439   1          */
1440   1          unsigned char temp;
1441   1          LCD_CmdWrite(0x0C);
1442   1          temp = LCD_DataRead();
1443   1          temp |= cSetb5;
1444   1          LCD_DataWrite(temp);
1445   1      }
1446          void Clear_Vsync_Interrupt_Flag(void)
1447          {
1448   1          /*
1449   1          Vsync Time base interrupt flag
1450   1          Write Function ..Vsync Interrupt Clear Bit
1451   1          0: No operation.
1452   1          1: Clear the interrupt.
1453   1          */
1454   1          unsigned char temp;
1455   1          LCD_CmdWrite(0x0C);
1456   1          temp = LCD_DataRead();
1457   1          temp |= cSetb4;
1458   1          LCD_DataWrite(temp);
1459   1      }
1460          void Clear_KeyScan_Interrupt_Flag(void)
1461          {
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 25  

1462   1          /*
1463   1          Key Scan Interrupt flag
1464   1          Write Function..Key Scan Interrupt Clear Bit
1465   1          0: No operation.
1466   1          1: Clear the Key Scan interrupt.
1467   1          */
1468   1          unsigned char temp;
1469   1          LCD_CmdWrite(0x0C);
1470   1          temp = LCD_DataRead();
1471   1          temp |= cSetb3;
1472   1          LCD_DataWrite(temp);
1473   1      }
1474          unsigned char Chk_Key_Press(void)
1475          {
1476   1          unsigned char temp;
1477   1          LCD_CmdWrite(0x0C);
1478   1          temp = LCD_DataRead();
1479   1      
1480   1          if ((temp & 0x08) == 0x08)
1481   1              return 1;
1482   1          else
1483   1              return 0;
1484   1      }
1485          
1486          void Clear_DMA_Draw_BTE_Interrupt_Flag(void)
1487          {
1488   1          /*
1489   1          Serial flash DMA Complete | Draw task finished | BTE
1490   1          Process Complete etc. Interrupt flag
1491   1          Write Function.. Interrupt Clear Bit
1492   1          0: No operation.
1493   1          1: Clear interrupt.
1494   1          */
1495   1          unsigned char temp;
1496   1          LCD_CmdWrite(0x0C);
1497   1          temp = LCD_DataRead();
1498   1          temp |= cSetb2;
1499   1          LCD_DataWrite(temp);
1500   1      }
1501          void Clear_PWM1_Interrupt_Flag(void)
1502          {
1503   1          /*
1504   1          PWM 1 timer Interrupt flag
1505   1          Write Function..Interrupt Clear Bit
1506   1          0: No operation.
1507   1          1: Clear interrupt.
1508   1          */
1509   1          unsigned char temp;
1510   1          LCD_CmdWrite(0x0C);
1511   1          temp = LCD_DataRead();
1512   1          temp |= cSetb1;
1513   1          LCD_DataWrite(temp);
1514   1      }
1515          void Clear_PWM0_Interrupt_Flag(void)
1516          {
1517   1          /*
1518   1          PWM 0 timer Interrupt flag
1519   1          Write Function..Interrupt Clear Bit
1520   1          0: No operation.
1521   1          1: Clear interrupt.
1522   1          */
1523   1          unsigned char temp;
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 26  

1524   1          LCD_CmdWrite(0x0C);
1525   1          temp = LCD_DataRead();
1526   1          temp |= cSetb0;
1527   1          LCD_DataWrite(temp);
1528   1      }
1529          //[0Dh]=========================================================================
1530          void XnINTR_Mask_Resume_Interrupt_Flag(void)
1531          {
1532   1          /*
1533   1          Mask Resume Interrupt Flag
1534   1          0: Enable.
1535   1          1: Mask.
1536   1          */
1537   1          unsigned char temp;
1538   1          LCD_CmdWrite(0x0D);
1539   1          temp = LCD_DataRead();
1540   1          temp |= cSetb7;
1541   1          LCD_DataWrite(temp);
1542   1      }
1543          void XnINTR_Mask_ExtInterrupt_Input_Flag(void)
1544          {
1545   1          /*
1546   1          Mask External Interrupt (PS[0] pin) Flag
1547   1          0: Enable.
1548   1          1: Mask.
1549   1          */
1550   1          unsigned char temp;
1551   1          LCD_CmdWrite(0x0D);
1552   1          temp = LCD_DataRead();
1553   1          temp |= cSetb6;
1554   1          LCD_DataWrite(temp);
1555   1      }
1556          void XnINTR_Mask_I2CM_Interrupt_Flag(void)
1557          {
1558   1          /*
1559   1          Mask I2C Master Interrupt Flag
1560   1          0: Enable.
1561   1          1: Mask.
1562   1          */
1563   1          unsigned char temp;
1564   1          LCD_CmdWrite(0x0D);
1565   1          temp = LCD_DataRead();
1566   1          temp |= cSetb5;
1567   1          LCD_DataWrite(temp);
1568   1      }
1569          void XnINTR_Mask_Vsync_Interrupt_Flag(void)
1570          {
1571   1          /*
1572   1          Mask Vsync time base interrupt Flag
1573   1          0: Enable.
1574   1          1: Mask.
1575   1          */
1576   1          unsigned char temp;
1577   1          LCD_CmdWrite(0x0D);
1578   1          temp = LCD_DataRead();
1579   1          temp |= cSetb4;
1580   1          LCD_DataWrite(temp);
1581   1      }
1582          void XnINTR_Mask_KeyScan_Interrupt_Flag(void)
1583          {
1584   1          /*
1585   1          Mask Key Scan Interrupt Flag
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 27  

1586   1          0: Enable.
1587   1          1: Mask.
1588   1          */
1589   1          unsigned char temp;
1590   1          LCD_CmdWrite(0x0D);
1591   1          temp = LCD_DataRead();
1592   1          temp |= cSetb3;
1593   1          LCD_DataWrite(temp);
1594   1      }
1595          void XnINTR_Mask_DMA_Draw_BTE_Interrupt_Flag(void)
1596          {
1597   1          /*
1598   1          Mask Serial flash DMA Complete | Draw task finished | BTE
1599   1          Process Complete etc. Interrupt Flag
1600   1          0: Enable.
1601   1          1: Mask.
1602   1          */
1603   1          unsigned char temp;
1604   1          LCD_CmdWrite(0x0D);
1605   1          temp = LCD_DataRead();
1606   1          temp |= cSetb2;
1607   1          LCD_DataWrite(temp);
1608   1      }
1609          void XnINTR_Mask_PWM1_Interrupt_Flag(void)
1610          {
1611   1          /*
1612   1          Mask PWM timer 1 Interrupt Flag
1613   1          0: Enable.
1614   1          1: Mask.
1615   1          */
1616   1          unsigned char temp;
1617   1          LCD_CmdWrite(0x0D);
1618   1          temp = LCD_DataRead();
1619   1          temp |= cSetb1;
1620   1          LCD_DataWrite(temp);
1621   1      }
1622          void XnINTR_Mask_PWM0_Interrupt_Flag(void)
1623          {
1624   1          /*
1625   1          Mask PWM timer 0 Interrupt Flag
1626   1          0: Enable.
1627   1          1: Mask.
1628   1          */
1629   1          unsigned char temp;
1630   1          LCD_CmdWrite(0x0D);
1631   1          temp = LCD_DataRead();
1632   1          temp |= cSetb0;
1633   1          LCD_DataWrite(temp);
1634   1      }
1635          
1636          void XnINTR_Unmask_Resume_Interrupt_Flag(void)
1637          {
1638   1          /*
1639   1          Mask Resume Interrupt Flag
1640   1          0: Enable.
1641   1          1: Mask.
1642   1          */
1643   1          unsigned char temp;
1644   1          LCD_CmdWrite(0x0D);
1645   1          temp = LCD_DataRead();
1646   1          temp &= cClrb7;
1647   1          LCD_DataWrite(temp);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 28  

1648   1      }
1649          void XnINTR_Unmask_ExtInterrupt_Input_Flag(void)
1650          {
1651   1          /*
1652   1          Mask External Interrupt (PS[0] pin) Flag
1653   1          0: Enable.
1654   1          1: Mask.
1655   1          */
1656   1          unsigned char temp;
1657   1          LCD_CmdWrite(0x0D);
1658   1          temp = LCD_DataRead();
1659   1          temp &= cClrb6;
1660   1          LCD_DataWrite(temp);
1661   1      }
1662          void XnINTR_Unmask_I2CM_Interrupt_Flag(void)
1663          {
1664   1          /*
1665   1          Mask I2C Master Interrupt Flag
1666   1          0: Enable.
1667   1          1: Mask.
1668   1          */
1669   1          unsigned char temp;
1670   1          LCD_CmdWrite(0x0D);
1671   1          temp = LCD_DataRead();
1672   1          temp &= cClrb5;
1673   1          LCD_DataWrite(temp);
1674   1      }
1675          void XnINTR_Unmask_Vsync_Interrupt_Flag(void)
1676          {
1677   1          /*
1678   1          Mask Vsync time base interrupt Flag
1679   1          0: Enable.
1680   1          1: Mask.
1681   1          */
1682   1          unsigned char temp;
1683   1          LCD_CmdWrite(0x0D);
1684   1          temp = LCD_DataRead();
1685   1          temp &= cClrb4;
1686   1          LCD_DataWrite(temp);
1687   1      }
1688          void XnINTR_Unmask_KeyScan_Interrupt_Flag(void)
1689          {
1690   1          /*
1691   1          Mask Key Scan Interrupt Flag
1692   1          0: Enable.
1693   1          1: Mask.
1694   1          */
1695   1          unsigned char temp;
1696   1          LCD_CmdWrite(0x0D);
1697   1          temp = LCD_DataRead();
1698   1          temp &= cClrb3;
1699   1          LCD_DataWrite(temp);
1700   1      }
1701          void XnINTR_Unmask_DMA_Draw_BTE_Interrupt_Flag(void)
1702          {
1703   1          /*
1704   1          Mask Serial flash DMA Complete | Draw task finished | BTE
1705   1          Process Complete etc. Interrupt Flag
1706   1          0: Enable.
1707   1          1: Mask.
1708   1          */
1709   1          unsigned char temp;
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 29  

1710   1          LCD_CmdWrite(0x0D);
1711   1          temp = LCD_DataRead();
1712   1          temp &= cClrb2;
1713   1          LCD_DataWrite(temp);
1714   1      }
1715          void XnINTR_Unmask_PWM1_Interrupt_Flag(void)
1716          {
1717   1          /*
1718   1          Mask PWM timer 1 Interrupt Flag
1719   1          0: Enable.
1720   1          1: Mask.
1721   1          */
1722   1          unsigned char temp;
1723   1          LCD_CmdWrite(0x0D);
1724   1          temp = LCD_DataRead();
1725   1          temp &= cClrb1;
1726   1          LCD_DataWrite(temp);
1727   1      }
1728          void XnINTR_Unmask_PWM0_Interrupt_Flag(void)
1729          {
1730   1          /*
1731   1          Mask PWM timer 0 Interrupt Flag
1732   1          0: Enable.
1733   1          1: Mask.
1734   1          */
1735   1          unsigned char temp;
1736   1          LCD_CmdWrite(0x0D);
1737   1          temp = LCD_DataRead();
1738   1          temp &= cClrb0;
1739   1          LCD_DataWrite(temp);
1740   1      }
1741          
1742          //[0Eh]=========================================================================
1743          void Enable_GPIOF_PullUp(void)
1744          {
1745   1          /*
1746   1          GPIO_F[7:0] Pull-Up Enable (XPDAT[23:19, 15:13])
1747   1          0: Pull-Up Disable
1748   1          1: Pull-Up Enable
1749   1          */
1750   1          unsigned char temp;
1751   1          LCD_CmdWrite(0x0E);
1752   1          temp = LCD_DataRead();
1753   1          temp |= cSetb5;
1754   1          LCD_DataWrite(temp);
1755   1      }
1756          void Enable_GPIOE_PullUp(void)
1757          {
1758   1          /*
1759   1          GPIO_E[7:0] Pull-Up Enable (XPDAT[12:10, 7:3])
1760   1          0: Pull-Up Disable
1761   1          1: Pull-Up Enable
1762   1          */
1763   1          unsigned char temp;
1764   1          LCD_CmdWrite(0x0E);
1765   1          temp = LCD_DataRead();
1766   1          temp |= cSetb4;
1767   1          LCD_DataWrite(temp);
1768   1      }
1769          void Enable_GPIOD_PullUp(void)
1770          {
1771   1          /*
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 30  

1772   1          GPIO_D[7:0] Pull-Up Enable (XPDAT[18, 2, 17, 16, 9, 8, 1,0])
1773   1          0: Pull-Up Disable
1774   1          1: Pull-Up Enable
1775   1          */
1776   1          unsigned char temp;
1777   1          LCD_CmdWrite(0x0E);
1778   1          temp = LCD_DataRead();
1779   1          temp |= cSetb3;
1780   1          LCD_DataWrite(temp);
1781   1      }
1782          void Enable_GPIOC_PullUp(void)
1783          {
1784   1          /*
1785   1          GPIO_C[6:0] Pull-Up Enable (XSDA, XSCL, XnSFCS1,
1786   1          XnSFCS0, XMISO, XMOSI , XSCK)
1787   1          0: Pull-Up Disable
1788   1          1: Pull-Up Enable
1789   1          */
1790   1          unsigned char temp;
1791   1          LCD_CmdWrite(0x0E);
1792   1          temp = LCD_DataRead();
1793   1          temp |= cSetb2;
1794   1          LCD_DataWrite(temp);
1795   1      }
1796          void Enable_XDB15_8_PullUp(void)
1797          {
1798   1          /*
1799   1          XDB[15:8] Pull-Up Enable
1800   1          0: Pull-Up Disable
1801   1          1: Pull-Up Enable
1802   1          */
1803   1          unsigned char temp;
1804   1          LCD_CmdWrite(0x0E);
1805   1          temp = LCD_DataRead();
1806   1          temp |= cSetb1;
1807   1          LCD_DataWrite(temp);
1808   1      }
1809          void Enable_XDB7_0_PullUp(void)
1810          {
1811   1          /*
1812   1          XDB[7:0] Pull-Up Enable
1813   1          0: Pull-Up Disable
1814   1          1: Pull-Up Enable
1815   1          */
1816   1          unsigned char temp;
1817   1          LCD_CmdWrite(0x0E);
1818   1          temp = LCD_DataRead();
1819   1          temp |= cSetb0;
1820   1          LCD_DataWrite(temp);
1821   1      }
1822          void Disable_GPIOF_PullUp(void)
1823          {
1824   1          /*
1825   1          GPIO_F[7:0] Pull-Up Enable (XPDAT[23:19, 15:13])
1826   1          0: Pull-Up Disable
1827   1          1: Pull-Up Enable
1828   1          */
1829   1          unsigned char temp;
1830   1          LCD_CmdWrite(0x0E);
1831   1          temp = LCD_DataRead();
1832   1          temp &= cClrb5;
1833   1          LCD_DataWrite(temp);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 31  

1834   1      }
1835          void Disable_GPIOE_PullUp(void)
1836          {
1837   1          /*
1838   1          GPIO_E[7:0] Pull-Up Enable (XPDAT[12:10, 7:3])
1839   1          0: Pull-Up Disable
1840   1          1: Pull-Up Enable
1841   1          */
1842   1          unsigned char temp;
1843   1          LCD_CmdWrite(0x0E);
1844   1          temp = LCD_DataRead();
1845   1          temp &= cClrb4;
1846   1          LCD_DataWrite(temp);
1847   1      }
1848          void Disable_GPIOD_PullUp(void)
1849          {
1850   1          /*
1851   1          GPIO_D[7:0] Pull-Up Enable (XPDAT[18, 2, 17, 16, 9, 8, 1,0])
1852   1          0: Pull-Up Disable
1853   1          1: Pull-Up Enable
1854   1          */
1855   1          unsigned char temp;
1856   1          LCD_CmdWrite(0x0E);
1857   1          temp = LCD_DataRead();
1858   1          temp &= cClrb3;
1859   1          LCD_DataWrite(temp);
1860   1      }
1861          void Disable_GPIOC_PullUp(void)
1862          {
1863   1          /*
1864   1          GPIO_C[6:0] Pull-Up Enable (XSDA, XSCL, XnSFCS1,
1865   1          XnSFCS0, XMISO, XMOSI , XSCK)
1866   1          0: Pull-Up Disable
1867   1          1: Pull-Up Enable
1868   1          */
1869   1          unsigned char temp;
1870   1          LCD_CmdWrite(0x0E);
1871   1          temp = LCD_DataRead();
1872   1          temp &= cClrb2;
1873   1          LCD_DataWrite(temp);
1874   1      }
1875          void Disable_XDB15_8_PullUp(void)
1876          {
1877   1          /*
1878   1          XDB[15:8] Pull-Up Enable
1879   1          0: Pull-Up Disable
1880   1          1: Pull-Up Enable
1881   1          */
1882   1          unsigned char temp;
1883   1          LCD_CmdWrite(0x0E);
1884   1          temp = LCD_DataRead();
1885   1          temp &= cClrb1;
1886   1          LCD_DataWrite(temp);
1887   1      }
1888          void Disable_XDB7_0_PullUp(void)
1889          {
1890   1          /*
1891   1          XDB[7:0] Pull-Up Enable
1892   1          0: Pull-Up Disable
1893   1          1: Pull-Up Enable
1894   1          */
1895   1          unsigned char temp;
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 32  

1896   1          LCD_CmdWrite(0x0E);
1897   1          temp = LCD_DataRead();
1898   1          temp &= cClrb0;
1899   1          LCD_DataWrite(temp);
1900   1      }
1901          //[0Fh]=========================================================================
1902          void XPDAT18_Set_GPIO_D7(void)
1903          {
1904   1          /*
1905   1          XPDAT[18] C not scan function select
1906   1          0: GPIO-D7
1907   1          1: KOUT[4]
1908   1          */
1909   1          unsigned char temp;
1910   1          LCD_CmdWrite(0x0F);
1911   1          temp = LCD_DataRead();
1912   1          temp &= cClrb7;
1913   1          LCD_DataWrite(temp);
1914   1      }
1915          void XPDAT18_Set_KOUT4(void)
1916          {
1917   1          /*
1918   1          XPDAT[18] C not scan function select
1919   1          0: GPIO-D7
1920   1          1: KOUT[4]
1921   1          */
1922   1          unsigned char temp;
1923   1          LCD_CmdWrite(0x0F);
1924   1          temp = LCD_DataRead();
1925   1          temp |= cSetb7;
1926   1          LCD_DataWrite(temp);
1927   1      }
1928          void XPDAT17_Set_GPIO_D5(void)
1929          {
1930   1          /*
1931   1          XPDAT[17] C not scan function select
1932   1          0: GPIO-D5
1933   1          1: KOUT[2]
1934   1          */
1935   1          unsigned char temp;
1936   1          LCD_CmdWrite(0x0F);
1937   1          temp = LCD_DataRead();
1938   1          temp &= cClrb6;
1939   1          LCD_DataWrite(temp);
1940   1      }
1941          void XPDAT17_Set_KOUT2(void)
1942          {
1943   1          /*
1944   1          XPDAT[17] C not scan function select
1945   1          0: GPIO-D5
1946   1          1: KOUT[2]
1947   1          */
1948   1          unsigned char temp;
1949   1          LCD_CmdWrite(0x0F);
1950   1          temp = LCD_DataRead();
1951   1          temp |= cSetb6;
1952   1          LCD_DataWrite(temp);
1953   1      }
1954          void XPDAT16_Set_GPIO_D4(void)
1955          {
1956   1          /*
1957   1          XPDAT[16] C not scan function select
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 33  

1958   1          0: GPIO-D4
1959   1          1: KOUT[1]
1960   1          */
1961   1          unsigned char temp;
1962   1          LCD_CmdWrite(0x0F);
1963   1          temp = LCD_DataRead();
1964   1          temp &= cClrb5;
1965   1          LCD_DataWrite(temp);
1966   1      }
1967          void XPDAT16_Set_KOUT1(void)
1968          {
1969   1          /*
1970   1          XPDAT[16] C not scan function select
1971   1          0: GPIO-D4
1972   1          1: KOUT[1]
1973   1          */
1974   1          unsigned char temp;
1975   1          LCD_CmdWrite(0x0F);
1976   1          temp = LCD_DataRead();
1977   1          temp |= cSetb5;
1978   1          LCD_DataWrite(temp);
1979   1      }
1980          void XPDAT9_Set_GPIO_D3(void)
1981          {
1982   1          /*
1983   1          XPDAT[9] C not scan function select
1984   1          0: GPIO-D3
1985   1          1: KOUT[3]
1986   1          */
1987   1          unsigned char temp;
1988   1          LCD_CmdWrite(0x0F);
1989   1          temp = LCD_DataRead();
1990   1          temp &= cClrb4;
1991   1          LCD_DataWrite(temp);
1992   1      }
1993          void XPDAT9_Set_KOUT3(void)
1994          {
1995   1          /*
1996   1          XPDAT[9] C not scan function select
1997   1          0: GPIO-D3
1998   1          1: KOUT[3]
1999   1          */
2000   1          unsigned char temp;
2001   1          LCD_CmdWrite(0x0F);
2002   1          temp = LCD_DataRead();
2003   1          temp |= cSetb4;
2004   1          LCD_DataWrite(temp);
2005   1      }
2006          void XPDAT8_Set_GPIO_D2(void)
2007          {
2008   1          /*
2009   1          XPDAT[8] C not scan function select
2010   1          0: GPIO-D2
2011   1          1: KIN[3]
2012   1          */
2013   1          unsigned char temp;
2014   1          LCD_CmdWrite(0x0F);
2015   1          temp = LCD_DataRead();
2016   1          temp &= cClrb3;
2017   1          LCD_DataWrite(temp);
2018   1      }
2019          void XPDAT8_Set_KIN3(void)
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 34  

2020          {
2021   1          /*
2022   1          XPDAT[8] C not scan function select
2023   1          0: GPIO-D2
2024   1          1: KIN[3]
2025   1          */
2026   1          unsigned char temp;
2027   1          LCD_CmdWrite(0x0F);
2028   1          temp = LCD_DataRead();
2029   1          temp |= cSetb3;
2030   1          LCD_DataWrite(temp);
2031   1      }
2032          void XPDAT2_Set_GPIO_D6(void)
2033          {
2034   1          /*
2035   1          XPDAT[2] C not scan function select
2036   1          0: GPIO-D6
2037   1          1: KIN[4]
2038   1          */
2039   1          unsigned char temp;
2040   1          LCD_CmdWrite(0x0F);
2041   1          temp = LCD_DataRead();
2042   1          temp &= cClrb2;
2043   1          LCD_DataWrite(temp);
2044   1      }
2045          void XPDAT2_Set_KIN4(void)
2046          {
2047   1          /*
2048   1          XPDAT[2] C not scan function select
2049   1          0: GPIO-D6
2050   1          1: KIN[4]
2051   1          */
2052   1          unsigned char temp;
2053   1          LCD_CmdWrite(0x0F);
2054   1          temp = LCD_DataRead();
2055   1          temp |= cSetb2;
2056   1          LCD_DataWrite(temp);
2057   1      }
2058          void XPDAT1_Set_GPIO_D1(void)
2059          {
2060   1          /*
2061   1          XPDAT[1] C not scan function select
2062   1          0: GPIO-D1
2063   1          1: KIN[2]
2064   1          */
2065   1          unsigned char temp;
2066   1          LCD_CmdWrite(0x0F);
2067   1          temp = LCD_DataRead();
2068   1          temp &= cClrb1;
2069   1          LCD_DataWrite(temp);
2070   1      }
2071          void XPDAT1_Set_KIN2(void)
2072          {
2073   1          /*
2074   1          XPDAT[1] C not scan function select
2075   1          0: GPIO-D1
2076   1          1: KIN[2]
2077   1          */
2078   1          unsigned char temp;
2079   1          LCD_CmdWrite(0x0F);
2080   1          temp = LCD_DataRead();
2081   1          temp |= cSetb1;
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 35  

2082   1          LCD_DataWrite(temp);
2083   1      }
2084          void XPDAT0_Set_GPIO_D0(void)
2085          {
2086   1          /*
2087   1          XPDAT[0] C not scan function select
2088   1          0: GPIO-D0
2089   1          1: KIN[1]
2090   1          */
2091   1          unsigned char temp;
2092   1          LCD_CmdWrite(0x0F);
2093   1          temp = LCD_DataRead();
2094   1          temp &= cClrb0;
2095   1          LCD_DataWrite(temp);
2096   1      }
2097          void XPDAT0_Set_KIN1(void)
2098          {
2099   1          /*
2100   1          XPDAT[0] C not scan function select
2101   1          0: GPIO-D0
2102   1          1: KIN[1]
2103   1          */
2104   1          unsigned char temp;
2105   1          LCD_CmdWrite(0x0F);
2106   1          temp = LCD_DataRead();
2107   1          temp |= cSetb0;
2108   1          LCD_DataWrite(temp);
2109   1      }
2110          
2111          //[10h]=========================================================================
2112          void Enable_PIP1(void)
2113          {
2114   1          /*
2115   1          PIP 1 window Enable/Disable
2116   1          0 : PIP 1 window disable.
2117   1          1 : PIP 1 window enable
2118   1          PIP 1 window always on top of PIP 2 window.
2119   1          */
2120   1          unsigned char temp;
2121   1          LCD_CmdWrite(0x10);
2122   1          temp = LCD_DataRead();
2123   1          temp |= cSetb7;
2124   1          LCD_DataWrite(temp);
2125   1      }
2126          void Disable_PIP1(void)
2127          {
2128   1          /*
2129   1          PIP 1 window Enable/Disable
2130   1          0 : PIP 1 window disable.
2131   1          1 : PIP 1 window enable
2132   1          PIP 1 window always on top of PIP 2 window.
2133   1          */
2134   1          unsigned char temp;
2135   1          LCD_CmdWrite(0x10);
2136   1          temp = LCD_DataRead();
2137   1          temp &= cClrb7;
2138   1          LCD_DataWrite(temp);
2139   1      }
2140          void Enable_PIP2(void)
2141          {
2142   1          /*
2143   1          PIP 2 window Enable/Disable
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 36  

2144   1          0 : PIP 2 window disable.
2145   1          1 : PIP 2 window enable
2146   1          PIP 1 window always on top of PIP 2 window.
2147   1          */
2148   1          unsigned char temp;
2149   1          LCD_CmdWrite(0x10);
2150   1          temp = LCD_DataRead();
2151   1          temp |= cSetb6;
2152   1          LCD_DataWrite(temp);
2153   1      }
2154          void Disable_PIP2(void)
2155          {
2156   1          /*
2157   1          PIP 2 window Enable/Disable
2158   1          0 : PIP 2 window disable.
2159   1          1 : PIP 2 window enable
2160   1          PIP 1 window always on top of PIP 2 window.
2161   1          */
2162   1          unsigned char temp;
2163   1          LCD_CmdWrite(0x10);
2164   1          temp = LCD_DataRead();
2165   1          temp &= cClrb6;
2166   1          LCD_DataWrite(temp);
2167   1      }
2168          void Select_PIP1_Parameter(void)
2169          {
2170   1          /*
2171   1          0: To configure PIP 1’s parameters.
2172   1          1: To configure PIP 2’s parameters..
2173   1          */
2174   1          unsigned char temp;
2175   1          LCD_CmdWrite(0x10);
2176   1          temp = LCD_DataRead();
2177   1          temp &= cClrb4;
2178   1          LCD_DataWrite(temp);
2179   1      }
2180          void Select_PIP2_Parameter(void)
2181          {
2182   1          /*
2183   1          0: To configure PIP 1’s parameters.
2184   1          1: To configure PIP 2’s parameters..
2185   1          */
2186   1          unsigned char temp;
2187   1          LCD_CmdWrite(0x10);
2188   1          temp = LCD_DataRead();
2189   1          temp |= cSetb4;
2190   1          LCD_DataWrite(temp);
2191   1      }
2192          void Select_Main_Window_8bpp(void)
2193          {
2194   1          /*
2195   1          Main Window Color Depth Setting
2196   1          00b: 8-bpp generic TFT, i.e. 256 colors.
2197   1          01b: 16-bpp generic TFT, i.e. 65K colors.
2198   1          1xb: 24-bpp generic TFT, i.e. 1.67M colors.
2199   1          */
2200   1          unsigned char temp;
2201   1          LCD_CmdWrite(0x10);
2202   1          temp = LCD_DataRead();
2203   1          temp &= cClrb3;
2204   1          temp &= cClrb2;
2205   1          LCD_DataWrite(temp);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 37  

2206   1      }
2207          void Select_Main_Window_16bpp(void)
2208          {
2209   1          /*
2210   1          Main Window Color Depth Setting
2211   1          00b: 8-bpp generic TFT, i.e. 256 colors.
2212   1          01b: 16-bpp generic TFT, i.e. 65K colors.
2213   1          1xb: 24-bpp generic TFT, i.e. 1.67M colors.
2214   1          */
2215   1          unsigned char temp;
2216   1          LCD_CmdWrite(0x10);
2217   1          temp = LCD_DataRead();
2218   1          temp &= cClrb3;
2219   1          temp |= cSetb2;
2220   1          LCD_DataWrite(temp);
2221   1      }
2222          void Select_Main_Window_24bpp(void)
2223          {
2224   1          /*
2225   1          Main Window Color Depth Setting
2226   1          00b: 8-bpp generic TFT, i.e. 256 colors.
2227   1          01b: 16-bpp generic TFT, i.e. 65K colors.
2228   1          1xb: 24-bpp generic TFT, i.e. 1.67M colors.
2229   1          */
2230   1          unsigned char temp;
2231   1          LCD_CmdWrite(0x10);
2232   1          temp = LCD_DataRead();
2233   1          temp |= cSetb3;
2234   1          LCD_DataWrite(temp);
2235   1      }
2236          
2237          void Select_LCD_Sync_Mode(void)
2238          {
2239   1          /*
2240   1          To Control panel's synchronous signals
2241   1          0: Sync Mode: Enable XVSYNC, XHSYNC, XDE
2242   1          1: DE Mode: Only XDE enable, XVSYNC & XHSYNC in idle state
2243   1          */
2244   1          unsigned char temp;
2245   1          LCD_CmdWrite(0x10);
2246   1          temp = LCD_DataRead();
2247   1          temp &= cClrb0;
2248   1          LCD_DataWrite(temp);
2249   1      }
2250          void Select_LCD_DE_Mode(void)
2251          {
2252   1          /*
2253   1          To Control panel's synchronous signals
2254   1          0: Sync Mode: Enable XVSYNC, XHSYNC, XDE
2255   1          1: DE Mode: Only XDE enable, XVSYNC & XHSYNC in idle state
2256   1          */
2257   1          unsigned char temp;
2258   1          LCD_CmdWrite(0x10);
2259   1          temp = LCD_DataRead();
2260   1          temp |= cSetb0;
2261   1          LCD_DataWrite(temp);
2262   1      }
2263          
2264          //[11h]=========================================================================
2265          void Select_PIP1_Window_8bpp(void)
2266          {
2267   1          /*
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 38  

2268   1          PIP 1 Window Color Depth Setting
2269   1          00b: 8-bpp generic TFT, i.e. 256 colors.
2270   1          01b: 16-bpp generic TFT, i.e. 65K colors.
2271   1          1xb: 24-bpp generic TFT, i.e. 1.67M colors.
2272   1          */
2273   1          unsigned char temp;
2274   1          LCD_CmdWrite(0x11);
2275   1          temp = LCD_DataRead();
2276   1          temp &= cClrb3;
2277   1          temp &= cClrb2;
2278   1          LCD_DataWrite(temp);
2279   1      }
2280          void Select_PIP1_Window_16bpp(void)
2281          {
2282   1          /*
2283   1          PIP 1 Window Color Depth Setting
2284   1          00b: 8-bpp generic TFT, i.e. 256 colors.
2285   1          01b: 16-bpp generic TFT, i.e. 65K colors.
2286   1          1xb: 24-bpp generic TFT, i.e. 1.67M colors.
2287   1          */
2288   1          unsigned char temp;
2289   1          LCD_CmdWrite(0x11);
2290   1          temp = LCD_DataRead();
2291   1          temp &= cClrb3;
2292   1          temp |= cSetb2;
2293   1          LCD_DataWrite(temp);
2294   1      }
2295          void Select_PIP1_Window_24bpp(void)
2296          {
2297   1          /*
2298   1          PIP 1 Window Color Depth Setting
2299   1          00b: 8-bpp generic TFT, i.e. 256 colors.
2300   1          01b: 16-bpp generic TFT, i.e. 65K colors.
2301   1          1xb: 24-bpp generic TFT, i.e. 1.67M colors.
2302   1          */
2303   1          unsigned char temp;
2304   1          LCD_CmdWrite(0x11);
2305   1          temp = LCD_DataRead();
2306   1          temp |= cSetb3;
2307   1          //    temp &= cClrb2;
2308   1          LCD_DataWrite(temp);
2309   1      }
2310          void Select_PIP2_Window_8bpp(void)
2311          {
2312   1          /*
2313   1          PIP 2 Window Color Depth Setting
2314   1          00b: 8-bpp generic TFT, i.e. 256 colors.
2315   1          01b: 16-bpp generic TFT, i.e. 65K colors.
2316   1          1xb: 24-bpp generic TFT, i.e. 1.67M colors.
2317   1          */
2318   1          unsigned char temp;
2319   1          LCD_CmdWrite(0x11);
2320   1          temp = LCD_DataRead();
2321   1          temp &= cClrb1;
2322   1          temp &= cClrb0;
2323   1          LCD_DataWrite(temp);
2324   1      }
2325          void Select_PIP2_Window_16bpp(void)
2326          {
2327   1          /*
2328   1          PIP 2 Window Color Depth Setting
2329   1          00b: 8-bpp generic TFT, i.e. 256 colors.
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 39  

2330   1          01b: 16-bpp generic TFT, i.e. 65K colors.
2331   1          1xb: 24-bpp generic TFT, i.e. 1.67M colors.
2332   1          */
2333   1          unsigned char temp;
2334   1          LCD_CmdWrite(0x11);
2335   1          temp = LCD_DataRead();
2336   1          temp &= cClrb1;
2337   1          temp |= cSetb0;
2338   1          LCD_DataWrite(temp);
2339   1      }
2340          void Select_PIP2_Window_24bpp(void)
2341          {
2342   1          /*
2343   1          PIP 2 Window Color Depth Setting
2344   1          00b: 8-bpp generic TFT, i.e. 256 colors.
2345   1          01b: 16-bpp generic TFT, i.e. 65K colors.
2346   1          1xb: 24-bpp generic TFT, i.e. 1.67M colors.
2347   1          */
2348   1          unsigned char temp;
2349   1          LCD_CmdWrite(0x11);
2350   1          temp = LCD_DataRead();
2351   1          temp |= cSetb1;
2352   1          //    temp &= cClrb0;
2353   1          LCD_DataWrite(temp);
2354   1      }
2355          
2356          //[12h]=========================================================================
2357          void PCLK_Rising(void)
2358          {
2359   1          /*
2360   1          PCLK Inversion
2361   1          0: PDAT, DE, HSYNC etc. Drive(/ change) at PCLK falling edge.
2362   1          1: PDAT, DE, HSYNC etc. Drive(/ change) at PCLK rising edge.
2363   1          */
2364   1          unsigned char temp;
2365   1          LCD_CmdWrite(0x12);
2366   1          temp = LCD_DataRead();
2367   1          temp &= cClrb7;
2368   1          LCD_DataWrite(temp);
2369   1      }
2370          void PCLK_Falling(void)
2371          {
2372   1          /*
2373   1          PCLK Inversion
2374   1          0: PDAT, DE, HSYNC etc. Drive(/ change) at PCLK falling edge.
2375   1          1: PDAT, DE, HSYNC etc. Drive(/ change) at PCLK rising edge.
2376   1          */
2377   1          unsigned char temp;
2378   1          LCD_CmdWrite(0x12);
2379   1          temp = LCD_DataRead();
2380   1          temp |= cSetb7;
2381   1          LCD_DataWrite(temp);
2382   1      }
2383          void Display_ON(void)
2384          {
2385   1          /*
2386   1          Display ON/OFF
2387   1          0b: Display Off.
2388   1          1b: Display On.
2389   1          */
2390   1          unsigned char temp;
2391   1      
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 40  

2392   1          LCD_CmdWrite(0x12);
2393   1          temp = LCD_DataRead();
2394   1          temp |= cSetb6;
2395   1          LCD_DataWrite(temp);
2396   1      }
2397          
2398          void Display_OFF(void)
2399          {
2400   1          /*
2401   1          Display ON/OFF
2402   1          0b: Display Off.
2403   1          1b: Display On.
2404   1          */
2405   1          unsigned char temp;
2406   1      
2407   1          LCD_CmdWrite(0x12);
2408   1          temp = LCD_DataRead();
2409   1          temp &= cClrb6;
2410   1          LCD_DataWrite(temp);
2411   1      }
2412          void Color_Bar_ON(void)
2413          {
2414   1          /*
2415   1          Display Test Color Bar
2416   1          0b: Disable.
2417   1          1b: Enable.
2418   1          */
2419   1          unsigned char temp;
2420   1      
2421   1          LCD_CmdWrite(0x12);
2422   1          temp = LCD_DataRead();
2423   1          temp |= cSetb5;
2424   1          LCD_DataWrite(temp);
2425   1      }
2426          void Color_Bar_OFF(void)
2427          {
2428   1          /*
2429   1          Display Test Color Bar
2430   1          0b: Disable.
2431   1          1b: Enable.
2432   1          */
2433   1          unsigned char temp;
2434   1      
2435   1          LCD_CmdWrite(0x12);
2436   1          temp = LCD_DataRead();
2437   1          temp &= cClrb5;
2438   1          LCD_DataWrite(temp);
2439   1      }
2440          
2441          void HSCAN_L_to_R(void)
2442          {
2443   1          /*
2444   1          Horizontal Scan direction
2445   1          0 : From Left to Right
2446   1          1 : From Right to Left
2447   1          */
2448   1          unsigned char temp;
2449   1      
2450   1          LCD_CmdWrite(0x12);
2451   1          temp = LCD_DataRead();
2452   1          temp &= cClrb4;
2453   1          LCD_DataWrite(temp);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 41  

2454   1      }
2455          void HSCAN_R_to_L(void)
2456          {
2457   1          /*
2458   1          Horizontal Scan direction
2459   1          0 : From Left to Right
2460   1          1 : From Right to Left
2461   1          */
2462   1          unsigned char temp;
2463   1      
2464   1          LCD_CmdWrite(0x12);
2465   1          temp = LCD_DataRead();
2466   1          temp |= cSetb4;
2467   1          LCD_DataWrite(temp);
2468   1      }
2469          void VSCAN_T_to_B(void)
2470          {
2471   1          /*
2472   1          Vertical Scan direction
2473   1          0 : From Top to Bottom
2474   1          1 : From bottom to Top
2475   1          */
2476   1          unsigned char temp;
2477   1      
2478   1          LCD_CmdWrite(0x12);
2479   1          temp = LCD_DataRead();
2480   1          temp &= cClrb3;
2481   1          LCD_DataWrite(temp);
2482   1      }
2483          void VSCAN_B_to_T(void)
2484          {
2485   1          /*
2486   1          Vertical Scan direction
2487   1          0 : From Top to Bottom
2488   1          1 : From bottom to Top
2489   1          */
2490   1          unsigned char temp;
2491   1      
2492   1          LCD_CmdWrite(0x12);
2493   1          temp = LCD_DataRead();
2494   1          temp |= cSetb3;
2495   1          LCD_DataWrite(temp);
2496   1      }
2497          void PDATA_Set_RGB(void)
2498          {
2499   1          /*parallel PDATA[23:0] Output Sequence
2500   1          000b : RGB
2501   1          001b : RBG
2502   1          010b : GRB
2503   1          011b : GBR
2504   1          100b : BRG
2505   1          101b : BGR
2506   1          110b : Gray
2507   1          */
2508   1          unsigned char temp;
2509   1      
2510   1          LCD_CmdWrite(0x12);
2511   1          temp = LCD_DataRead();
2512   1          temp &= 0xf8;
2513   1          LCD_DataWrite(temp);
2514   1      }
2515          void PDATA_Set_RBG(void)
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 42  

2516          {
2517   1          /*parallel PDATA[23:0] Output Sequence
2518   1          000b : RGB
2519   1          001b : RBG
2520   1          010b : GRB
2521   1          011b : GBR
2522   1          100b : BRG
2523   1          101b : BGR
2524   1          110b : Gray
2525   1          */
2526   1          unsigned char temp;
2527   1      
2528   1          LCD_CmdWrite(0x12);
2529   1          temp = LCD_DataRead();
2530   1          temp &= 0xf8;
2531   1          temp |= cSetb0;
2532   1          LCD_DataWrite(temp);
2533   1      }
2534          void PDATA_Set_GRB(void)
2535          {
2536   1          /*parallel PDATA[23:0] Output Sequence
2537   1          000b : RGB
2538   1          001b : RBG
2539   1          010b : GRB
2540   1          011b : GBR
2541   1          100b : BRG
2542   1          101b : BGR
2543   1          110b : Gray
2544   1          */
2545   1          unsigned char temp;
2546   1      
2547   1          LCD_CmdWrite(0x12);
2548   1          temp = LCD_DataRead();
2549   1          temp &= 0xf8;
2550   1          temp |= cSetb1;
2551   1          LCD_DataWrite(temp);
2552   1      }
2553          void PDATA_Set_GBR(void)
2554          {
2555   1          /*parallel PDATA[23:0] Output Sequence
2556   1          000b : RGB
2557   1          001b : RBG
2558   1          010b : GRB
2559   1          011b : GBR
2560   1          100b : BRG
2561   1          101b : BGR
2562   1          110b : Gray
2563   1          */
2564   1          unsigned char temp;
2565   1      
2566   1          LCD_CmdWrite(0x12);
2567   1          temp = LCD_DataRead();
2568   1          temp &= 0xf8;
2569   1          temp |= cSetb1;
2570   1          temp |= cSetb0;
2571   1          LCD_DataWrite(temp);
2572   1      }
2573          void PDATA_Set_BRG(void)
2574          {
2575   1          /*parallel PDATA[23:0] Output Sequence
2576   1          000b : RGB
2577   1          001b : RBG
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 43  

2578   1          010b : GRB
2579   1          011b : GBR
2580   1          100b : BRG
2581   1          101b : BGR
2582   1          110b : Gray
2583   1          */
2584   1          unsigned char temp;
2585   1      
2586   1          LCD_CmdWrite(0x12);
2587   1          temp = LCD_DataRead();
2588   1          temp &= 0xf8;
2589   1          temp |= cSetb2;
2590   1          LCD_DataWrite(temp);
2591   1      }
2592          void PDATA_Set_BGR(void)
2593          {
2594   1          /*parallel PDATA[23:0] Output Sequence
2595   1          000b : RGB
2596   1          001b : RBG
2597   1          010b : GRB
2598   1          011b : GBR
2599   1          100b : BRG
2600   1          101b : BGR
2601   1          110b : Gray
2602   1          */
2603   1          unsigned char temp;
2604   1      
2605   1          LCD_CmdWrite(0x12);
2606   1          temp = LCD_DataRead();
2607   1          temp &= 0xf8;
2608   1          temp |= cSetb2;
2609   1          temp |= cSetb0;
2610   1          LCD_DataWrite(temp);
2611   1      }
2612          void PDATA_Set_Gray(void)
2613          {
2614   1          /*parallel PDATA[23:0] Output Sequence
2615   1          000b : RGB
2616   1          001b : RBG
2617   1          010b : GRB
2618   1          011b : GBR
2619   1          100b : BRG
2620   1          101b : BGR
2621   1          110b : Gray
2622   1          */
2623   1          unsigned char temp;
2624   1      
2625   1          LCD_CmdWrite(0x12);
2626   1          temp = LCD_DataRead();
2627   1          temp &= 0xf8;
2628   1          temp |= cSetb2;
2629   1          temp |= cSetb1;
2630   1          LCD_DataWrite(temp);
2631   1      }
2632          
2633          void PDATA_IDLE_STATE(void)
2634          {
2635   1          /*
2636   1          111b : XPDAT pins send out PDAT idle state (all 0 or 1, black or white color).
2637   1          */
2638   1          unsigned char temp;
2639   1      
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 44  

2640   1          LCD_CmdWrite(0x12);
2641   1          temp = LCD_DataRead();
2642   1          temp |= 0x07;
2643   1          LCD_DataWrite(temp);
2644   1      }
2645          
2646          //[13h]=========================================================================
2647          void HSYNC_Low_Active(void)
2648          {
2649   1          /*
2650   1          HSYNC Polarity
2651   1          0 : Low active.
2652   1          1 : High active.
2653   1          */
2654   1          unsigned char temp;
2655   1      
2656   1          LCD_CmdWrite(0x13);
2657   1          temp = LCD_DataRead();
2658   1          temp &= cClrb7;
2659   1          LCD_DataWrite(temp);
2660   1      }
2661          void HSYNC_High_Active(void)
2662          {
2663   1          /*
2664   1          HSYNC Polarity
2665   1          0 : Low active.
2666   1          1 : High active.
2667   1          */
2668   1          unsigned char temp;
2669   1      
2670   1          LCD_CmdWrite(0x13);
2671   1          temp = LCD_DataRead();
2672   1          temp |= cSetb7;
2673   1          LCD_DataWrite(temp);
2674   1      }
2675          void VSYNC_Low_Active(void)
2676          {
2677   1          /*
2678   1          VSYNC Polarity
2679   1          0 : Low active.
2680   1          1 : High active.
2681   1          */
2682   1          unsigned char temp;
2683   1      
2684   1          LCD_CmdWrite(0x13);
2685   1          temp = LCD_DataRead();
2686   1          temp &= cClrb6;
2687   1          LCD_DataWrite(temp);
2688   1      }
2689          void VSYNC_High_Active(void)
2690          {
2691   1          /*
2692   1          VSYNC Polarity
2693   1          0 : Low active.
2694   1          1 : High active.
2695   1          */
2696   1          unsigned char temp;
2697   1      
2698   1          LCD_CmdWrite(0x13);
2699   1          temp = LCD_DataRead();
2700   1          temp |= cSetb6;
2701   1          LCD_DataWrite(temp);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 45  

2702   1      }
2703          void DE_Low_Active(void)
2704          {
2705   1          /*
2706   1          DE Polarity
2707   1          0 : High active.
2708   1          1 : Low active.
2709   1          */
2710   1          unsigned char temp;
2711   1      
2712   1          LCD_CmdWrite(0x13);
2713   1          temp = LCD_DataRead();
2714   1          temp |= cSetb5;
2715   1          LCD_DataWrite(temp);
2716   1      }
2717          void DE_High_Active(void)
2718          {
2719   1          /*
2720   1          DE Polarity
2721   1          0 : High active.
2722   1          1 : Low active.
2723   1          */
2724   1          unsigned char temp;
2725   1      
2726   1          LCD_CmdWrite(0x13);
2727   1          temp = LCD_DataRead();
2728   1          temp &= cClrb5;
2729   1          LCD_DataWrite(temp);
2730   1      }
2731          void Idle_DE_Low(void)
2732          {
2733   1          /*
2734   1          DE IDLE STATE(When STANDBY or DISPLAY OFF )
2735   1          0 : Pin “DE” output is low.
2736   1          1 : Pin “DE” output is high.
2737   1          */
2738   1          unsigned char temp;
2739   1      
2740   1          LCD_CmdWrite(0x13);
2741   1          temp = LCD_DataRead();
2742   1          temp &= cClrb4;
2743   1          LCD_DataWrite(temp);
2744   1      }
2745          void Idle_DE_High(void)
2746          {
2747   1          /*
2748   1          DE IDLE STATE(When STANDBY or DISPLAY OFF )
2749   1          0 : Pin “DE” output is low.
2750   1          1 : Pin “DE” output is high.
2751   1          */
2752   1          unsigned char temp;
2753   1      
2754   1          LCD_CmdWrite(0x13);
2755   1          temp = LCD_DataRead();
2756   1          temp |= cSetb4;
2757   1          LCD_DataWrite(temp);
2758   1      }
2759          void Idle_PCLK_Low(void)
2760          {
2761   1          /*
2762   1          PCLK IDLE STATE(When STANDBY or DISPLAY OFF )
2763   1          0 : Pin “PCLK” output is low.
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 46  

2764   1          1 : Pin “PCLK” output is high.
2765   1          */
2766   1          unsigned char temp;
2767   1      
2768   1          LCD_CmdWrite(0x13);
2769   1          temp = LCD_DataRead();
2770   1          temp &= cClrb3;
2771   1          LCD_DataWrite(temp);
2772   1      }
2773          void Idle_PCLK_High(void)
2774          {
2775   1          /*
2776   1          PCLK IDLE STATE(When STANDBY or DISPLAY OFF )
2777   1          0 : Pin “PCLK” output is low.
2778   1          1 : Pin “PCLK” output is high.
2779   1          */
2780   1          unsigned char temp;
2781   1      
2782   1          LCD_CmdWrite(0x13);
2783   1          temp = LCD_DataRead();
2784   1          temp |= cSetb3;
2785   1          LCD_DataWrite(temp);
2786   1      }
2787          void Idle_PDAT_Low(void)
2788          {
2789   1          /*
2790   1          PDAT IDLE STATE(When STANDBY or DISPLAY OFF )
2791   1          0 : Pins “PDAT[23:0]” output is low.
2792   1          1 : Pins “PCLK[23:0]” output is high.
2793   1          */
2794   1          unsigned char temp;
2795   1      
2796   1          LCD_CmdWrite(0x13);
2797   1          temp = LCD_DataRead();
2798   1          temp &= cClrb2;
2799   1          LCD_DataWrite(temp);
2800   1      }
2801          void Idle_PDAT_High(void)
2802          {
2803   1          /*
2804   1          PDAT IDLE STATE(When STANDBY or DISPLAY OFF )
2805   1          0 : Pins “PDAT[23:0]” output is low.
2806   1          1 : Pins “PCLK[23:0]” output is high.
2807   1          */
2808   1          unsigned char temp;
2809   1      
2810   1          LCD_CmdWrite(0x13);
2811   1          temp = LCD_DataRead();
2812   1          temp |= cSetb2;
2813   1          LCD_DataWrite(temp);
2814   1      }
2815          void Idle_HSYNC_Low(void)
2816          {
2817   1          /*
2818   1          HSYNC IDLE STATE(When STANDBY or DISPLAY OFF )
2819   1          0 : Pin “HSYNC” output is low.
2820   1          1 : Pin “HSYNC” output is high.
2821   1          */
2822   1          unsigned char temp;
2823   1      
2824   1          LCD_CmdWrite(0x13);
2825   1          temp = LCD_DataRead();
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 47  

2826   1          temp &= cClrb1;
2827   1          LCD_DataWrite(temp);
2828   1      }
2829          void Idle_HSYNC_High(void)
2830          {
2831   1          /*
2832   1          HSYNC IDLE STATE(When STANDBY or DISPLAY OFF )
2833   1          0 : Pin “HSYNC” output is low.
2834   1          1 : Pin “HSYNC” output is high.
2835   1          */
2836   1          unsigned char temp;
2837   1      
2838   1          LCD_CmdWrite(0x13);
2839   1          temp = LCD_DataRead();
2840   1          temp |= cSetb1;
2841   1          LCD_DataWrite(temp);
2842   1      }
2843          void Idle_VSYNC_Low(void)
2844          {
2845   1          /*
2846   1          VSYNC IDLE STATE(When STANDBY or DISPLAY OFF )
2847   1          0 : Pin “VSYNC” output is low.
2848   1          1 : Pin “VSYNC” output is high.
2849   1          */
2850   1          unsigned char temp;
2851   1      
2852   1          LCD_CmdWrite(0x13);
2853   1          temp = LCD_DataRead();
2854   1          temp &= cClrb0;
2855   1          LCD_DataWrite(temp);
2856   1      }
2857          void Idle_VSYNC_High(void)
2858          {
2859   1          /*
2860   1          VSYNC IDLE STATE(When STANDBY or DISPLAY OFF )
2861   1          0 : Pin “VSYNC” output is low.
2862   1          1 : Pin “VSYNC” output is high.
2863   1          */
2864   1          unsigned char temp;
2865   1      
2866   1          LCD_CmdWrite(0x13);
2867   1          temp = LCD_DataRead();
2868   1          temp |= cSetb0;
2869   1          LCD_DataWrite(temp);
2870   1      }
2871          
2872          //[14h][15h][1Ah][1Bh]=========================================================================
2873          void LCD_HorizontalWidth_VerticalHeight(unsigned short WX, unsigned short HY)
2874          {
2875   1          /*
2876   1          [14h] Horizontal Display Width Setting Bit[7:0]
2877   1          [15h] Horizontal Display Width Fine Tuning (HDWFT) [3:0]
2878   1          The register specifies the LCD panel horizontal display width in
2879   1          the unit of 8 pixels resolution.
2880   1          Horizontal display width(pixels) = (HDWR + 1) * 8 + HDWFTR
2881   1      
2882   1          [1Ah] Vertical Display Height Bit[7:0]
2883   1          Vertical Display Height(Line) = VDHR + 1
2884   1          [1Bh] Vertical Display Height Bit[10:8]
2885   1          Vertical Display Height(Line) = VDHR + 1
2886   1          */
2887   1          unsigned char temp;
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 48  

2888   1          if (WX < 8) {
2889   2              LCD_CmdWrite(0x14);
2890   2              LCD_DataWrite(0x00);
2891   2      
2892   2              LCD_CmdWrite(0x15);
2893   2              LCD_DataWrite(WX);
2894   2      
2895   2              temp = HY - 1;
2896   2              LCD_CmdWrite(0x1A);
2897   2              LCD_DataWrite(temp);
2898   2      
2899   2              temp = (HY - 1) >> 8;
2900   2              LCD_CmdWrite(0x1B);
2901   2              LCD_DataWrite(temp);
2902   2          } else {
2903   2              temp = (WX / 8) - 1;
2904   2              LCD_CmdWrite(0x14);
2905   2              LCD_DataWrite(temp);
2906   2      
2907   2              temp = WX % 8;
2908   2              LCD_CmdWrite(0x15);
2909   2              LCD_DataWrite(temp);
2910   2      
2911   2              temp = HY - 1;
2912   2              LCD_CmdWrite(0x1A);
2913   2              LCD_DataWrite(temp);
2914   2      
2915   2              temp = (HY - 1) >> 8;
2916   2              LCD_CmdWrite(0x1B);
2917   2              LCD_DataWrite(temp);
2918   2          }
2919   1      }
2920          //[16h][17h]=========================================================================
2921          void LCD_Horizontal_Non_Display(unsigned short WX)
2922          {
2923   1          /*
2924   1          [16h] Horizontal Non-Display Period(HNDR) Bit[4:0]
2925   1          This register specifies the horizontal non-display period. Also
2926   1          called back porch.
2927   1          Horizontal non-display period(pixels) = (HNDR + 1) * 8 + HNDFTR
2928   1      
2929   1          [17h] Horizontal Non-Display Period Fine Tuning(HNDFT) [3:0]
2930   1          This register specifies the fine tuning for horizontal non-display
2931   1          period; it is used to support the SYNC mode panel. Each level of
2932   1          this modulation is 1-pixel.
2933   1          Horizontal non-display period(pixels) = (HNDR + 1) * 8 + HNDFTR
2934   1          */
2935   1          unsigned char temp;
2936   1          if (WX < 8) {
2937   2              LCD_CmdWrite(0x16);
2938   2              LCD_DataWrite(0x00);
2939   2      
2940   2              LCD_CmdWrite(0x17);
2941   2              LCD_DataWrite(WX);
2942   2          } else {
2943   2              temp = (WX / 8) - 1;
2944   2              LCD_CmdWrite(0x16);
2945   2              LCD_DataWrite(temp);
2946   2      
2947   2              temp = WX % 8;
2948   2              LCD_CmdWrite(0x17);
2949   2              LCD_DataWrite(temp);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 49  

2950   2          }
2951   1      }
2952          //[18h]=========================================================================
2953          void LCD_HSYNC_Start_Position(unsigned short WX)
2954          {
2955   1          /*
2956   1          [18h] HSYNC Start Position[4:0]
2957   1          The starting position from the end of display area to the
2958   1          beginning of HSYNC. Each level of this modulation is 8-pixel.
2959   1          Also called front porch.
2960   1          HSYNC Start Position(pixels) = (HSTR + 1)x8
2961   1          */
2962   1          unsigned char temp;
2963   1          if (WX < 8) {
2964   2              LCD_CmdWrite(0x18);
2965   2              LCD_DataWrite(0x00);
2966   2          } else {
2967   2              temp = (WX / 8) - 1;
2968   2              LCD_CmdWrite(0x18);
2969   2              LCD_DataWrite(temp);
2970   2          }
2971   1      }
2972          //[19h]=========================================================================
2973          void LCD_HSYNC_Pulse_Width(unsigned short WX)
2974          {
2975   1          /*
2976   1          [19h] HSYNC Pulse Width(HPW) [4:0]
2977   1          The period width of HSYNC.
2978   1          HSYNC Pulse Width(pixels) = (HPW + 1)x8
2979   1          */
2980   1          unsigned char temp;
2981   1          if (WX < 8) {
2982   2              LCD_CmdWrite(0x19);
2983   2              LCD_DataWrite(0x00);
2984   2          } else {
2985   2              temp = (WX / 8) - 1;
2986   2              LCD_CmdWrite(0x19);
2987   2              LCD_DataWrite(temp);
2988   2          }
2989   1      }
2990          //[1Ch][1Dh]=========================================================================
2991          void LCD_Vertical_Non_Display(unsigned short HY)
2992          {
2993   1          /*
2994   1          [1Ch] Vertical Non-Display Period Bit[7:0]
2995   1          Vertical Non-Display Period(Line) = (VNDR + 1)
2996   1      
2997   1          [1Dh] Vertical Non-Display Period Bit[9:8]
2998   1          Vertical Non-Display Period(Line) = (VNDR + 1)
2999   1          */
3000   1          unsigned short temp;
3001   1          temp = HY - 1;
3002   1          LCD_CmdWrite(0x1C);
3003   1          LCD_DataWrite(temp);
3004   1      
3005   1          LCD_CmdWrite(0x1D);
3006   1          LCD_DataWrite(temp >> 8);
3007   1      }
3008          //[1Eh]=========================================================================
3009          void LCD_VSYNC_Start_Position(unsigned short HY)
3010          {
3011   1          /*
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 50  

3012   1          [1Eh] VSYNC Start Position[7:0]
3013   1          The starting position from the end of display area to the beginning of VSYNC.
3014   1          VSYNC Start Position(Line) = (VSTR + 1)
3015   1          */
3016   1          unsigned char temp;
3017   1          temp = HY - 1;
3018   1          LCD_CmdWrite(0x1E);
3019   1          LCD_DataWrite(temp);
3020   1      }
3021          //[1Fh]=========================================================================
3022          void LCD_VSYNC_Pulse_Width(unsigned short HY)
3023          {
3024   1          /*
3025   1          [1Fh] VSYNC Pulse Width[5:0]
3026   1          The pulse width of VSYNC in lines.
3027   1          VSYNC Pulse Width(Line) = (VPWR + 1)
3028   1          */
3029   1          unsigned char temp;
3030   1          temp = HY - 1;
3031   1          LCD_CmdWrite(0x1F);
3032   1          LCD_DataWrite(temp);
3033   1      }
3034          //[20h][21h][22h][23h]=========================================================================
3035          void Main_Image_Start_Address(unsigned long Addr)
3036          {
3037   1          /*
3038   1          [20h] Main Image Start Address[7:2]
3039   1          [21h] Main Image Start Address[15:8]
3040   1          [22h] Main Image Start Address [23:16]
3041   1          [23h] Main Image Start Address [31:24]
3042   1          */
3043   1          LCD_CmdWrite(0x20);
3044   1          LCD_DataWrite(Addr);
3045   1          LCD_CmdWrite(0x21);
3046   1          LCD_DataWrite(Addr >> 8);
3047   1          LCD_CmdWrite(0x22);
3048   1          LCD_DataWrite(Addr >> 16);
3049   1          LCD_CmdWrite(0x23);
3050   1          LCD_DataWrite(Addr >> 24);
3051   1      }
3052          //[24h][25h]=========================================================================
3053          void Main_Image_Width(unsigned short WX)
3054          {
3055   1          /*
3056   1          [24h] Main Image Width [7:0]
3057   1          [25h] Main Image Width [12:8]
3058   1          Unit: Pixel.
3059   1          It must be divisible by 4. MIW Bit [1:0] tie to “0” internally.
3060   1          The value is physical pixel number. Maximum value is 8188 pixels
3061   1          */
3062   1          LCD_CmdWrite(0x24);
3063   1          LCD_DataWrite(WX);
3064   1          LCD_CmdWrite(0x25);
3065   1          LCD_DataWrite(WX >> 8);
3066   1      }
3067          //[26h][27h][28h][29h]=========================================================================
3068          void Main_Window_Start_XY(unsigned short WX, unsigned short HY)
3069          {
3070   1          /*
3071   1          [26h] Main Window Upper-Left corner X-coordinate [7:0]
3072   1          [27h] Main Window Upper-Left corner X-coordinate [12:8]
3073   1          Reference Main Image coordinate.
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 51  

3074   1          Unit: Pixel
3075   1          It must be divisible by 4. MWULX Bit [1:0] tie to “0” internally.
3076   1          X-axis coordinate plus Horizontal display width cannot large than 8188.
3077   1      
3078   1          [28h] Main Window Upper-Left corner Y-coordinate [7:0]
3079   1          [29h] Main Window Upper-Left corner Y-coordinate [12:8]
3080   1          Reference Main Image coordinate.
3081   1          Unit: Pixel
3082   1          Range is between 0 and 8191.
3083   1          */
3084   1          LCD_CmdWrite(0x26);
3085   1          LCD_DataWrite(WX);
3086   1          LCD_CmdWrite(0x27);
3087   1          LCD_DataWrite(WX >> 8);
3088   1          LCD_CmdWrite(0x28);
3089   1          LCD_DataWrite(HY);
3090   1          LCD_CmdWrite(0x29);
3091   1          LCD_DataWrite(HY >> 8);
3092   1      }
3093          //[2Ah][2Bh][2Ch][2Dh]=========================================================================
3094          void PIP_Display_Start_XY(unsigned short WX, unsigned short HY)
3095          {
3096   1          /*
3097   1          [2Ah] PIP Window Display Upper-Left corner X-coordinate [7:0]
3098   1          [2Bh] PIP Window Display Upper-Left corner X-coordinate [12:8]
3099   1          Reference Main Window coordinate.
3100   1          Unit: Pixel
3101   1          It must be divisible by 4. PWDULX Bit [1:0] tie to “0” internally.
3102   1          X-axis coordinate should less than horizontal display width.
3103   1          According to bit of Select Configure PIP 1 or 2 Window’s parameters.
3104   1          Function bit will be configured for relative PIP window.
3105   1      
3106   1          [2Ch] PIP Window Display Upper-Left corner Y-coordinate [7:0]
3107   1          [2Dh] PIP Window Display Upper-Left corner Y-coordinate [12:8]
3108   1          Reference Main Window coordinate.
3109   1          Unit: Pixel
3110   1          Y-axis coordinate should less than vertical display height.
3111   1          According to bit of Select Configure PIP 1 or 2 Window’s parameters.
3112   1          Function bit will be configured for relative PIP window.
3113   1          */
3114   1          LCD_CmdWrite(0x2A);
3115   1          LCD_DataWrite(WX);
3116   1          LCD_CmdWrite(0x2B);
3117   1          LCD_DataWrite(WX >> 8);
3118   1          LCD_CmdWrite(0x2C);
3119   1          LCD_DataWrite(HY);
3120   1          LCD_CmdWrite(0x2D);
3121   1          LCD_DataWrite(HY >> 8);
3122   1      }
3123          //[2Eh][2Fh][30h][31h]=========================================================================
3124          void PIP_Image_Start_Address(unsigned long Addr)
3125          {
3126   1          /*
3127   1          [2Eh] PIP Image Start Address[7:2]
3128   1          [2Fh] PIP Image Start Address[15:8]
3129   1          [30h] PIP Image Start Address [23:16]
3130   1          [31h] PIP Image Start Address [31:24]
3131   1          */
3132   1          LCD_CmdWrite(0x2E);
3133   1          LCD_DataWrite(Addr);
3134   1          LCD_CmdWrite(0x2F);
3135   1          LCD_DataWrite(Addr >> 8);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 52  

3136   1          LCD_CmdWrite(0x30);
3137   1          LCD_DataWrite(Addr >> 16);
3138   1          LCD_CmdWrite(0x31);
3139   1          LCD_DataWrite(Addr >> 24);
3140   1      }
3141          //[32h][33h]=========================================================================
3142          void PIP_Image_Width(unsigned short WX)
3143          {
3144   1          /*
3145   1          [32h] PIP Image Width [7:0]
3146   1          [33h] PIP Image Width [12:8]
3147   1          Unit: Pixel.
3148   1          It must be divisible by 4. PIW Bit [1:0] tie to “0” internally.
3149   1          The value is physical pixel number.
3150   1          This width should less than horizontal display width.
3151   1          According to bit of Select Configure PIP 1 or 2 Window’s parameters.
3152   1          Function bit will be configured for relative PIP window.
3153   1          */
3154   1          LCD_CmdWrite(0x32);
3155   1          LCD_DataWrite(WX);
3156   1          LCD_CmdWrite(0x33);
3157   1          LCD_DataWrite(WX >> 8);
3158   1      }
3159          //[34h][35h][36h][37h]=========================================================================
3160          void PIP_Window_Image_Start_XY(unsigned short WX, unsigned short HY)
3161          {
3162   1      
3163   1          /*
3164   1          [34h] PIP 1 or 2 Window Image Upper-Left corner X-coordinate [7:0]
3165   1          [35h] PIP Window Image Upper-Left corner X-coordinate [12:8]
3166   1          Reference PIP Image coordinate.
3167   1          Unit: Pixel
3168   1          It must be divisible by 4. PWIULX Bit [1:0] tie to “0” internally.
3169   1          X-axis coordinate plus PIP image width cannot large than 8188.
3170   1          According to bit of Select Configure PIP 1 or 2 Window’s parameters.
3171   1          Function bit will be configured for relative PIP window.
3172   1      
3173   1          [36h] PIP Windows Display Upper-Left corner Y-coordinate [7:0]
3174   1          [37h] PIP Windows Image Upper-Left corner Y-coordinate [12:8]
3175   1          Reference PIP Image coordinate.
3176   1          Unit: Pixel
3177   1          Y-axis coordinate plus PIP window height should less than 8191.
3178   1          According to bit of Select Configure PIP 1 or 2 Window’s parameters.
3179   1          Function bit will be configured for relative PIP window.
3180   1          */
3181   1          LCD_CmdWrite(0x34);
3182   1          LCD_DataWrite(WX);
3183   1          LCD_CmdWrite(0x35);
3184   1          LCD_DataWrite(WX >> 8);
3185   1          LCD_CmdWrite(0x36);
3186   1          LCD_DataWrite(HY);
3187   1          LCD_CmdWrite(0x37);
3188   1          LCD_DataWrite(HY >> 8);
3189   1      }
3190          //[38h][39h][3Ah][3Bh]=========================================================================
3191          void PIP_Window_Width_Height(unsigned short WX, unsigned short HY)
3192          {
3193   1          /*
3194   1          [38h] PIP Window Width [7:0]
3195   1          [39h] PIP Window Width [10:8]
3196   1          Unit: Pixel.
3197   1          It must be divisible by 4. The value is physical pixel number.
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 53  

3198   1          Maximum value is 8188 pixels.
3199   1          According to bit of Select Configure PIP 1 or 2 Window’s parameters.
3200   1          Function bit will be configured for relative PIP window.
3201   1      
3202   1          [3Ah] PIP Window Height [7:0]
3203   1          [3Bh] PIP Window Height [10:8]
3204   1          Unit: Pixel
3205   1          The value is physical pixel number. Maximum value is 8191 pixels.
3206   1          According to bit of Select Configure PIP 1 or 2 Window’s parameters.
3207   1          Function bit will be configured for relative PIP window.
3208   1          */
3209   1          LCD_CmdWrite(0x38);
3210   1          LCD_DataWrite(WX);
3211   1          LCD_CmdWrite(0x39);
3212   1          LCD_DataWrite(WX >> 8);
3213   1          LCD_CmdWrite(0x3A);
3214   1          LCD_DataWrite(HY);
3215   1          LCD_CmdWrite(0x3B);
3216   1          LCD_DataWrite(HY >> 8);
3217   1      }
3218          
3219          //[3Ch]=========================================================================
3220          void Enable_Gamma_Correction(void)
3221          {
3222   1          /*
3223   1          Gamma correction Enable
3224   1          0: Disable
3225   1          1: Enable
3226   1          Gamma correction is the last output stage.
3227   1          */
3228   1          unsigned char temp;
3229   1      
3230   1          LCD_CmdWrite(0x3C);
3231   1          temp = LCD_DataRead();
3232   1          temp |= cSetb7;
3233   1          LCD_DataWrite(temp);
3234   1      }
3235          void Disable_Gamma_Correction(void)
3236          {
3237   1          /*
3238   1          Gamma correction Enable
3239   1          0: Disable
3240   1          1: Enable
3241   1          Gamma correction is the last output stage.
3242   1          */
3243   1          unsigned char temp;
3244   1      
3245   1          LCD_CmdWrite(0x3C);
3246   1          temp = LCD_DataRead();
3247   1          temp &= cClrb7;
3248   1          LCD_DataWrite(temp);
3249   1      }
3250          void Gamma_Table_for_Blue(void)
3251          {
3252   1          /*
3253   1          Gamma table select for MPU write gamma data
3254   1          00b: Gamma table for Blue
3255   1          01b: Gamma table for Green
3256   1          10b: Gamma table for Red
3257   1          */
3258   1          unsigned char temp;
3259   1      
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 54  

3260   1          LCD_CmdWrite(0x3C);
3261   1          temp = LCD_DataRead();
3262   1          temp &= cClrb6;
3263   1          temp &= cClrb5;
3264   1          LCD_DataWrite(temp);
3265   1      }
3266          void Gamma_Table_for_Green(void)
3267          {
3268   1          /*
3269   1          Gamma table select for MPU write gamma data
3270   1          00b: Gamma table for Blue
3271   1          01b: Gamma table for Green
3272   1          10b: Gamma table for Red
3273   1          */
3274   1          unsigned char temp;
3275   1      
3276   1          LCD_CmdWrite(0x3C);
3277   1          temp = LCD_DataRead();
3278   1          temp &= cClrb6;
3279   1          temp |= cSetb5;
3280   1          LCD_DataWrite(temp);
3281   1      }
3282          void Gamma_Table_for_Red(void)
3283          {
3284   1          /*
3285   1          Gamma table select for MPU write gamma data
3286   1          00b: Gamma table for Blue
3287   1          01b: Gamma table for Green
3288   1          10b: Gamma table for Red
3289   1          */
3290   1          unsigned char temp;
3291   1      
3292   1          LCD_CmdWrite(0x3C);
3293   1          temp = LCD_DataRead();
3294   1          temp |= cSetb6;
3295   1          temp &= cClrb5;
3296   1          LCD_DataWrite(temp);
3297   1      }
3298          
3299          void Enable_Graphic_Cursor(void)
3300          {
3301   1          /*
3302   1          Graphic Cursor Enable
3303   1          0 : Graphic Cursor disable.
3304   1          1 : Graphic Cursor enable.
3305   1          */
3306   1          unsigned char temp;
3307   1      
3308   1          LCD_CmdWrite(0x3C);
3309   1          temp = LCD_DataRead();
3310   1          temp |= cSetb4;
3311   1          LCD_DataWrite(temp);
3312   1      }
3313          void Disable_Graphic_Cursor(void)
3314          {
3315   1          /*
3316   1          Graphic Cursor Enable
3317   1          0 : Graphic Cursor disable.
3318   1          1 : Graphic Cursor enable.
3319   1          */
3320   1          unsigned char temp;
3321   1      
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 55  

3322   1          LCD_CmdWrite(0x3C);
3323   1          temp = LCD_DataRead();
3324   1          temp &= cClrb4;
3325   1          LCD_DataWrite(temp);
3326   1      }
3327          //
3328          void Select_Graphic_Cursor_1(void)
3329          {
3330   1          /*
3331   1          Graphic Cursor Selection Bit
3332   1          Select one from four graphic cursor types. (00b to 11b)
3333   1          00b : Graphic Cursor Set 1.
3334   1          01b : Graphic Cursor Set 2.
3335   1          10b : Graphic Cursor Set 3.
3336   1          11b : Graphic Cursor Set 4.
3337   1          */
3338   1          unsigned char temp;
3339   1      
3340   1          LCD_CmdWrite(0x3C);
3341   1          temp = LCD_DataRead();
3342   1          temp &= cClrb3;
3343   1          temp &= cClrb2;
3344   1          LCD_DataWrite(temp);
3345   1      }
3346          void Select_Graphic_Cursor_2(void)
3347          {
3348   1          /*
3349   1          Graphic Cursor Selection Bit
3350   1          Select one from four graphic cursor types. (00b to 11b)
3351   1          00b : Graphic Cursor Set 1.
3352   1          01b : Graphic Cursor Set 2.
3353   1          10b : Graphic Cursor Set 3.
3354   1          11b : Graphic Cursor Set 4.
3355   1          */
3356   1          unsigned char temp;
3357   1      
3358   1          LCD_CmdWrite(0x3C);
3359   1          temp = LCD_DataRead();
3360   1          temp &= cClrb3;
3361   1          temp |= cSetb2;
3362   1          LCD_DataWrite(temp);
3363   1      }
3364          void Select_Graphic_Cursor_3(void)
3365          {
3366   1          /*
3367   1          Graphic Cursor Selection Bit
3368   1          Select one from four graphic cursor types. (00b to 11b)
3369   1          00b : Graphic Cursor Set 1.
3370   1          01b : Graphic Cursor Set 2.
3371   1          10b : Graphic Cursor Set 3.
3372   1          11b : Graphic Cursor Set 4.
3373   1          */
3374   1          unsigned char temp;
3375   1      
3376   1          LCD_CmdWrite(0x3C);
3377   1          temp = LCD_DataRead();
3378   1          temp |= cSetb3;
3379   1          temp &= cClrb2;
3380   1          LCD_DataWrite(temp);
3381   1      }
3382          void Select_Graphic_Cursor_4(void)
3383          {
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 56  

3384   1          /*
3385   1          Graphic Cursor Selection Bit
3386   1          Select one from four graphic cursor types. (00b to 11b)
3387   1          00b : Graphic Cursor Set 1.
3388   1          01b : Graphic Cursor Set 2.
3389   1          10b : Graphic Cursor Set 3.
3390   1          11b : Graphic Cursor Set 4.
3391   1          */
3392   1          unsigned char temp;
3393   1      
3394   1          LCD_CmdWrite(0x3C);
3395   1          temp = LCD_DataRead();
3396   1          temp |= cSetb3;
3397   1          temp |= cSetb2;
3398   1          LCD_DataWrite(temp);
3399   1      }
3400          //
3401          void Enable_Text_Cursor(void)
3402          {
3403   1          /*
3404   1          Text Cursor Enable
3405   1          0 : Disable.
3406   1          1 : Enable.
3407   1          Text cursor & Graphic cursor cannot enable simultaneously.
3408   1          Graphic cursor has higher priority then Text cursor if enabled simultaneously.
3409   1          */
3410   1          unsigned char temp;
3411   1      
3412   1          LCD_CmdWrite(0x3C);
3413   1          temp = LCD_DataRead();
3414   1          temp |= cSetb1;
3415   1          LCD_DataWrite(temp);
3416   1      }
3417          void Disable_Text_Cursor(void)
3418          {
3419   1          /*
3420   1          Text Cursor Enable
3421   1          0 : Disable.
3422   1          1 : Enable.
3423   1          Text cursor & Graphic cursor cannot enable simultaneously.
3424   1          Graphic cursor has higher priority then Text cursor if enabled simultaneously.
3425   1          */
3426   1          unsigned char temp;
3427   1      
3428   1          LCD_CmdWrite(0x3C);
3429   1          temp = LCD_DataRead();
3430   1          temp &= cClrb1;
3431   1          LCD_DataWrite(temp);
3432   1      }
3433          //
3434          void Enable_Text_Cursor_Blinking(void)
3435          {
3436   1          /*
3437   1          Text Cursor Blinking Enable
3438   1          0 : Disable.
3439   1          1 : Enable.
3440   1          */
3441   1          unsigned char temp;
3442   1      
3443   1          LCD_CmdWrite(0x3C);
3444   1          temp = LCD_DataRead();
3445   1          temp |= cSetb0;
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 57  

3446   1          LCD_DataWrite(temp);
3447   1      }
3448          void Disable_Text_Cursor_Blinking(void)
3449          {
3450   1          /*
3451   1          Text Cursor Blinking Enable
3452   1          0 : Disable.
3453   1          1 : Enable.
3454   1          */
3455   1          unsigned char temp;
3456   1      
3457   1          LCD_CmdWrite(0x3C);
3458   1          temp = LCD_DataRead();
3459   1          temp &= cClrb0;
3460   1          LCD_DataWrite(temp);
3461   1      }
3462          //[3Dh]=========================================================================
3463          void Blinking_Time_Frames(unsigned char temp)
3464          {
3465   1          /*
3466   1          Text Cursor Blink Time Setting (Unit: Frame)
3467   1          00h : 1 frame time.
3468   1          01h : 2 frames time.
3469   1          02h : 3 frames time.
3470   1          :
3471   1          FFh : 256 frames time.
3472   1          */
3473   1          LCD_CmdWrite(0x3D);
3474   1          LCD_DataWrite(temp);
3475   1      }
3476          //[3Eh]=========================================================================
3477          void Text_Cursor_H_V(unsigned short WX, unsigned short HY)
3478          {
3479   1          /*
3480   1          [3Eh]
3481   1          Text Cursor Horizontal Size Setting[4:0]
3482   1          Unit : Pixel
3483   1          Zero-based number. Value “0” means 1 pixel.
3484   1          Note : When font is enlarged, the cursor setting will multiply the
3485   1          same times as the font enlargement.
3486   1          [3Fh]
3487   1          Text Cursor Vertical Size Setting[4:0]
3488   1          Unit : Pixel
3489   1          Zero-based number. Value “0” means 1 pixel.
3490   1          Note : When font is enlarged, the cursor setting will multiply the
3491   1          same times as the font enlargement.
3492   1          */
3493   1          LCD_CmdWrite(0x3E);
3494   1          LCD_DataWrite(WX);
3495   1          LCD_CmdWrite(0x3F);
3496   1          LCD_DataWrite(HY);
3497   1      }
3498          //[40h][41h][42h][43h]=========================================================================
3499          void Graphic_Cursor_XY(unsigned short WX, unsigned short HY)
3500          {
3501   1          /*
3502   1          [40h] Graphic Cursor Horizontal Location[7:0]
3503   1          [41h] Graphic Cursor Horizontal Location[12:8]
3504   1          [42h] Graphic Cursor Vertical Location[7:0]
3505   1          [43h] Graphic Cursor Vertical Location[12:8]
3506   1          Reference main Window coordinate.
3507   1          */
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 58  

3508   1          LCD_CmdWrite(0x40);
3509   1          LCD_DataWrite(WX);
3510   1          LCD_CmdWrite(0x41);
3511   1          LCD_DataWrite(WX >> 8);
3512   1          LCD_CmdWrite(0x42);
3513   1          LCD_DataWrite(HY);
3514   1          LCD_CmdWrite(0x43);
3515   1          LCD_DataWrite(HY >> 8);
3516   1      }
3517          //[44h]=========================================================================
3518          void Set_Graphic_Cursor_Color_1(unsigned char temp)
3519          {
3520   1          /*
3521   1          [44h] Graphic Cursor Color 0 with 256 Colors
3522   1          RGB Format [7:0] = RRRGGGBB.
3523   1          */
3524   1          LCD_RegisterWrite(0x44, temp);
3525   1      }
3526          //[45h]=========================================================================
3527          void Set_Graphic_Cursor_Color_2(unsigned char temp)
3528          {
3529   1          /*
3530   1          [45h] Graphic Cursor Color 1 with 256 Colors
3531   1          RGB Format [7:0] = RRRGGGBB.
3532   1          */
3533   1          LCD_RegisterWrite(0x45, temp);
3534   1      }
3535          
3536          //[50h][51h][52h][53h]=========================================================================
3537          void Canvas_Image_Start_address(unsigned long Addr)
3538          {
3539   1          /*
3540   1          [50h] Start address of Canvas [7:0]
3541   1          [51h] Start address of Canvas [15:8]
3542   1          [52h] Start address of Canvas [23:16]
3543   1          [53h] Start address of Canvas [31:24]
3544   1          */
3545   1          LCD_CmdWrite(0x50);
3546   1          LCD_DataWrite(Addr);
3547   1          LCD_CmdWrite(0x51);
3548   1          LCD_DataWrite(Addr >> 8);
3549   1          LCD_CmdWrite(0x52);
3550   1          LCD_DataWrite(Addr >> 16);
3551   1          LCD_CmdWrite(0x53);
3552   1          LCD_DataWrite(Addr >> 24);
3553   1      }
3554          //[54h][55h]=========================================================================
3555          void Canvas_image_width(unsigned short WX)
3556          {
3557   1          /*
3558   1          [54h] Canvas image width [7:2]
3559   1          [55h] Canvas image width [12:8]
3560   1          */
3561   1          LCD_CmdWrite(0x54);
3562   1          LCD_DataWrite(WX);
3563   1          LCD_CmdWrite(0x55);
3564   1          LCD_DataWrite(WX >> 8);
3565   1      }
3566          //[56h][57h][58h][59h]=========================================================================
3567          void Active_Window_XY(unsigned short WX, unsigned short HY)
3568          {
3569   1          /*
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 59  

3570   1          [56h] Active Window Upper-Left corner X-coordinate [7:0]
3571   1          [57h] Active Window Upper-Left corner X-coordinate [12:8]
3572   1          [58h] Active Window Upper-Left corner Y-coordinate [7:0]
3573   1          [59h] Active Window Upper-Left corner Y-coordinate [12:8]
3574   1          */
3575   1          LCD_CmdWrite(0x56);
3576   1          LCD_DataWrite(WX);
3577   1          LCD_CmdWrite(0x57);
3578   1          LCD_DataWrite(WX >> 8);
3579   1          LCD_CmdWrite(0x58);
3580   1          LCD_DataWrite(HY);
3581   1          LCD_CmdWrite(0x59);
3582   1          LCD_DataWrite(HY >> 8);
3583   1      }
3584          //[5Ah][5Bh][5Ch][5Dh]=========================================================================
3585          void Active_Window_WH(unsigned short WX, unsigned short HY)
3586          {
3587   1          /*
3588   1          [5Ah] Width of Active Window [7:0]
3589   1          [5Bh] Width of Active Window [12:8]
3590   1          [5Ch] Height of Active Window [7:0]
3591   1          [5Dh] Height of Active Window [12:8]
3592   1          */
3593   1          LCD_CmdWrite(0x5A);
3594   1          LCD_DataWrite(WX);
3595   1          LCD_CmdWrite(0x5B);
3596   1          LCD_DataWrite(WX >> 8);
3597   1          LCD_CmdWrite(0x5C);
3598   1          LCD_DataWrite(HY);
3599   1          LCD_CmdWrite(0x5D);
3600   1          LCD_DataWrite(HY >> 8);
3601   1      }
3602          //[5Eh]=========================================================================
3603          
3604          void Memory_XY_Mode(void)
3605          {
3606   1          /*
3607   1          Canvas addressing mode
3608   1          0: Block mode (X-Y coordinate addressing)
3609   1          1: linear mode
3610   1          */
3611   1          unsigned char temp;
3612   1      
3613   1          LCD_CmdWrite(0x5E);
3614   1          temp = LCD_DataRead();
3615   1          temp &= cClrb2;
3616   1          LCD_DataWrite(temp);
3617   1      }
3618          void Memory_Linear_Mode(void)
3619          {
3620   1          /*
3621   1          Canvas addressing mode
3622   1          0: Block mode (X-Y coordinate addressing)
3623   1          1: linear mode
3624   1          */
3625   1          unsigned char temp;
3626   1      
3627   1          LCD_CmdWrite(0x5E);
3628   1          temp = LCD_DataRead();
3629   1          temp |= cSetb2;
3630   1          LCD_DataWrite(temp);
3631   1      }
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 60  

3632          void Memory_8bpp_Mode(void)
3633          {
3634   1          /*
3635   1          Canvas image’s color depth & memory R/W data width
3636   1          In Block Mode:
3637   1          00: 8bpp
3638   1          01: 16bpp
3639   1          1x: 24bpp
3640   1          In Linear Mode:
3641   1          x0: 8-bits memory data read/write.
3642   1          x1: 16-bits memory data read/write
3643   1          */
3644   1          unsigned char temp;
3645   1      
3646   1          LCD_CmdWrite(0x5E);
3647   1          temp = LCD_DataRead();
3648   1          temp &= cClrb1;
3649   1          temp &= cClrb0;
3650   1          LCD_DataWrite(temp);
3651   1      }
3652          void Memory_16bpp_Mode(void)
3653          {
3654   1          /*
3655   1          Canvas image’s color depth & memory R/W data width
3656   1          In Block Mode:
3657   1          00: 8bpp
3658   1          01: 16bpp
3659   1          1x: 24bpp
3660   1          In Linear Mode:
3661   1          x0: 8-bits memory data read/write.
3662   1          x1: 16-bits memory data read/write
3663   1          */
3664   1          unsigned char temp;
3665   1      
3666   1          LCD_CmdWrite(0x5E);
3667   1          temp = LCD_DataRead();
3668   1          temp &= cClrb1;
3669   1          temp |= cSetb0;
3670   1          LCD_DataWrite(temp);
3671   1      }
3672          void Memory_24bpp_Mode(void)
3673          {
3674   1          /*
3675   1          Canvas image’s color depth & memory R/W data width
3676   1          In Block Mode:
3677   1          00: 8bpp
3678   1          01: 16bpp
3679   1          1x: 24bpp
3680   1          In Linear Mode:
3681   1          x0: 8-bits memory data read/write.
3682   1          x1: 16-bits memory data read/write
3683   1          */
3684   1          unsigned char temp;
3685   1      
3686   1          LCD_CmdWrite(0x5E);
3687   1          temp = LCD_DataRead();
3688   1          temp |= cSetb1;
3689   1          //  temp |= cSetb0;
3690   1          LCD_DataWrite(temp);
3691   1      }
3692          
3693          //[5Fh][60h][61h][62h]=========================================================================
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 61  

3694          void Goto_Pixel_XY(unsigned short WX, unsigned short HY)
3695          {
3696   1          /*
3697   1          Set Graphic Read/Write position
3698   1      
3699   1          REG[5Eh] bit3, Select to read back Graphic Read/Write position.
3700   1          When DPRAM Linear mode:Graphic Read/Write Position [31:24][23:16][15:8][7:0]
3701   1          When DPRAM Active window mode:Graphic Read/Write
3702   1          Horizontal Position [12:8][7:0],
3703   1          Vertical Position [12:8][7:0].
3704   1          Reference Canvas image coordinate. Unit: Pixel
3705   1          */
3706   1          LCD_CmdWrite(0x5F);
3707   1          LCD_DataWrite(WX);
3708   1          LCD_CmdWrite(0x60);
3709   1          LCD_DataWrite(WX >> 8);
3710   1          LCD_CmdWrite(0x61);
3711   1          LCD_DataWrite(HY);
3712   1          LCD_CmdWrite(0x62);
3713   1          LCD_DataWrite(HY >> 8);
3714   1      }
3715          void Goto_Linear_Addr(unsigned long Addr)
3716          {
3717   1          /*
3718   1          Set Graphic Read/Write position
3719   1      
3720   1          REG[5Eh] bit3, Select to read back Graphic Read/Write position.
3721   1          When DPRAM Linear mode:Graphic Read/Write Position [31:24][23:16][15:8][7:0]
3722   1          When DPRAM Active window mode:Graphic Read/Write
3723   1          Horizontal Position [12:8][7:0],
3724   1          Vertical Position [12:8][7:0].
3725   1          Reference Canvas image coordinate. Unit: Pixel
3726   1          */
3727   1          LCD_CmdWrite(0x5F);
3728   1          LCD_DataWrite(Addr);
3729   1          LCD_CmdWrite(0x60);
3730   1          LCD_DataWrite(Addr >> 8);
3731   1          LCD_CmdWrite(0x61);
3732   1          LCD_DataWrite(Addr >> 16);
3733   1          LCD_CmdWrite(0x62);
3734   1          LCD_DataWrite(Addr >> 24);
3735   1      }
3736          
3737          //[63h][64h][65h][66h]=========================================================================
3738          void Goto_Text_XY(unsigned short WX, unsigned short HY)
3739          {
3740   1          /*
3741   1          Set Text Write position
3742   1          Text Write X-coordinate [12:8][7:0]
3743   1          Text Write Y-coordinate [12:8][7:0]
3744   1          Reference Canvas image coordinate.
3745   1          Unit: Pixel
3746   1          */
3747   1          LCD_CmdWrite(0x63);
3748   1          LCD_DataWrite(WX);
3749   1          LCD_CmdWrite(0x64);
3750   1          LCD_DataWrite(WX >> 8);
3751   1          LCD_CmdWrite(0x65);
3752   1          LCD_DataWrite(HY);
3753   1          LCD_CmdWrite(0x66);
3754   1          LCD_DataWrite(HY >> 8);
3755   1      }
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 62  

3756          
3757          //[67h]=========================================================================
3758          /*
3759          [bit7]Draw Line / Triangle Start Signal
3760          Write Function
3761          0 : Stop the drawing function.
3762          1 : Start the drawing function.
3763          Read Function
3764          0 : Drawing function complete.
3765          1 : Drawing function is processing.
3766          [bit5]Fill function for Triangle Signal
3767          0 : Non fill.
3768          1 : Fill.
3769          [bit1]Draw Triangle or Line Select Signal
3770          0 : Draw Line
3771          1 : Draw Triangle
3772          */
3773          void Draw_Enable_AA(void)
3774          {
3775   1          unsigned char temp;
3776   1      
3777   1          LCD_CmdWrite(0x67);
3778   1          temp = LCD_DataRead();
3779   1      
3780   1          temp |= cSetb0;
3781   1          LCD_DataWrite(temp);
3782   1      }
3783          void Draw_Disable_AA(void)
3784          {
3785   1          unsigned char temp;
3786   1      
3787   1          LCD_CmdWrite(0x67);
3788   1          temp = LCD_DataRead();
3789   1          temp &= cClrb0;
3790   1          LCD_DataWrite(temp);
3791   1      }
3792          void Start_Line(void)
3793          {
3794   1          unsigned char temp;
3795   1      
3796   1          LCD_CmdWrite(0x67);
3797   1          temp = LCD_DataRead();
3798   1          temp &= cClrb1;
3799   1          temp |= cSetb7;
3800   1          LCD_DataWrite(temp);
3801   1      
3802   1          Check_2D_Busy();
3803   1      }
3804          void Start_Triangle(void)
3805          {
3806   1          unsigned char temp;
3807   1      
3808   1          LCD_CmdWrite(0x67);
3809   1          temp = LCD_DataRead();
3810   1          temp |= cSetb1;
3811   1          temp &= cClrb5;
3812   1          //  LCD_DataWrite(temp);
3813   1          temp |= cSetb7;
3814   1          LCD_DataWrite(temp);
3815   1      
3816   1          Check_2D_Busy();
3817   1      }
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 63  

3818          void Start_Triangle_Fill(void)
3819          {
3820   1          unsigned char temp;
3821   1      
3822   1          LCD_CmdWrite(0x67);
3823   1          temp = LCD_DataRead();
3824   1          temp |= cSetb1;
3825   1          temp |= cSetb5;
3826   1          //  LCD_DataWrite(temp);
3827   1          temp |= cSetb7;
3828   1          LCD_DataWrite(temp);
3829   1      
3830   1          Check_2D_Busy();
3831   1      }
3832          //[68h][69h][6Ah][6Bh]=========================================================================
3833          // 起c
3834          void Line_Start_XY(unsigned short WX, unsigned short HY)
3835          {
3836   1          /*
3837   1          [68h] Draw Line/Square/Triangle Start X-coordinate [7:0]
3838   1          [69h] Draw Line/Square/Triangle Start X-coordinate [12:8]
3839   1          [6Ah] Draw Line/Square/Triangle Start Y-coordinate [7:0]
3840   1          [6Bh] Draw Line/Square/Triangle Start Y-coordinate [12:8]
3841   1          */
3842   1          LCD_CmdWrite(0x68);
3843   1          LCD_DataWrite(WX);
3844   1      
3845   1          LCD_CmdWrite(0x69);
3846   1          LCD_DataWrite(WX >> 8);
3847   1      
3848   1          LCD_CmdWrite(0x6A);
3849   1          LCD_DataWrite(HY);
3850   1      
3851   1          LCD_CmdWrite(0x6B);
3852   1          LCD_DataWrite(HY >> 8);
3853   1      }
3854          //[6Ch][6Dh][6Eh][6Fh]=========================================================================
3855          // Kc
3856          void Line_End_XY(unsigned short WX, unsigned short HY)
3857          {
3858   1          /*
3859   1          [6Ch] Draw Line/Square/Triangle End X-coordinate [7:0]
3860   1          [6Dh] Draw Line/Square/Triangle End X-coordinate [12:8]
3861   1          [6Eh] Draw Line/Square/Triangle End Y-coordinate [7:0]
3862   1          [6Fh] Draw Line/Square/Triangle End Y-coordinate [12:8]
3863   1          */
3864   1          LCD_CmdWrite(0x6C);
3865   1          LCD_DataWrite(WX);
3866   1      
3867   1          LCD_CmdWrite(0x6D);
3868   1          LCD_DataWrite(WX >> 8);
3869   1      
3870   1          LCD_CmdWrite(0x6E);
3871   1          LCD_DataWrite(HY);
3872   1      
3873   1          LCD_CmdWrite(0x6F);
3874   1          LCD_DataWrite(HY >> 8);
3875   1      }
3876          //[68h]~[73h]=========================================================================
3877          // 三角-c1
3878          void Triangle_Point1_XY(unsigned short WX, unsigned short HY)
3879          {
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 64  

3880   1          /*
3881   1          [68h] Draw Line/Square/Triangle Start X-coordinate [7:0]
3882   1          [69h] Draw Line/Square/Triangle Start X-coordinate [12:8]
3883   1          [6Ah] Draw Line/Square/Triangle Start Y-coordinate [7:0]
3884   1          [6Bh] Draw Line/Square/Triangle Start Y-coordinate [12:8]
3885   1          */
3886   1          LCD_CmdWrite(0x68);
3887   1          LCD_DataWrite(WX);
3888   1      
3889   1          LCD_CmdWrite(0x69);
3890   1          LCD_DataWrite(WX >> 8);
3891   1      
3892   1          LCD_CmdWrite(0x6A);
3893   1          LCD_DataWrite(HY);
3894   1      
3895   1          LCD_CmdWrite(0x6B);
3896   1          LCD_DataWrite(HY >> 8);
3897   1      }
3898          // 三角-c2
3899          void Triangle_Point2_XY(unsigned short WX, unsigned short HY)
3900          {
3901   1          /*
3902   1          [6Ch] Draw Line/Square/Triangle End X-coordinate [7:0]
3903   1          [6Dh] Draw Line/Square/Triangle End X-coordinate [12:8]
3904   1          [6Eh] Draw Line/Square/Triangle End Y-coordinate [7:0]
3905   1          [6Fh] Draw Line/Square/Triangle End Y-coordinate [12:8]
3906   1          */
3907   1          LCD_CmdWrite(0x6C);
3908   1          LCD_DataWrite(WX);
3909   1      
3910   1          LCD_CmdWrite(0x6D);
3911   1          LCD_DataWrite(WX >> 8);
3912   1      
3913   1          LCD_CmdWrite(0x6E);
3914   1          LCD_DataWrite(HY);
3915   1      
3916   1          LCD_CmdWrite(0x6F);
3917   1          LCD_DataWrite(HY >> 8);
3918   1      }
3919          // 三角-c3
3920          void Triangle_Point3_XY(unsigned short WX, unsigned short HY)
3921          {
3922   1          /*
3923   1          [70h] Draw Triangle Point 3 X-coordinate [7:0]
3924   1          [71h] Draw Triangle Point 3 X-coordinate [12:8]
3925   1          [72h] Draw Triangle Point 3 Y-coordinate [7:0]
3926   1          [73h] Draw Triangle Point 3 Y-coordinate [12:8]
3927   1          */
3928   1          LCD_CmdWrite(0x70);
3929   1          LCD_DataWrite(WX);
3930   1      
3931   1          LCD_CmdWrite(0x71);
3932   1          LCD_DataWrite(WX >> 8);
3933   1      
3934   1          LCD_CmdWrite(0x72);
3935   1          LCD_DataWrite(HY);
3936   1      
3937   1          LCD_CmdWrite(0x73);
3938   1          LCD_DataWrite(HY >> 8);
3939   1      }
3940          // 方起c
3941          void Square_Start_XY(unsigned short WX, unsigned short HY)
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 65  

3942          {
3943   1          /*
3944   1          [68h] Draw Line/Square/Triangle Start X-coordinate [7:0]
3945   1          [69h] Draw Line/Square/Triangle Start X-coordinate [12:8]
3946   1          [6Ah] Draw Line/Square/Triangle Start Y-coordinate [7:0]
3947   1          [6Bh] Draw Line/Square/Triangle Start Y-coordinate [12:8]
3948   1          */
3949   1          LCD_CmdWrite(0x68);
3950   1          LCD_DataWrite(WX);
3951   1      
3952   1          LCD_CmdWrite(0x69);
3953   1          LCD_DataWrite(WX >> 8);
3954   1      
3955   1          LCD_CmdWrite(0x6A);
3956   1          LCD_DataWrite(HY);
3957   1      
3958   1          LCD_CmdWrite(0x6B);
3959   1          LCD_DataWrite(HY >> 8);
3960   1      }
3961          // 方Kc
3962          void Square_End_XY(unsigned short WX, unsigned short HY)
3963          {
3964   1          /*
3965   1          [6Ch] Draw Line/Square/Triangle End X-coordinate [7:0]
3966   1          [6Dh] Draw Line/Square/Triangle End X-coordinate [12:8]
3967   1          [6Eh] Draw Line/Square/Triangle End Y-coordinate [7:0]
3968   1          [6Fh] Draw Line/Square/Triangle End Y-coordinate [12:8]
3969   1          */
3970   1          LCD_CmdWrite(0x6C);
3971   1          LCD_DataWrite(WX);
3972   1      
3973   1          LCD_CmdWrite(0x6D);
3974   1          LCD_DataWrite(WX >> 8);
3975   1      
3976   1          LCD_CmdWrite(0x6E);
3977   1          LCD_DataWrite(HY);
3978   1      
3979   1          LCD_CmdWrite(0x6F);
3980   1          LCD_DataWrite(HY >> 8);
3981   1      }
3982          //[76h]=========================================================================
3983          /*
3984          [bit7]
3985          Draw Circle / Ellipse / Square /Circle Square Start Signal
3986          Write Function
3987          0 : Stop the drawing function.
3988          1 : Start the drawing function.
3989          Read Function
3990          0 : Drawing function complete.
3991          1 : Drawing function is processing.
3992          [bit6]
3993          Fill the Circle / Ellipse / Square / Circle Square Signal
3994          0 : Non fill.
3995          1 : fill.
3996          [bit5 bit4]
3997          Draw Circle / Ellipse / Square / Ellipse Curve / Circle Square Select
3998          00 : Draw Circle / Ellipse
3999          01 : Draw Circle / Ellipse Curve
4000          10 : Draw Square.
4001          11 : Draw Circle Square.
4002          [bit1 bit0]
4003          Draw Circle / Ellipse Curve Part Select
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 66  

4004          00 : bottom-left Ellipse Curve
4005          01 : upper-left Ellipse Curve
4006          10 : upper-right Ellipse Curve
4007          11 : bottom-right Ellipse Curve
4008          */
4009          void Start_Circle_or_Ellipse(void)
4010          {
4011   1          LCD_CmdWrite(0x76);
4012   1          LCD_DataWrite(0x80); // B1000_XXXX
4013   1      
4014   1          Check_2D_Busy();
4015   1      }
4016          void Start_Circle_or_Ellipse_Fill(void)
4017          {
4018   1          LCD_CmdWrite(0x76);
4019   1          LCD_DataWrite(0xC0); // B1100_XXXX
4020   1      
4021   1          Check_2D_Busy();
4022   1      }
4023          //
4024          void Start_Left_Down_Curve(void)
4025          {
4026   1          LCD_CmdWrite(0x76);
4027   1          LCD_DataWrite(0x90); // B1001_XX00
4028   1      
4029   1          Check_2D_Busy();
4030   1      }
4031          void Start_Left_Up_Curve(void)
4032          {
4033   1          LCD_CmdWrite(0x76);
4034   1          LCD_DataWrite(0x91); // B1001_XX01
4035   1      
4036   1          Check_2D_Busy();
4037   1      }
4038          void Start_Right_Up_Curve(void)
4039          {
4040   1          LCD_CmdWrite(0x76);
4041   1          LCD_DataWrite(0x92); // B1001_XX10
4042   1      
4043   1          Check_2D_Busy();
4044   1      }
4045          void Start_Right_Down_Curve(void)
4046          {
4047   1          LCD_CmdWrite(0x76);
4048   1          LCD_DataWrite(0x93); // B1001_XX11
4049   1      
4050   1          Check_2D_Busy();
4051   1      }
4052          //
4053          void Start_Left_Down_Curve_Fill(void)
4054          {
4055   1          LCD_CmdWrite(0x76);
4056   1          LCD_DataWrite(0xD0); // B1101_XX00
4057   1      
4058   1          Check_2D_Busy();
4059   1      }
4060          void Start_Left_Up_Curve_Fill(void)
4061          {
4062   1          LCD_CmdWrite(0x76);
4063   1          LCD_DataWrite(0xD1); // B1101_XX01
4064   1      
4065   1          Check_2D_Busy();
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 67  

4066   1      }
4067          void Start_Right_Up_Curve_Fill(void)
4068          {
4069   1          LCD_CmdWrite(0x76);
4070   1          LCD_DataWrite(0xD2); // B1101_XX10
4071   1      
4072   1          Check_2D_Busy();
4073   1      }
4074          void Start_Right_Down_Curve_Fill(void)
4075          {
4076   1          LCD_CmdWrite(0x76);
4077   1          LCD_DataWrite(0xD3); // B1101_XX11
4078   1      
4079   1          Check_2D_Busy();
4080   1      }
4081          //
4082          void Start_Square(void)
4083          {
4084   1          LCD_CmdWrite(0x76);
4085   1          LCD_DataWrite(0xA0); // B1010_XXXX
4086   1      
4087   1          Check_2D_Busy();
4088   1      }
4089          void Start_Square_Fill(void)
4090          {
4091   1          LCD_CmdWrite(0x76);
4092   1          LCD_DataWrite(0xE0); // B1110_XXXX
4093   1      
4094   1          Check_2D_Busy();
4095   1      }
4096          void Start_Circle_Square(void)
4097          {
4098   1          LCD_CmdWrite(0x76);
4099   1          LCD_DataWrite(0xB0); // B1011_XXXX
4100   1      
4101   1          Check_2D_Busy();
4102   1      }
4103          void Start_Circle_Square_Fill(void)
4104          {
4105   1          LCD_CmdWrite(0x76);
4106   1          LCD_DataWrite(0xF0); // B1111_XXXX
4107   1      
4108   1          Check_2D_Busy();
4109   1      }
4110          //[77h]~[7Eh]=========================================================================
4111          // A半
4112          void Circle_Radius_R(unsigned short WX)
4113          {
4114   1          /*
4115   1          [77h] Draw Circle/Ellipse/Circle Square Major radius [7:0]
4116   1          [78h] Draw Circle/Ellipse/Circle Square Major radius [12:8]
4117   1          [79h] Draw Circle/Ellipse/Circle Square Minor radius [7:0]
4118   1          [7Ah] Draw Circle/Ellipse/Circle Square Minor radius [12:8]
4119   1          */
4120   1          LCD_CmdWrite(0x77);
4121   1          LCD_DataWrite(WX);
4122   1      
4123   1          LCD_CmdWrite(0x78);
4124   1          LCD_DataWrite(WX >> 8);
4125   1      
4126   1          LCD_CmdWrite(0x79);
4127   1          LCD_DataWrite(WX);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 68  

4128   1      
4129   1          LCD_CmdWrite(0x7A);
4130   1          LCD_DataWrite(WX >> 8);
4131   1      }
4132          
4133          // EA半
4134          void Ellipse_Radius_RxRy(unsigned short WX, unsigned short HY)
4135          {
4136   1          /*
4137   1          [77h] Draw Circle/Ellipse/Circle Square Major radius [7:0]
4138   1          [78h] Draw Circle/Ellipse/Circle Square Major radius [12:8]
4139   1          [79h] Draw Circle/Ellipse/Circle Square Minor radius [7:0]
4140   1          [7Ah] Draw Circle/Ellipse/Circle Square Minor radius [12:8]
4141   1          */
4142   1          LCD_CmdWrite(0x77);
4143   1          LCD_DataWrite(WX);
4144   1      
4145   1          LCD_CmdWrite(0x78);
4146   1          LCD_DataWrite(WX >> 8);
4147   1      
4148   1          LCD_CmdWrite(0x79);
4149   1          LCD_DataWrite(HY);
4150   1      
4151   1          LCD_CmdWrite(0x7A);
4152   1          LCD_DataWrite(HY >> 8);
4153   1      }
4154          
4155          // 方形D角半
4156          void Circle_Square_Radius_RxRy(unsigned short WX, unsigned short HY)
4157          {
4158   1          /*
4159   1          [77h] Draw Circle/Ellipse/Circle Square Major radius [7:0]
4160   1          [78h] Draw Circle/Ellipse/Circle Square Major radius [12:8]
4161   1          [79h] Draw Circle/Ellipse/Circle Square Minor radius [7:0]
4162   1          [7Ah] Draw Circle/Ellipse/Circle Square Minor radius [12:8]
4163   1          */
4164   1          LCD_CmdWrite(0x77);
4165   1          LCD_DataWrite(WX);
4166   1      
4167   1          LCD_CmdWrite(0x78);
4168   1          LCD_DataWrite(WX >> 8);
4169   1      
4170   1          LCD_CmdWrite(0x79);
4171   1          LCD_DataWrite(HY);
4172   1      
4173   1          LCD_CmdWrite(0x7A);
4174   1          LCD_DataWrite(HY >> 8);
4175   1      }
4176          
4177          // A中心
4178          void Circle_Center_XY(unsigned short WX, unsigned short HY)
4179          {
4180   1          /*
4181   1          [7Bh] Draw Circle/Ellipse/Circle Square Center X-coordinate [7:0]
4182   1          [7Ch] Draw Circle/Ellipse/Circle Square Center X-coordinate [12:8]
4183   1          [7Dh] Draw Circle/Ellipse/Circle Square Center Y-coordinate [7:0]
4184   1          [7Eh] Draw Circle/Ellipse/Circle Square Center Y-coordinate [12:8]
4185   1          */
4186   1          LCD_CmdWrite(0x7B);
4187   1          LCD_DataWrite(WX);
4188   1      
4189   1          LCD_CmdWrite(0x7C);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 69  

4190   1          LCD_DataWrite(WX >> 8);
4191   1      
4192   1          LCD_CmdWrite(0x7D);
4193   1          LCD_DataWrite(HY);
4194   1      
4195   1          LCD_CmdWrite(0x7E);
4196   1          LCD_DataWrite(HY >> 8);
4197   1      }
4198          // EA中心
4199          void Ellipse_Center_XY(unsigned short WX, unsigned short HY)
4200          {
4201   1          /*
4202   1          [7Bh] Draw Circle/Ellipse/Circle Square Center X-coordinate [7:0]
4203   1          [7Ch] Draw Circle/Ellipse/Circle Square Center X-coordinate [12:8]
4204   1          [7Dh] Draw Circle/Ellipse/Circle Square Center Y-coordinate [7:0]
4205   1          [7Eh] Draw Circle/Ellipse/Circle Square Center Y-coordinate [12:8]
4206   1          */
4207   1          LCD_CmdWrite(0x7B);
4208   1          LCD_DataWrite(WX);
4209   1      
4210   1          LCD_CmdWrite(0x7C);
4211   1          LCD_DataWrite(WX >> 8);
4212   1      
4213   1          LCD_CmdWrite(0x7D);
4214   1          LCD_DataWrite(HY);
4215   1      
4216   1          LCD_CmdWrite(0x7E);
4217   1          LCD_DataWrite(HY >> 8);
4218   1      }
4219          
4220          //[84h]=========================================================================
4221          void Set_PWM_Prescaler_1_to_256(unsigned short WX)
4222          {
4223   1          /*
4224   1          PWM Prescaler Register
4225   1          These 8 bits determine prescaler value for Timer 0 and 1.
4226   1          Time base is “Core_Freq / (Prescaler + 1)”
4227   1          */
4228   1          LCD_CmdWrite(0x84);
4229   1          LCD_DataWrite(WX - 1);
4230   1      }
4231          //[85h]=========================================================================
4232          void Select_PWM1_Clock_Divided_By_1(void)
4233          {
4234   1          /*
4235   1          Select MUX input for PWM Timer 1.
4236   1          00 = 1; 01 = 1/2; 10 = 1/4 ; 11 = 1/8;
4237   1          */
4238   1          unsigned char temp;
4239   1      
4240   1          LCD_CmdWrite(0x85);
4241   1          temp = LCD_DataRead();
4242   1          temp &= cClrb7;
4243   1          temp &= cClrb6;
4244   1          LCD_DataWrite(temp);
4245   1      }
4246          void Select_PWM1_Clock_Divided_By_2(void)
4247          {
4248   1          /*
4249   1          Select MUX input for PWM Timer 1.
4250   1          00 = 1; 01 = 1/2; 10 = 1/4 ; 11 = 1/8;
4251   1          */
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 70  

4252   1          unsigned char temp;
4253   1      
4254   1          LCD_CmdWrite(0x85);
4255   1          temp = LCD_DataRead();
4256   1          temp &= cClrb7;
4257   1          temp |= cSetb6;
4258   1          LCD_DataWrite(temp);
4259   1      }
4260          void Select_PWM1_Clock_Divided_By_4(void)
4261          {
4262   1          /*
4263   1          Select MUX input for PWM Timer 1.
4264   1          00 = 1; 01 = 1/2; 10 = 1/4 ; 11 = 1/8;
4265   1          */
4266   1          unsigned char temp;
4267   1      
4268   1          LCD_CmdWrite(0x85);
4269   1          temp = LCD_DataRead();
4270   1          temp |= cSetb7;
4271   1          temp &= cClrb6;
4272   1          LCD_DataWrite(temp);
4273   1      }
4274          void Select_PWM1_Clock_Divided_By_8(void)
4275          {
4276   1          /*
4277   1          Select MUX input for PWM Timer 1.
4278   1          00 = 1; 01 = 1/2; 10 = 1/4 ; 11 = 1/8;
4279   1          */
4280   1          unsigned char temp;
4281   1      
4282   1          LCD_CmdWrite(0x85);
4283   1          temp = LCD_DataRead();
4284   1          temp |= cSetb7;
4285   1          temp |= cSetb6;
4286   1          LCD_DataWrite(temp);
4287   1      }
4288          void Select_PWM0_Clock_Divided_By_1(void)
4289          {
4290   1          /*
4291   1          Select MUX input for PWM Timer 0.
4292   1          00 = 1; 01 = 1/2; 10 = 1/4 ; 11 = 1/8;
4293   1          */
4294   1          unsigned char temp;
4295   1      
4296   1          LCD_CmdWrite(0x85);
4297   1          temp = LCD_DataRead();
4298   1          temp &= cClrb5;
4299   1          temp &= cClrb4;
4300   1          LCD_DataWrite(temp);
4301   1      }
4302          void Select_PWM0_Clock_Divided_By_2(void)
4303          {
4304   1          /*
4305   1          Select MUX input for PWM Timer 0.
4306   1          00 = 1; 01 = 1/2; 10 = 1/4 ; 11 = 1/8;
4307   1          */
4308   1          unsigned char temp;
4309   1      
4310   1          LCD_CmdWrite(0x85);
4311   1          temp = LCD_DataRead();
4312   1          temp &= cClrb5;
4313   1          temp |= cSetb4;
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 71  

4314   1          LCD_DataWrite(temp);
4315   1      }
4316          void Select_PWM0_Clock_Divided_By_4(void)
4317          {
4318   1          /*
4319   1          Select MUX input for PWM Timer 0.
4320   1          00 = 1; 01 = 1/2; 10 = 1/4 ; 11 = 1/8;
4321   1          */
4322   1          unsigned char temp;
4323   1      
4324   1          LCD_CmdWrite(0x85);
4325   1          temp = LCD_DataRead();
4326   1          temp |= cSetb5;
4327   1          temp &= cClrb4;
4328   1          LCD_DataWrite(temp);
4329   1      }
4330          void Select_PWM0_Clock_Divided_By_8(void)
4331          {
4332   1          /*
4333   1          Select MUX input for PWM Timer 0.
4334   1          00 = 1; 01 = 1/2; 10 = 1/4 ; 11 = 1/8;
4335   1          */
4336   1          unsigned char temp;
4337   1      
4338   1          LCD_CmdWrite(0x85);
4339   1          temp = LCD_DataRead();
4340   1          temp |= cSetb5;
4341   1          temp |= cSetb4;
4342   1          LCD_DataWrite(temp);
4343   1      }
4344          //[85h].[bit3][bit2]=========================================================================
4345          /*
4346          XPWM[1] pin function control
4347          0X: XPWM[1] output system error flag (REG[00h] bit[1:0], Scan bandwidth insufficient + Memory access out o
             -f range)
4348          10: XPWM[1] enabled and controlled by PWM timer 1
4349          11: XPWM[1] output oscillator clock
4350          //If XTEST[0] set high, then XPWM[1] will become panel scan clock input.
4351          */
4352          void Select_PWM1_is_ErrorFlag(void)
4353          {
4354   1          unsigned char temp;
4355   1      
4356   1          LCD_CmdWrite(0x85);
4357   1          temp = LCD_DataRead();
4358   1          temp &= cClrb3;
4359   1          LCD_DataWrite(temp);
4360   1      }
4361          void Select_PWM1(void)
4362          {
4363   1          unsigned char temp;
4364   1      
4365   1          LCD_CmdWrite(0x85);
4366   1          temp = LCD_DataRead();
4367   1          temp |= cSetb3;
4368   1          temp &= cClrb2;
4369   1          LCD_DataWrite(temp);
4370   1      }
4371          void Select_PWM1_is_Osc_Clock(void)
4372          {
4373   1          unsigned char temp;
4374   1      
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 72  

4375   1          LCD_CmdWrite(0x85);
4376   1          temp = LCD_DataRead();
4377   1          temp |= cSetb3;
4378   1          temp |= cSetb2;
4379   1          LCD_DataWrite(temp);
4380   1      }
4381          //[85h].[bit1][bit0]=========================================================================
4382          /*
4383          XPWM[0] pin function control
4384          0X: XPWM[0] becomes GPIO-C[7]
4385          10: XPWM[0] enabled and controlled by PWM timer 0
4386          11: XPWM[0] output core clock
4387          */
4388          void Select_PWM0_is_GPIO_C7(void)
4389          {
4390   1          unsigned char temp;
4391   1      
4392   1          LCD_CmdWrite(0x85);
4393   1          temp = LCD_DataRead();
4394   1          temp &= cClrb1;
4395   1          LCD_DataWrite(temp);
4396   1      }
4397          void Select_PWM0(void)
4398          {
4399   1          unsigned char temp;
4400   1      
4401   1          LCD_CmdWrite(0x85);
4402   1          temp = LCD_DataRead();
4403   1          temp |= cSetb1;
4404   1          temp &= cClrb0;
4405   1          LCD_DataWrite(temp);
4406   1      }
4407          void Select_PWM0_is_Core_Clock(void)
4408          {
4409   1          unsigned char temp;
4410   1      
4411   1          LCD_CmdWrite(0x85);
4412   1          temp = LCD_DataRead();
4413   1          temp |= cSetb1;
4414   1          temp |= cSetb0;
4415   1          LCD_DataWrite(temp);
4416   1      }
4417          //[86h]=========================================================================
4418          //[86h]PWM1
4419          void Enable_PWM1_Inverter(void)
4420          {
4421   1          /*
4422   1          PWM Timer 1 output inverter on/off.
4423   1          Determine the output inverter on/off for Timer 1.
4424   1          0 = Inverter off
4425   1          1 = Inverter on for PWM1
4426   1          */
4427   1          unsigned char temp;
4428   1          LCD_CmdWrite(0x86);
4429   1          temp = LCD_DataRead();
4430   1          temp |= cSetb6;
4431   1          LCD_DataWrite(temp);
4432   1      }
4433          void Disable_PWM1_Inverter(void)
4434          {
4435   1          /*
4436   1          PWM Timer 1 output inverter on/off.
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 73  

4437   1          Determine the output inverter on/off for Timer 1.
4438   1          0 = Inverter off
4439   1          1 = Inverter on for PWM1
4440   1          */
4441   1          unsigned char temp;
4442   1          LCD_CmdWrite(0x86);
4443   1          temp = LCD_DataRead();
4444   1          temp &= cClrb6;
4445   1          LCD_DataWrite(temp);
4446   1      }
4447          void Auto_Reload_PWM1(void)
4448          {
4449   1          /*
4450   1          PWM Timer 1 auto reload on/off
4451   1          Determine auto reload on/off for Timer 1.
4452   1          0 = One-shot
4453   1          1 = Interval mode(auto reload)
4454   1          */
4455   1          unsigned char temp;
4456   1          LCD_CmdWrite(0x86);
4457   1          temp = LCD_DataRead();
4458   1          temp |= cSetb5;
4459   1          LCD_DataWrite(temp);
4460   1      }
4461          void One_Shot_PWM1(void)
4462          {
4463   1          /*
4464   1          PWM Timer 1 auto reload on/off
4465   1          Determine auto reload on/off for Timer 1.
4466   1          0 = One-shot
4467   1          1 = Interval mode(auto reload)
4468   1          */
4469   1          unsigned char temp;
4470   1          LCD_CmdWrite(0x86);
4471   1          temp = LCD_DataRead();
4472   1          temp &= cClrb5;
4473   1          LCD_DataWrite(temp);
4474   1      }
4475          void Start_PWM1(void)
4476          {
4477   1          /*
4478   1          PWM Timer 1 start/stop
4479   1          Determine start/stop for Timer 1.
4480   1          0 = Stop
4481   1          1 = Start for Timer 1
4482   1          */
4483   1          unsigned char temp;
4484   1          LCD_CmdWrite(0x86);
4485   1          temp = LCD_DataRead();
4486   1          temp |= cSetb4;
4487   1          LCD_DataWrite(temp);
4488   1      }
4489          void Stop_PWM1(void)
4490          {
4491   1          /*
4492   1          PWM Timer 1 start/stop
4493   1          Determine start/stop for Timer 1.
4494   1          0 = Stop
4495   1          1 = Start for Timer 1
4496   1          */
4497   1          unsigned char temp;
4498   1          LCD_CmdWrite(0x86);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 74  

4499   1          temp = LCD_DataRead();
4500   1          temp &= cClrb4;
4501   1          LCD_DataWrite(temp);
4502   1      }
4503          //[86h]PWM0
4504          void Enable_PWM0_Dead_Zone(void)
4505          {
4506   1          /*
4507   1          PWM Timer 0 Dead zone enable
4508   1          Determine the dead zone operation. 0 = Disable. 1 = Enable.
4509   1          */
4510   1          unsigned char temp;
4511   1          LCD_CmdWrite(0x86);
4512   1          temp = LCD_DataRead();
4513   1          temp |= cSetb3;
4514   1          LCD_DataWrite(temp);
4515   1      }
4516          void Disable_PWM0_Dead_Zone(void)
4517          {
4518   1          /*
4519   1          PWM Timer 0 Dead zone enable
4520   1          Determine the dead zone operation. 0 = Disable. 1 = Enable.
4521   1          */
4522   1          unsigned char temp;
4523   1          LCD_CmdWrite(0x86);
4524   1          temp = LCD_DataRead();
4525   1          temp &= cClrb3;
4526   1          LCD_DataWrite(temp);
4527   1      }
4528          void Enable_PWM0_Inverter(void)
4529          {
4530   1          /*
4531   1          PWM Timer 0 output inverter on/off
4532   1          Determine the output inverter on/off for Timer 0.
4533   1          0 = Inverter off
4534   1          1 = Inverter on for PWM0
4535   1          */
4536   1          unsigned char temp;
4537   1          LCD_CmdWrite(0x86);
4538   1          temp = LCD_DataRead();
4539   1          temp |= cSetb2;
4540   1          LCD_DataWrite(temp);
4541   1      }
4542          void Disable_PWM0_Inverter(void)
4543          {
4544   1          /*
4545   1          PWM Timer 0 output inverter on/off
4546   1          Determine the output inverter on/off for Timer 0.
4547   1          0 = Inverter off
4548   1          1 = Inverter on for PWM0
4549   1          */
4550   1          unsigned char temp;
4551   1          LCD_CmdWrite(0x86);
4552   1          temp = LCD_DataRead();
4553   1          temp &= cClrb2;
4554   1          LCD_DataWrite(temp);
4555   1      }
4556          void Auto_Reload_PWM0(void)
4557          {
4558   1          /*
4559   1          PWM Timer 0 auto reload on/off
4560   1          Determine auto reload on/off for Timer 0.
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 75  

4561   1          0 = One-shot
4562   1          1 = Interval mode(auto reload)
4563   1          */
4564   1          unsigned char temp;
4565   1          LCD_CmdWrite(0x86);
4566   1          temp = LCD_DataRead();
4567   1          temp |= cSetb1;
4568   1          LCD_DataWrite(temp);
4569   1      }
4570          void One_Shot_PWM0(void)
4571          {
4572   1          /*
4573   1          PWM Timer 1 auto reload on/off
4574   1          Determine auto reload on/off for Timer 1.
4575   1          0 = One-shot
4576   1          1 = Interval mode(auto reload)
4577   1          */
4578   1          unsigned char temp;
4579   1          LCD_CmdWrite(0x86);
4580   1          temp = LCD_DataRead();
4581   1          temp &= cClrb1;
4582   1          LCD_DataWrite(temp);
4583   1      }
4584          void Start_PWM0(void)
4585          {
4586   1          /*
4587   1          PWM Timer 0 start/stop
4588   1          Determine start/stop for Timer 0.
4589   1          0 = Stop
4590   1          1 = Start for Timer 0
4591   1          */
4592   1          unsigned char temp;
4593   1          LCD_CmdWrite(0x86);
4594   1          temp = LCD_DataRead();
4595   1          temp |= cSetb0;
4596   1          LCD_DataWrite(temp);
4597   1      }
4598          void Stop_PWM0(void)
4599          {
4600   1          /*
4601   1          PWM Timer 0 start/stop
4602   1          Determine start/stop for Timer 0.
4603   1          0 = Stop
4604   1          1 = Start for Timer 0
4605   1          */
4606   1          unsigned char temp;
4607   1          LCD_CmdWrite(0x86);
4608   1          temp = LCD_DataRead();
4609   1          temp &= cClrb0;
4610   1          LCD_DataWrite(temp);
4611   1      }
4612          //[87h]=========================================================================
4613          void Set_Timer0_Dead_Zone_Length(unsigned char temp)
4614          {
4615   1          /*
4616   1          Timer 0 Dead zone length register
4617   1          These 8 bits determine the dead zone length. The 1 unit time of
4618   1          the dead zone length is equal to that of timer 0.
4619   1          */
4620   1          LCD_CmdWrite(0x87);
4621   1          LCD_DataWrite(temp);
4622   1      }
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 76  

4623          //[88h][89h]=========================================================================
4624          void Set_Timer0_Compare_Buffer(unsigned short WX)
4625          {
4626   1          /*
4627   1          Timer 0 compare buffer register
4628   1          Compare buffer register total has 16 bits.
4629   1          When timer counter equal or less than compare buffer register will cause PWM out
4630   1          high level if inv_on bit is off.
4631   1          */
4632   1          LCD_CmdWrite(0x88);
4633   1          LCD_DataWrite(WX);
4634   1          LCD_CmdWrite(0x89);
4635   1          LCD_DataWrite(WX >> 8);
4636   1      }
4637          //[8Ah][8Bh]=========================================================================
4638          void Set_Timer0_Count_Buffer(unsigned short WX)
4639          {
4640   1          /*
4641   1          Timer 0 count buffer register
4642   1          Count buffer register total has 16 bits.
4643   1          When timer counter equal to 0 will cause PWM timer reload Count buffer register if reload_en bit set a
             -s enable.
4644   1          It may read back timer counter’s real time value when PWM timer start.
4645   1          */
4646   1          LCD_CmdWrite(0x8A);
4647   1          LCD_DataWrite(WX);
4648   1          LCD_CmdWrite(0x8B);
4649   1          LCD_DataWrite(WX >> 8);
4650   1      }
4651          //[8Ch][8Dh]=========================================================================
4652          void Set_Timer1_Compare_Buffer(unsigned short WX)
4653          {
4654   1          /*
4655   1          Timer 0 compare buffer register
4656   1          Compare buffer register total has 16 bits.
4657   1          When timer counter equal or less than compare buffer register will cause PWM out
4658   1          high level if inv_on bit is off.
4659   1          */
4660   1          LCD_CmdWrite(0x8C);
4661   1          LCD_DataWrite(WX);
4662   1          LCD_CmdWrite(0x8D);
4663   1          LCD_DataWrite(WX >> 8);
4664   1      }
4665          //[8Eh][8Fh]=========================================================================
4666          void Set_Timer1_Count_Buffer(unsigned short WX)
4667          {
4668   1          /*
4669   1          Timer 0 count buffer register
4670   1          Count buffer register total has 16 bits.
4671   1          When timer counter equal to 0 will cause PWM timer reload Count buffer register if reload_en bit set a
             -s enable.
4672   1          It may read back timer counter’s real time value when PWM timer start.
4673   1          */
4674   1          LCD_CmdWrite(0x8E);
4675   1          LCD_DataWrite(WX);
4676   1          LCD_CmdWrite(0x8F);
4677   1          LCD_DataWrite(WX >> 8);
4678   1      }
4679          
4680          
4681          
4682          
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 77  

4683          //[90h]~[B5h]=========================================================================
4684          
4685          //[90h]=========================================================================
4686          void BTE_Enable(void)
4687          {
4688   1          /*
4689   1          BTE Function Enable
4690   1          0 : BTE Function disable.
4691   1          1 : BTE Function enable.
4692   1          */
4693   1          unsigned char temp;
4694   1          LCD_CmdWrite(0x90);
4695   1          temp = LCD_DataRead();
4696   1          temp |= cSetb4;
4697   1          LCD_DataWrite(temp);
4698   1      }
4699          
4700          //[90h]=========================================================================
4701          void BTE_Disable(void)
4702          {
4703   1          /*
4704   1          BTE Function Enable
4705   1          0 : BTE Function disable.
4706   1          1 : BTE Function enable.
4707   1          */
4708   1          unsigned char temp;
4709   1          LCD_CmdWrite(0x90);
4710   1          temp = LCD_DataRead();
4711   1          temp &= cClrb4;
4712   1          LCD_DataWrite(temp);
4713   1      }
4714          
4715          //[90h]=========================================================================
4716          void Check_BTE_Busy(void)
4717          {
4718   1          /*
4719   1          case1: [90h]BTE Function Control Register_bit4
4720   1          Read
4721   1          0 : BTE function is idle.
4722   1          1 : BTE function is busy.
4723   1      
4724   1          case2: Status Register_bit3
4725   1          0 : BTE function is idle.
4726   1          1 : BTE function is busy.
4727   1          */
4728   1          unsigned char temp;
4729   1      
4730   1          // case1: using BTE Function Control Register
4731   1          do {
4732   2              LCD_CmdWrite(0x90);
4733   2              temp = LCD_DataRead();
4734   2          } while (temp & 0x10);
4735   1      
4736   1          // case2: using status register
4737   1          do {
4738   2              temp = LCD_StatusRead();
4739   2          } while (temp & 0x08);
4740   1      }
4741          //[90h]=========================================================================
4742          void Pattern_Format_8X8(void)
4743          {
4744   1          /*
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 78  

4745   1          Pattern Format
4746   1          0 : 8X8
4747   1          1 : 16X16
4748   1          */
4749   1          unsigned char temp;
4750   1          LCD_CmdWrite(0x90);
4751   1          temp = LCD_DataRead();
4752   1          temp &= cClrb0;
4753   1          LCD_DataWrite(temp);
4754   1      }
4755          //[90h]=========================================================================
4756          void Pattern_Format_16X16(void)
4757          {
4758   1          /*
4759   1          Pattern Format
4760   1          0 : 8X8
4761   1          1 : 16X16
4762   1          */
4763   1          unsigned char temp;
4764   1          LCD_CmdWrite(0x90);
4765   1          temp = LCD_DataRead();
4766   1          temp |= cSetb0;
4767   1          LCD_DataWrite(temp);
4768   1      }
4769          
4770          //[91h]=========================================================================
4771          void BTE_ROP_Code(unsigned char setx)
4772          {
4773   1          /*
4774   1          BTE ROP Code[Bit7:4]
4775   1      
4776   1          0000 : 0(Blackness)
4777   1          0001 : ~S0.~S1 or ~ ( S0+S1 )
4778   1          0010 : ~S0.S1
4779   1          0011 : ~S0
4780   1          0100 : S0.~S1
4781   1          0101 : ~S1
4782   1          0110 : S0^S1
4783   1          0111 : ~S0+~S1 or ~ ( S0.S1 )
4784   1          1000 : S0.S1
4785   1          1001 : ~ ( S0^S1 )
4786   1          1010 : S1
4787   1          1011 : ~S0+S1
4788   1          1100 : S0
4789   1          1101 : S0+~S1
4790   1          1110 : S0+S1
4791   1          1111 : 1 ( Whiteness )
4792   1          */
4793   1          unsigned char temp;
4794   1          LCD_CmdWrite(0x91);
4795   1          temp = LCD_DataRead();
4796   1          temp &= 0x0f;
4797   1          temp |= (setx << 4);
4798   1          LCD_DataWrite(temp);
4799   1      }
4800          
4801          //[91h]=========================================================================
4802          void BTE_Operation_Code(unsigned char setx)
4803          {
4804   1          /*
4805   1          BTE Operation Code[Bit3:0]
4806   1      
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 79  

4807   1          0000/ 0 : MPU Write BTE with ROP.
4808   1          0001    : NA
4809   1          0010/ 2 : Memory copy (move) BTE in positive direction with ROP.
4810   1          0011    : NA
4811   1          0100/ 4 : MPU Write with chroma keying (w/o ROP)
4812   1          0101/ 5 : Memory copy (move) with chroma keying (w/o ROP)
4813   1          0110/ 6 : Pattern Fill with ROP
4814   1          0111/ 7 : Pattern Fill with chroma keying (w/o ROP)
4815   1          1000/ 8 : MPU Write with Color Expansion (w/o ROP)
4816   1          1001/ 9 : MPU Write with Color Expansion and chroma keying (w/o ROP)
4817   1          1010/10 : Memory write with opacity (w/o ROP)
4818   1          1011/11 : MPU Write with opacity (w/o ROP)
4819   1          1100/12 : Solid Fill (w/o ROP)
4820   1          1101    : NA
4821   1          1110/14 : Memory write with Color Expansion (w/o ROP)
4822   1          1111/15 : Memory write with Color Expansion and chroma keying (w/o ROP)
4823   1          */
4824   1          unsigned char temp;
4825   1          LCD_CmdWrite(0x91);
4826   1          temp = LCD_DataRead();
4827   1          temp &= 0xf0;
4828   1          temp |= setx;
4829   1          LCD_DataWrite(temp);
4830   1      }
4831          //[92h]=========================================================================
4832          void BTE_S0_Color_8bpp(void)
4833          {
4834   1          /*
4835   1          S0 Color Depth
4836   1          00 : 256 Color
4837   1          01 : 64k Color
4838   1          1x : 16M Color
4839   1          */
4840   1          unsigned char temp;
4841   1          LCD_CmdWrite(0x92);
4842   1          temp = LCD_DataRead();
4843   1          temp &= cClrb6;
4844   1          temp &= cClrb5;
4845   1          LCD_DataWrite(temp);
4846   1      }
4847          //[92h]=========================================================================
4848          void BTE_S0_Color_16bpp(void)
4849          {
4850   1          /*
4851   1          S0 Color Depth
4852   1          00 : 256 Color
4853   1          01 : 64k Color
4854   1          1x : 16M Color
4855   1          */
4856   1          unsigned char temp;
4857   1          LCD_CmdWrite(0x92);
4858   1          temp = LCD_DataRead();
4859   1          temp &= cClrb6;
4860   1          temp |= cSetb5;
4861   1          LCD_DataWrite(temp);
4862   1      }
4863          //[92h]=========================================================================
4864          void BTE_S0_Color_24bpp(void)
4865          {
4866   1          /*
4867   1          S0 Color Depth
4868   1          00 : 256 Color
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 80  

4869   1          01 : 64k Color
4870   1          1x : 16M Color
4871   1          */
4872   1          unsigned char temp;
4873   1          LCD_CmdWrite(0x92);
4874   1          temp = LCD_DataRead();
4875   1          temp |= cSetb6;
4876   1          // temp |= cSetb5 ;
4877   1          LCD_DataWrite(temp);
4878   1      }
4879          //[92h]=========================================================================
4880          void BTE_S1_Color_8bpp(void)
4881          {
4882   1          /*
4883   1          S1 Color Depth
4884   1          000 : 256 Color
4885   1          001 : 64k Color
4886   1          010 : 16M Color
4887   1          011 : Constant Color
4888   1          100 : 8 bit pixel alpha blending
4889   1          101 : 16 bit pixel alpha blending
4890   1          110 : 32bit ARGB mode
4891   1          */
4892   1          unsigned char temp;
4893   1          LCD_CmdWrite(0x92);
4894   1          temp = LCD_DataRead();
4895   1          temp &= cClrb4;
4896   1          temp &= cClrb3;
4897   1          temp &= cClrb2;
4898   1          LCD_DataWrite(temp);
4899   1      }
4900          //[92h]=========================================================================
4901          void BTE_S1_Color_16bpp(void)
4902          {
4903   1          /*
4904   1          S1 Color Depth
4905   1          000 : 256 Color
4906   1          001 : 64k Color
4907   1          010 : 16M Color
4908   1          011 : Constant Color
4909   1          100 : 8 bit pixel alpha blending
4910   1          101 : 16 bit pixel alpha blending
4911   1          110 : 32bit ARGB mode
4912   1          */
4913   1          unsigned char temp;
4914   1          LCD_CmdWrite(0x92);
4915   1          temp = LCD_DataRead();
4916   1          temp &= cClrb4;
4917   1          temp &= cClrb3;
4918   1          temp |= cSetb2;
4919   1          LCD_DataWrite(temp);
4920   1      }
4921          //[92h]=========================================================================
4922          void BTE_S1_Color_24bpp(void)
4923          {
4924   1          /*
4925   1          S1 Color Depth
4926   1          000 : 256 Color
4927   1          001 : 64k Color
4928   1          010 : 16M Color
4929   1          011 : Constant Color
4930   1          100 : 8 bit pixel alpha blending
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 81  

4931   1          101 : 16 bit pixel alpha blending
4932   1          110 : 32bit ARGB mode
4933   1          */
4934   1          unsigned char temp;
4935   1          LCD_CmdWrite(0x92);
4936   1          temp = LCD_DataRead();
4937   1          temp &= cClrb4;
4938   1          temp |= cSetb3;
4939   1          temp &= cClrb2;
4940   1          LCD_DataWrite(temp);
4941   1      }
4942          
4943          //[92h]=========================================================================
4944          void BTE_S1_Color_Constant(void)
4945          {
4946   1          /*
4947   1          S1 Color Depth
4948   1          000 : 256 Color
4949   1          001 : 64k Color
4950   1          010 : 16M Color
4951   1          011 : Constant Color
4952   1          100 : 8 bit pixel alpha blending
4953   1          101 : 16 bit pixel alpha blending
4954   1          110 : 32bit ARGB mode
4955   1          */
4956   1          unsigned char temp;
4957   1          LCD_CmdWrite(0x92);
4958   1          temp = LCD_DataRead();
4959   1          temp &= cClrb4;
4960   1          temp |= cSetb3;
4961   1          temp |= cSetb2;
4962   1          LCD_DataWrite(temp);
4963   1      }
4964          
4965          //[92h]=========================================================================
4966          void BTE_S1_Color_8bit_Alpha(void)
4967          {
4968   1          /*
4969   1          S1 Color Depth
4970   1          000 : 256 Color
4971   1          001 : 64k Color
4972   1          010 : 16M Color
4973   1          011 : Constant Color
4974   1          100 : 8 bit pixel alpha blending
4975   1          101 : 16 bit pixel alpha blending
4976   1          110 : 32bit ARGB mode
4977   1          */
4978   1          unsigned char temp;
4979   1          LCD_CmdWrite(0x92);
4980   1          temp = LCD_DataRead();
4981   1          temp |= cSetb4;
4982   1          temp &= cClrb3;
4983   1          temp &= cClrb2;
4984   1          LCD_DataWrite(temp);
4985   1      }
4986          
4987          //[92h]=========================================================================
4988          void BTE_S1_Color_16bit_Alpha(void)
4989          {
4990   1          /*
4991   1          S1 Color Depth
4992   1          000 : 256 Color
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 82  

4993   1          001 : 64k Color
4994   1          010 : 16M Color
4995   1          011 : Constant Color
4996   1          100 : 8 bit pixel alpha blending
4997   1          101 : 16 bit pixel alpha blending
4998   1          110 : 32bit ARGB mode
4999   1          */
5000   1          unsigned char temp;
5001   1          LCD_CmdWrite(0x92);
5002   1          temp = LCD_DataRead();
5003   1          temp |= cSetb4;
5004   1          temp &= cClrb3;
5005   1          temp |= cSetb2;
5006   1          LCD_DataWrite(temp);
5007   1      }
5008          //[92h]=========================================================================
5009          void BTE_S1_Color_32bit_Alpha(void)
5010          {
5011   1          /*
5012   1          S1 Color Depth
5013   1          000 : 256 Color
5014   1          001 : 64k Color
5015   1          010 : 16M Color
5016   1          011 : Constant Color
5017   1          100 : 8 bit pixel alpha blending
5018   1          101 : 16 bit pixel alpha blending
5019   1          110 : 32bit ARGB mode
5020   1          */
5021   1          unsigned char temp;
5022   1          LCD_CmdWrite(0x92);
5023   1          temp = LCD_DataRead();
5024   1          temp |= cSetb4;
5025   1          temp |= cSetb3;
5026   1          temp &= cClrb2;
5027   1      
5028   1          LCD_DataWrite(temp);
5029   1      }
5030          
5031          //[92h]=========================================================================
5032          void BTE_Destination_Color_8bpp(void)
5033          {
5034   1          /*
5035   1          Destination Color Depth
5036   1          00 : 256 Color
5037   1          01 : 64k Color
5038   1          1x : 16M Color
5039   1          */
5040   1          unsigned char temp;
5041   1          LCD_CmdWrite(0x92);
5042   1          temp = LCD_DataRead();
5043   1          temp &= cClrb1;
5044   1          temp &= cClrb0;
5045   1          LCD_DataWrite(temp);
5046   1      }
5047          //[92h]=========================================================================
5048          void BTE_Destination_Color_16bpp(void)
5049          {
5050   1          /*
5051   1          Destination Color Depth
5052   1          00 : 256 Color
5053   1          01 : 64k Color
5054   1          1x : 16M Color
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 83  

5055   1          */
5056   1          unsigned char temp;
5057   1          LCD_CmdWrite(0x92);
5058   1          temp = LCD_DataRead();
5059   1          temp &= cClrb1;
5060   1          temp |= cSetb0;
5061   1          LCD_DataWrite(temp);
5062   1      }
5063          //[92h]=========================================================================
5064          void BTE_Destination_Color_24bpp(void)
5065          {
5066   1          /*
5067   1          Destination Color Depth
5068   1          00 : 256 Color
5069   1          10 : 64k Color
5070   1          1x : 16M Color
5071   1          */
5072   1          unsigned char temp;
5073   1          LCD_CmdWrite(0x92);
5074   1          temp = LCD_DataRead();
5075   1          temp |= cSetb1;
5076   1          // temp |= cSetb0 ;
5077   1          LCD_DataWrite(temp);
5078   1      }
5079          
5080          //[93h][94h][95h][96h]=========================================================================
5081          void BTE_S0_Memory_Start_Address(unsigned long Addr)
5082          {
5083   1          /*
5084   1          [93h] BTE S0 Memory Start Address [7:0]
5085   1          [94h] BTE S0 Memory Start Address [15:8]
5086   1          [95h] BTE S0 Memory Start Address [23:16]
5087   1          [96h] BTE S0 Memory Start Address [31:24]
5088   1          Bit [1:0] tie to “0” internally.
5089   1          */
5090   1          LCD_RegisterWrite(0x93, Addr);
5091   1          LCD_RegisterWrite(0x94, Addr >> 8);
5092   1          LCD_RegisterWrite(0x95, Addr >> 16);
5093   1          LCD_RegisterWrite(0x96, Addr >> 24);
5094   1      }
5095          
5096          //[97h][98h]=========================================================================
5097          void BTE_S0_Image_Width(unsigned short WX)
5098          {
5099   1          /*
5100   1          [97h] BTE S0 Image Width [7:0]
5101   1          [98h] BTE S0 Image Width [12:8]
5102   1          Unit: Pixel.
5103   1          Bit [1:0] tie to “0” internally.
5104   1          */
5105   1          LCD_RegisterWrite(0x97, WX);
5106   1          LCD_RegisterWrite(0x98, WX >> 8);
5107   1      }
5108          
5109          //[99h][9Ah][9Bh][9Ch]=========================================================================
5110          void BTE_S0_Window_Start_XY(unsigned short WX, unsigned short HY)
5111          {
5112   1          /*
5113   1          [99h] BTE S0 Window Upper-Left corner X-coordinate [7:0]
5114   1          [9Ah] BTE S0 Window Upper-Left corner X-coordinate [12:8]
5115   1          [9Bh] BTE S0 Window Upper-Left corner Y-coordinate [7:0]
5116   1          [9Ch] BTE S0 Window Upper-Left corner Y-coordinate [12:8]
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 84  

5117   1          */
5118   1      
5119   1          LCD_RegisterWrite(0x99, WX);
5120   1          LCD_RegisterWrite(0x9A, WX >> 8);
5121   1      
5122   1          LCD_RegisterWrite(0x9B, HY);
5123   1          LCD_RegisterWrite(0x9C, HY >> 8);
5124   1      }
5125          
5126          //[9Dh][9Eh][9Fh][A0h]=========================================================================
5127          void BTE_S1_Memory_Start_Address(unsigned long Addr)
5128          {
5129   1          /*
5130   1          [9Dh] BTE S1 Memory Start Address [7:0]
5131   1          [9Eh] BTE S1 Memory Start Address [15:8]
5132   1          [9Fh] BTE S1 Memory Start Address [23:16]
5133   1          [A0h] BTE S1 Memory Start Address [31:24]
5134   1          Bit [1:0] tie to “0” internally.
5135   1          */
5136   1          LCD_RegisterWrite(0x9D, Addr);
5137   1          LCD_RegisterWrite(0x9E, Addr >> 8);
5138   1          LCD_RegisterWrite(0x9F, Addr >> 16);
5139   1          LCD_RegisterWrite(0xA0, Addr >> 24);
5140   1      }
5141          
5142          // Input data format:R3G3B2
5143          void S1_Constant_color_256(unsigned char temp)
5144          {
5145   1          LCD_CmdWrite(0x9D);
5146   1          LCD_DataWrite(temp);
5147   1      
5148   1          LCD_CmdWrite(0x9E);
5149   1          LCD_DataWrite(temp << 3);
5150   1      
5151   1          LCD_CmdWrite(0x9F);
5152   1          LCD_DataWrite(temp << 6);
5153   1      }
5154          
5155          // Input data format:R5G6B6
5156          void S1_Constant_color_65k(unsigned short temp)
5157          {
5158   1          LCD_CmdWrite(0x9D);
5159   1          LCD_DataWrite(temp >> 8);
5160   1      
5161   1          LCD_CmdWrite(0x9E);
5162   1          LCD_DataWrite(temp >> 3);
5163   1      
5164   1          LCD_CmdWrite(0x9F);
5165   1          LCD_DataWrite(temp << 3);
5166   1      }
5167          
5168          // Input data format:R8G8B8
5169          void S1_Constant_color_16M(unsigned long temp)
5170          {
5171   1          LCD_CmdWrite(0x9D);
5172   1          LCD_DataWrite(temp >> 16);
5173   1      
5174   1          LCD_CmdWrite(0x9E);
5175   1          LCD_DataWrite(temp >> 8);
5176   1      
5177   1          LCD_CmdWrite(0x9F);
5178   1          LCD_DataWrite(temp);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 85  

5179   1      }
5180          
5181          //[A1h][A2h]=========================================================================
5182          void BTE_S1_Image_Width(unsigned short WX)
5183          {
5184   1          /*
5185   1          [A1h] BTE S1 Image Width [7:0]
5186   1          [A2h] BTE S1 Image Width [12:8]
5187   1          Unit: Pixel.
5188   1          Bit [1:0] tie to “0” internally.
5189   1          */
5190   1          LCD_RegisterWrite(0xA1, WX);
5191   1          LCD_RegisterWrite(0xA2, WX >> 8);
5192   1      }
5193          
5194          //[A3h][A4h][A5h][A6h]=========================================================================
5195          void BTE_S1_Window_Start_XY(unsigned short WX, unsigned short HY)
5196          {
5197   1          /*
5198   1          [A3h] BTE S1 Window Upper-Left corner X-coordinate [7:0]
5199   1          [A4h] BTE S1 Window Upper-Left corner X-coordinate [12:8]
5200   1          [A5h] BTE S1 Window Upper-Left corner Y-coordinate [7:0]
5201   1          [A6h] BTE S1 Window Upper-Left corner Y-coordinate [12:8]
5202   1          */
5203   1      
5204   1          LCD_RegisterWrite(0xA3, WX);
5205   1          LCD_RegisterWrite(0xA4, WX >> 8);
5206   1      
5207   1          LCD_RegisterWrite(0xA5, HY);
5208   1          LCD_RegisterWrite(0xA6, HY >> 8);
5209   1      }
5210          
5211          //[A7h][A8h][A9h][AAh]=========================================================================
5212          void BTE_Destination_Memory_Start_Address(unsigned long Addr)
5213          {
5214   1          /*
5215   1          [A7h] BTE Destination Memory Start Address [7:0]
5216   1          [A8h] BTE Destination Memory Start Address [15:8]
5217   1          [A9h] BTE Destination Memory Start Address [23:16]
5218   1          [AAh] BTE Destination Memory Start Address [31:24]
5219   1          Bit [1:0] tie to “0” internally.
5220   1          */
5221   1          LCD_RegisterWrite(0xA7, Addr);
5222   1          LCD_RegisterWrite(0xA8, Addr >> 8);
5223   1          LCD_RegisterWrite(0xA9, Addr >> 16);
5224   1          LCD_RegisterWrite(0xAA, Addr >> 24);
5225   1      }
5226          
5227          //[ABh][ACh]=========================================================================
5228          void BTE_Destination_Image_Width(unsigned short WX)
5229          {
5230   1          /*
5231   1          [ABh] BTE Destination Image Width [7:0]
5232   1          [ACh] BTE Destination Image Width [12:8]
5233   1          Unit: Pixel.
5234   1          Bit [1:0] tie to “0” internally.
5235   1          */
5236   1          LCD_RegisterWrite(0xAB, WX);
5237   1          LCD_RegisterWrite(0xAC, WX >> 8);
5238   1      }
5239          
5240          //[ADh][AEh][AFh][B0h]=========================================================================
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 86  

5241          void BTE_Destination_Window_Start_XY(unsigned short WX, unsigned short HY)
5242          {
5243   1          /*
5244   1          [ADh] BTE Destination Window Upper-Left corner X-coordinate [7:0]
5245   1          [AEh] BTE Destination Window Upper-Left corner X-coordinate [12:8]
5246   1          [AFh] BTE Destination Window Upper-Left corner Y-coordinate [7:0]
5247   1          [B0h] BTE Destination Window Upper-Left corner Y-coordinate [12:8]
5248   1          */
5249   1      
5250   1          LCD_RegisterWrite(0xAD, WX);
5251   1          LCD_RegisterWrite(0xAE, WX >> 8);
5252   1      
5253   1          LCD_RegisterWrite(0xAF, HY);
5254   1          LCD_RegisterWrite(0xB0, HY >> 8);
5255   1      }
5256          
5257          //[B1h][B2h][B3h][B4h]===============================================================
5258          
5259          void BTE_Window_Size(unsigned short WX, unsigned short HY)
5260          
5261          {
5262   1          /*
5263   1          [B1h] BTE Window Width [7:0]
5264   1          [B2h] BTE Window Width [12:8]
5265   1      
5266   1          [B3h] BTE Window Height [7:0]
5267   1          [B4h] BTE Window Height [12:8]
5268   1          */
5269   1          LCD_RegisterWrite(0xB1, WX);
5270   1          LCD_RegisterWrite(0xB2, WX >> 8);
5271   1      
5272   1          LCD_RegisterWrite(0xB3, HY);
5273   1          LCD_RegisterWrite(0xB4, HY >> 8);
5274   1      }
5275          
5276          //[B5h]=========================================================================
5277          void BTE_Alpha_Blending_Effect(unsigned char temp)
5278          {
5279   1          /*
5280   1          Window Alpha Blending effect for S0 & S1
5281   1          The value of alpha in the color code ranges from 0.0 to 1.0,
5282   1          where 0.0 represents a fully transparent color, and 1.0
5283   1          represents a fully opaque color.
5284   1          00h: 0
5285   1          01h: 1/32
5286   1          02h: 2/32
5287   1          :
5288   1          1Eh: 30/32
5289   1          1Fh: 31/32
5290   1          2Xh: 1
5291   1          Output Effect = (S0 image x (1 - alpha setting value)) + (S1 image x alpha setting value)
5292   1          */
5293   1          LCD_CmdWrite(0xB5);
5294   1          LCD_DataWrite(temp);
5295   1      }
5296          
5297          //[B6h]=========================================================================
5298          
5299          void Select_SFI_Quad_Mode_Dummy_8T_6Bh(void) //
5300          {
5301   1          /*[B6h]bit7-6=
5302   1          00b: [B7h] B3-0
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 87  

5303   1          01b: 4x read command code C 6Bh.
5304   1          10b: 4x read command code C EBh.
5305   1          11b:NA
5306   1          */
5307   1          unsigned char temp;
5308   1          LCD_CmdWrite(0xB6);
5309   1          temp = LCD_DataRead();
5310   1          temp &= 0x3F;
5311   1          temp |= 0x40;
5312   1          LCD_DataWrite(temp);
5313   1      }
5314          void Select_SFI_Quad_Mode_Dummy_4T_EBh(void) //
5315          {
5316   1          /*[B6h]bit7-6=
5317   1          00b: [B7h] B3-0
5318   1          01b: 4x read command code C 6Bh.
5319   1          10b: 4x read command code C EBh.
5320   1          11b:NA
5321   1          */
5322   1          unsigned char temp;
5323   1          LCD_CmdWrite(0xB6);
5324   1          temp = LCD_DataRead();
5325   1          temp &= 0x3F;
5326   1          temp |= 0x80;
5327   1          LCD_DataWrite(temp);
5328   1      }
5329          
5330          void Start_SFI_DMA(void)
5331          {
5332   1          /*[bit0]
5333   1          Write Function: DMA Start Bit
5334   1          Set to 1 by MPU and reset to 0 automatically
5335   1          It cannot start with fontwr_busy as 1. And if DMA enabled also
5336   1          cannot set as text mode & send character code.
5337   1          */
5338   1          unsigned char temp;
5339   1          LCD_CmdWrite(0xB6);
5340   1          temp = LCD_DataRead();
5341   1          temp |= cSetb0;
5342   1          LCD_DataWrite(temp);
5343   1      }
5344          
5345          void Check_Busy_SFI_DMA(void)
5346          {
5347   1          /*[bit0]
5348   1          Read Function: DMA Busy Check Bit
5349   1          0: Idle
5350   1          1: Busy
5351   1          */
5352   1          unsigned char temp;
5353   1      
5354   1          // case1:  using DMA Function Control Register
5355   1          LCD_CmdWrite(0xB6);
5356   1          do {
5357   2              temp = LCD_DataRead();
5358   2          } while (temp & 0x01);
5359   1      }
5360          
5361          //[B7h]=========================================================================
5362          
5363          void Select_SFI_Font_Mode(void)
5364          {
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 88  

5365   1          /*[bit6]
5366   1          Serial Flash /ROM Access Mode
5367   1          0: Font mode C for external cgrom
5368   1          1: DMA mode C for cgram , pattern , bootstart image or osd
5369   1          */
5370   1          unsigned char temp;
5371   1          LCD_CmdWrite(0xB7);
5372   1          temp = LCD_DataRead();
5373   1          temp &= cClrb6;
5374   1          LCD_DataWrite(temp);
5375   1      }
5376          void Select_SFI_DMA_Mode(void)
5377          {
5378   1          /*[bit6]
5379   1          Serial Flash /ROM Access Mode
5380   1          0: Font mode C for external cgrom
5381   1          1: DMA mode C for cgram , pattern , bootstart image or osd
5382   1          */
5383   1          unsigned char temp;
5384   1          LCD_CmdWrite(0xB7);
5385   1          temp = LCD_DataRead();
5386   1          temp |= cSetb6;
5387   1          LCD_DataWrite(temp);
5388   1      }
5389          void Select_SFI_24bit_Address(void)
5390          {
5391   1          /*[bit5]
5392   1          Serial Flash/ROM Address Mode
5393   1          0: 24 bits address mode
5394   1          1: 32 bits address mode
5395   1          */
5396   1          unsigned char temp;
5397   1          LCD_CmdWrite(0xB7);
5398   1          temp = LCD_DataRead();
5399   1          temp &= cClrb5;
5400   1          LCD_DataWrite(temp);
5401   1      }
5402          void Select_SFI_32bit_Address(void)
5403          {
5404   1          /*[bit5]
5405   1          Serial Flash/ROM Address Mode
5406   1          0: 24 bits address mode
5407   1          1: 32 bits address mode
5408   1          */
5409   1          unsigned char temp;
5410   1          LCD_CmdWrite(0xB7);
5411   1          temp = LCD_DataRead();
5412   1          temp |= cSetb5;
5413   1          LCD_DataWrite(temp);
5414   1      }
5415          void Select_standard_SPI_Mode0_or_Mode3(void)
5416          {
5417   1          /*[bit4]
5418   1          RA8875 compatible mode
5419   1          0: standard SPI mode 0 or mode 3 timing
5420   1          1: Follow RA8875 mode 0 & mode 3 timing
5421   1          */
5422   1          unsigned char temp;
5423   1          LCD_CmdWrite(0xB7);
5424   1          temp = LCD_DataRead();
5425   1          temp &= cClrb4;
5426   1          LCD_DataWrite(temp);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 89  

5427   1      }
5428          void Select_RA8875_SPI_Mode0_and_Mode3(void)
5429          {
5430   1          /*[bit4]
5431   1          RA8875 compatible mode
5432   1          0: standard SPI mode 0 or mode 3 timing
5433   1          1: Follow RA8875 mode 0 & mode 3 timing
5434   1          */
5435   1          unsigned char temp;
5436   1          LCD_CmdWrite(0xB7);
5437   1          temp = LCD_DataRead();
5438   1          temp |= cSetb4;
5439   1          LCD_DataWrite(temp);
5440   1      }
5441          
5442          void Select_SFI_Single_Mode_Dummy_0T_03h(void)
5443          {
5444   1          /*
5445   1          (1) [B6h]bit7-6=0x00
5446   1          (2) [B7h]bit3-0=
5447   1          000xb: 1x read command code = 03h. Without dummy cycle between address and data.
5448   1          010xb: 1x read command code = 0Bh. 8 dummy cycles inserted between address and data.
5449   1          1x0xb: 1x read command code = 1Bh. 16 dummy cycles inserted between address and data.
5450   1          */
5451   1          unsigned char temp;
5452   1      
5453   1          LCD_CmdWrite(0xB6);
5454   1          temp = LCD_DataRead();
5455   1          temp &= 0x3F;
5456   1          LCD_DataWrite(temp);
5457   1      
5458   1          LCD_CmdWrite(0xB7);
5459   1          temp = LCD_DataRead();
5460   1          temp &= 0xF0;
5461   1          LCD_DataWrite(temp);
5462   1      }
5463          void Select_SFI_Single_Mode_Dummy_8T_0Bh(void)
5464          {
5465   1          /*
5466   1          (1) [B6h]bit7-6=0x00
5467   1          (2) [B7h]bit3-0=
5468   1          000xb: 1x read command code = 03h. Without dummy cycle between address and data.
5469   1          010xb: 1x read command code = 0Bh. 8 dummy cycles inserted between address and data.
5470   1          1x0xb: 1x read command code = 1Bh. 16 dummy cycles inserted between address and data.
5471   1          */
5472   1          unsigned char temp;
5473   1      
5474   1          LCD_CmdWrite(0xB6);
5475   1          temp = LCD_DataRead();
5476   1          temp &= 0x3F;
5477   1          LCD_DataWrite(temp);
5478   1      
5479   1          LCD_CmdWrite(0xB7);
5480   1          temp = LCD_DataRead();
5481   1          temp &= 0xF0;
5482   1          temp |= cSetb2;
5483   1          LCD_DataWrite(temp);
5484   1      }
5485          void Select_SFI_Single_Mode_Dummy_16T_1Bh(void)
5486          {
5487   1          /*
5488   1          (1) [B6h]bit7-6=0x00
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 90  

5489   1          (2) [B7h]bit3-0=
5490   1          000xb: 1x read command code = 03h. Without dummy cycle between address and data.
5491   1          010xb: 1x read command code = 0Bh. 8 dummy cycles inserted between address and data.
5492   1          1x0xb: 1x read command code = 1Bh. 16 dummy cycles inserted between address and data.
5493   1          */
5494   1          unsigned char temp;
5495   1      
5496   1          LCD_CmdWrite(0xB6);
5497   1          temp = LCD_DataRead();
5498   1          temp &= 0x3F;
5499   1          LCD_DataWrite(temp);
5500   1      
5501   1          LCD_CmdWrite(0xB7);
5502   1          temp = LCD_DataRead();
5503   1          temp &= 0xF0;
5504   1          temp |= cSetb3;
5505   1          LCD_DataWrite(temp);
5506   1      }
5507          void Select_SFI_Dual_Mode_Dummy_8T_3Bh(void)
5508          {
5509   1          /*
5510   1          (1) [B6h]bit7-6=0x00
5511   1          (2) [B7h]bit3-0=
5512   1          xx10b: 2x read command code = 3Bh. 8 dummy cycles inserted between address and data phase. (mode 0)
5513   1          xx11b: 2x read command code = BBh. 4 dummy cycles inserted between address and data phase. (mode 1)
5514   1          */
5515   1          unsigned char temp;
5516   1      
5517   1          LCD_CmdWrite(0xB6);
5518   1          temp = LCD_DataRead();
5519   1          temp &= 0x3F;
5520   1          LCD_DataWrite(temp);
5521   1      
5522   1          LCD_CmdWrite(0xB7);
5523   1          temp = LCD_DataRead();
5524   1          temp &= 0xF0;
5525   1          temp |= 0x02;
5526   1          LCD_DataWrite(temp);
5527   1      }
5528          void Select_SFI_Dual_Mode_Dummy_4T_BBh(void)
5529          {
5530   1          /*
5531   1          (1) [B6h]bit7-6=0x00
5532   1          (2) [B7h]bit3-0=
5533   1          xx10b: 2x read command code = 3Bh. 8 dummy cycles inserted between address and data phase. (mode 0)
5534   1          xx11b: 2x read command code = BBh. 4 dummy cycles inserted between address and data phase. (mode 1)
5535   1          */
5536   1          unsigned char temp;
5537   1      
5538   1          LCD_CmdWrite(0xB6);
5539   1          temp = LCD_DataRead();
5540   1          temp &= 0x3F;
5541   1          LCD_DataWrite(temp);
5542   1      
5543   1          LCD_CmdWrite(0xB7);
5544   1          temp = LCD_DataRead();
5545   1          temp &= 0xF0;
5546   1          temp |= 0x03;
5547   1          LCD_DataWrite(temp);
5548   1      }
5549          
5550          //[B8h]=========================================================================
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 91  

5551          // REG[B8h] SPI master Tx /Rx FIFO Data Register (SPIDR)
5552          unsigned char SPI_Master_FIFO_Data_Put(unsigned char Data)
5553          {
5554   1          unsigned char temp;
5555   1          LCD_CmdWrite(0xB8);
5556   1          LCD_DataWrite(Data);
5557   1          do {
5558   2              temp = Tx_FIFO_Empty_Flag();
5559   2          } while (temp == 0);
5560   1          //  while(Tx_FIFO_Empty_Flag()==0); //空了再绦邢乱还P
5561   1          temp = SPI_Master_FIFO_Data_Get();
5562   1      
5563   1          return temp;
5564   1      }
5565          
5566          unsigned char SPI_Master_FIFO_Data_Get(void)
5567          {
5568   1          unsigned char temp;
5569   1      
5570   1          while (Rx_FIFO_Empty_Flag() == 1)
5571   1              ; // 不是空的往下绦
5572   1          LCD_CmdWrite(0xB8);
5573   1          temp = LCD_DataRead();
5574   1          // while(Rx_FIFO_full_flag()); //Bm入16PY料才需要
5575   1          return temp;
5576   1      }
5577          
5578          //[B9h]=========================================================================
5579          // REG[B9h] SPI master Control Register (SPIMCR2)
5580          
5581          void Enable_SPI_Master_Interrupt(void)
5582          {
5583   1          /*
5584   1          SPI Master Interrupt enable
5585   1          0: Disable interrupt.
5586   1          1: Enable interrupt.
5587   1          */
5588   1          unsigned char temp;
5589   1          LCD_CmdWrite(0xB9);
5590   1          temp = LCD_DataRead();
5591   1          temp |= cSetb6;
5592   1          LCD_DataWrite(temp);
5593   1      }
5594          void Disable_SPI_Master_Interrupt(void)
5595          {
5596   1          /*
5597   1          SPI Master Interrupt enable
5598   1          0: Disable interrupt.
5599   1          1: Enable interrupt.
5600   1          */
5601   1          unsigned char temp;
5602   1          LCD_CmdWrite(0xB9);
5603   1          temp = LCD_DataRead();
5604   1          temp &= cClrb6;
5605   1          LCD_DataWrite(temp);
5606   1      }
5607          
5608          // 0: inactive (nSS port will goes high)
5609          void nSS_Inactive(void)
5610          {
5611   1          unsigned char temp;
5612   1          LCD_CmdWrite(0xB9);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 92  

5613   1          temp = LCD_DataRead();
5614   1          temp &= cClrb4;
5615   1          LCD_DataWrite(temp);
5616   1      }
5617          // 1: active (nSS port will goes low)
5618          void nSS_Active(void)
5619          {
5620   1          unsigned char temp;
5621   1          LCD_CmdWrite(0xB9);
5622   1          temp = LCD_DataRead();
5623   1          temp |= cSetb4;
5624   1          LCD_DataWrite(temp);
5625   1      }
5626          
5627          void Mask_FIFO_overflow_error_Interrupt(void)
5628          {
5629   1          /*
5630   1          Mask interrupt for FIFO overflow error [OVFIRQEN]
5631   1          0: unmask
5632   1          1: mask
5633   1          */
5634   1          unsigned char temp;
5635   1          LCD_CmdWrite(0xB9);
5636   1          temp = LCD_DataRead();
5637   1          temp |= cSetb3;
5638   1          LCD_DataWrite(temp);
5639   1      }
5640          void Unmask_FIFO_overflow_error_Interrupt(void)
5641          {
5642   1          /*
5643   1          Mask interrupt for FIFO overflow error [OVFIRQEN]
5644   1          0: unmask
5645   1          1: mask
5646   1          */
5647   1          unsigned char temp;
5648   1          LCD_CmdWrite(0xB9);
5649   1          temp = LCD_DataRead();
5650   1          temp &= cClrb3;
5651   1          LCD_DataWrite(temp);
5652   1      }
5653          
5654          void Mask_EMTIRQEN_Interrupt(void)
5655          {
5656   1          /*
5657   1          Mask interrupt for while Tx FIFO empty & SPI engine/FSM idle [EMTIRQEN]
5658   1          0: unmask
5659   1          1: mask
5660   1          */
5661   1          unsigned char temp;
5662   1          LCD_CmdWrite(0xB9);
5663   1          temp = LCD_DataRead();
5664   1          temp |= cSetb2;
5665   1          LCD_DataWrite(temp);
5666   1      }
5667          void Unmask_EMTIRQEN_Interrupt(void)
5668          {
5669   1          /*
5670   1          Mask interrupt for while Tx FIFO empty & SPI engine/FSM idle [EMTIRQEN]
5671   1          0: unmask
5672   1          1: mask
5673   1          */
5674   1          unsigned char temp;
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 93  

5675   1          LCD_CmdWrite(0xB9);
5676   1          temp = LCD_DataRead();
5677   1          temp &= cClrb2;
5678   1          LCD_DataWrite(temp);
5679   1      }
5680          
5681          /*
5682          SPI operation mode
5683          Only support mode 0 & mode 3, when enable serial flash’s DMA
5684          or access Getop’s character serial ROM device.
5685          mode / CPOL:Clock Polarity bit / CPHA:Clock Phase bit
5686              0 0 0
5687              1 0 1
5688              2 1 0
5689              3 1 1
5690          */
5691          void Reset_CPOL(void)
5692          {
5693   1          unsigned char temp;
5694   1          LCD_CmdWrite(0xB9);
5695   1          temp = LCD_DataRead();
5696   1          temp &= cClrb1;
5697   1          LCD_DataWrite(temp);
5698   1      }
5699          
5700          void Set_CPOL(void)
5701          {
5702   1          unsigned char temp;
5703   1          LCD_CmdWrite(0xB9);
5704   1          temp = LCD_DataRead();
5705   1          temp |= cSetb1;
5706   1          LCD_DataWrite(temp);
5707   1      }
5708          
5709          void Reset_CPHA(void)
5710          {
5711   1          unsigned char temp;
5712   1          LCD_CmdWrite(0xB9);
5713   1          temp = LCD_DataRead();
5714   1          temp &= cClrb0;
5715   1          LCD_DataWrite(temp);
5716   1      }
5717          
5718          void Set_CPHA(void)
5719          {
5720   1          unsigned char temp;
5721   1          LCD_CmdWrite(0xB9);
5722   1          temp = LCD_DataRead();
5723   1          temp |= cSetb0;
5724   1          LCD_DataWrite(temp);
5725   1      }
5726          
5727          // REG[BAh] SPI master Status Register (SPIMSR)
5728          unsigned char Tx_FIFO_Empty_Flag(void)
5729          {
5730   1          LCD_CmdWrite(0xBA);
5731   1          if ((LCD_DataRead() & 0x80) == 0x80)
5732   1              return 1;
5733   1          else
5734   1              return 0;
5735   1      }
5736          
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 94  

5737          unsigned char Tx_FIFO_Full_Flag(void)
5738          {
5739   1          LCD_CmdWrite(0xBA);
5740   1          if ((LCD_DataRead() & 0x40) == 0x40)
5741   1              return 1;
5742   1          else
5743   1              return 0;
5744   1      }
5745          
5746          unsigned char Rx_FIFO_Empty_Flag(void)
5747          {
5748   1          LCD_CmdWrite(0xBA);
5749   1          if ((LCD_DataRead() & 0x20) == 0x20)
5750   1              return 1;
5751   1          else
5752   1              return 0;
5753   1      }
5754          
5755          unsigned char Rx_FIFO_full_flag(void)
5756          {
5757   1          LCD_CmdWrite(0xBA);
5758   1          if ((LCD_DataRead() & 0x10) == 0x10)
5759   1              return 1;
5760   1          else
5761   1              return 0;
5762   1      }
5763          
5764          unsigned char OVFI_Flag(void)
5765          {
5766   1          LCD_CmdWrite(0xBA);
5767   1          if ((LCD_DataRead() & 0x08) == 0x08)
5768   1              return 1;
5769   1          else
5770   1              return 0;
5771   1      }
5772          
5773          void Clear_OVFI_Flag(void)
5774          {
5775   1          unsigned char temp;
5776   1          LCD_CmdWrite(0xBA);
5777   1          temp = LCD_DataRead();
5778   1          temp |= cSetb3;
5779   1          LCD_DataWrite(temp);
5780   1      }
5781          
5782          unsigned char EMTI_Flag(void)
5783          {
5784   1          LCD_CmdWrite(0xBA);
5785   1          if ((LCD_DataRead() & 0x04) == 0x04)
5786   1              return 1;
5787   1          else
5788   1              return 0;
5789   1      }
5790          
5791          void Clear_EMTI_Flag(void)
5792          {
5793   1          unsigned char temp;
5794   1          LCD_CmdWrite(0xBA);
5795   1          temp = LCD_DataRead();
5796   1          temp |= cSetb2;
5797   1          LCD_DataWrite(temp);
5798   1      }
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 95  

5799          
5800          // REG[BB] SPI Clock period (SPIDIV)
5801          void SPI_Clock_Period(unsigned char temp)
5802          {
5803   1          /*
5804   1          SPI_clock= CORE_FREQ / ((Divisor+1)x2)
5805   1          */
5806   1          LCD_CmdWrite(0xBB);
5807   1          LCD_DataWrite(temp);
5808   1      }
5809          
5810          //[BCh][BDh][BEh][BFh]=========================================================================
5811          void SFI_DMA_Source_Start_Address(unsigned long Addr)
5812          {
5813   1          /*
5814   1          DMA Source START ADDRESS
5815   1          This bits index serial flash address [7:0][15:8][23:16][31:24]
5816   1          */
5817   1          LCD_CmdWrite(0xBC);
5818   1          LCD_DataWrite(Addr);
5819   1          LCD_CmdWrite(0xBD);
5820   1          LCD_DataWrite(Addr >> 8);
5821   1          LCD_CmdWrite(0xBE);
5822   1          LCD_DataWrite(Addr >> 16);
5823   1          LCD_CmdWrite(0xBF);
5824   1          LCD_DataWrite(Addr >> 24);
5825   1      }
5826          //[C0h][C1h][C2h][C3h]=========================================================================
5827          void SFI_DMA_Destination_Start_Address(unsigned long Addr)
5828          {
5829   1          /*
5830   1          DMA Destination START ADDRESS
5831   1          [1:0]Fix at 0
5832   1          This bits index SDRAM address [7:0][15:8][23:16][31:24]
5833   1          */
5834   1          LCD_CmdWrite(0xC0);
5835   1          LCD_DataWrite(Addr);
5836   1          LCD_CmdWrite(0xC1);
5837   1          LCD_DataWrite(Addr >> 8);
5838   1          LCD_CmdWrite(0xC2);
5839   1          LCD_DataWrite(Addr >> 16);
5840   1          LCD_CmdWrite(0xC3);
5841   1          LCD_DataWrite(Addr >> 24);
5842   1      }
5843          //[C0h][C1h][C2h][C3h]=========================================================================
5844          void SFI_DMA_Destination_Upper_Left_Corner(unsigned short WX, unsigned short HY)
5845          {
5846   1          /*
5847   1          C0h
5848   1          This register defines DMA Destination Window Upper-Left corner
5849   1          X-coordinate [7:0] on Canvas area.
5850   1          When REG DMACR bit 1 = 1 (Block Mode)
5851   1          This register defines Destination address [7:2] in SDRAM.
5852   1          C1h
5853   1          When REG DMACR bit 1 = 0 (Linear Mode)
5854   1          This register defines DMA Destination Window Upper-Left corner
5855   1          X-coordinate [12:8] on Canvas area.
5856   1          When REG DMACR bit 1 = 1 (Block Mode)
5857   1          This register defines Destination address [15:8] in SDRAM.
5858   1          C2h
5859   1          When REG DMACR bit 1 = 0 (Linear Mode)
5860   1          This register defines DMA Destination Window Upper-Left corner
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 96  

5861   1          Y-coordinate [7:0] on Canvas area.
5862   1          When REG DMACR bit 1 = 1 (Block Mode)
5863   1          This register defines Destination address [23:16] in SDRAM.
5864   1          C3h
5865   1          When REG DMACR bit 1 = 0 (Linear Mode)
5866   1          This register defines DMA Destination Window Upper-Left corner
5867   1          Y-coordinate [12:8] on Canvas area.
5868   1          When REG DMACR bit 1 = 1 (Block Mode)
5869   1          This register defines Destination address [31:24] in SDRAM.
5870   1          */
5871   1      
5872   1          LCD_CmdWrite(0xC0);
5873   1          LCD_DataWrite(WX);
5874   1          LCD_CmdWrite(0xC1);
5875   1          LCD_DataWrite(WX >> 8);
5876   1      
5877   1          LCD_CmdWrite(0xC2);
5878   1          LCD_DataWrite(HY);
5879   1          LCD_CmdWrite(0xC3);
5880   1          LCD_DataWrite(HY >> 8);
5881   1      }
5882          
5883          //[C6h][C7h][C8h][C9h]=========================================================================
5884          void SFI_DMA_Transfer_Number(unsigned long Num)
5885          {
5886   1          /*
5887   1          When REG DMACR bit 1 = 0 (Linear Mode)
5888   1          DMA Transfer Number [7:0][15:8][23:16][31:24]
5889   1      
5890   1          When REG DMACR bit 1 = 1 (Block Mode)
5891   1          DMA Block Width [7:0][15:8]
5892   1          DMA Block HIGH[7:0][15:8]
5893   1          */
5894   1          LCD_CmdWrite(0xC6);
5895   1          LCD_DataWrite(Num);
5896   1          LCD_CmdWrite(0xC7);
5897   1          LCD_DataWrite(Num >> 8);
5898   1          LCD_CmdWrite(0xC8);
5899   1          LCD_DataWrite(Num >> 16);
5900   1          LCD_CmdWrite(0xC9);
5901   1          LCD_DataWrite(Num >> 24);
5902   1      }
5903          void SFI_DMA_Transfer_Width_Height(unsigned short WX, unsigned short HY)
5904          {
5905   1          /*
5906   1          When REG DMACR bit 1 = 0 (Linear Mode)
5907   1          DMA Transfer Number [7:0][15:8][23:16][31:24]
5908   1      
5909   1          When REG DMACR bit 1 = 1 (Block Mode)
5910   1          DMA Block Width [7:0][15:8]
5911   1          DMA Block HIGH[7:0][15:8]
5912   1          */
5913   1          LCD_CmdWrite(0xC6);
5914   1          LCD_DataWrite(WX);
5915   1          LCD_CmdWrite(0xC7);
5916   1          LCD_DataWrite(WX >> 8);
5917   1      
5918   1          LCD_CmdWrite(0xC8);
5919   1          LCD_DataWrite(HY);
5920   1          LCD_CmdWrite(0xC9);
5921   1          LCD_DataWrite(HY >> 8);
5922   1      }
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 97  

5923          //[CAh][CBh]=========================================================================
5924          void SFI_DMA_Source_Width(unsigned short WX)
5925          {
5926   1          /*
5927   1          DMA Source Picture Width [7:0][12:8]
5928   1          Unit: pixel
5929   1          */
5930   1          LCD_CmdWrite(0xCA);
5931   1          LCD_DataWrite(WX);
5932   1          LCD_CmdWrite(0xCB);
5933   1          LCD_DataWrite(WX >> 8);
5934   1      }
5935          
5936          //[CCh]=========================================================================
5937          
5938          void Font_Select_UserDefine_Mode(void)
5939          {
5940   1          /*[bit7-6]
5941   1          User-defined Font /CGROM Font Selection Bit in Text Mode
5942   1          00 : Internal CGROM
5943   1          01 : Genitop serial flash
5944   1          10 : User-defined Font
5945   1          */
5946   1          unsigned char temp;
5947   1          LCD_CmdWrite(0xCC);
5948   1          temp = LCD_DataRead();
5949   1          temp |= cSetb7;
5950   1          temp &= cClrb6;
5951   1          LCD_DataWrite(temp);
5952   1      }
5953          void CGROM_Select_Internal_CGROM(void)
5954          {
5955   1          /*[bit7-6]
5956   1          User-defined Font /CGROM Font Selection Bit in Text Mode
5957   1          00 : Internal CGROM
5958   1          01 : Genitop serial flash
5959   1          10 : User-defined Font
5960   1          */
5961   1          unsigned char temp;
5962   1          LCD_CmdWrite(0xCC);
5963   1          temp = LCD_DataRead();
5964   1          temp &= cClrb7;
5965   1          temp &= cClrb6;
5966   1          LCD_DataWrite(temp);
5967   1      }
5968          void CGROM_Select_Genitop_FontROM(void)
5969          {
5970   1          /*[bit7-6]
5971   1          User-defined Font /CGROM Font Selection Bit in Text Mode
5972   1          00 : Internal CGROM
5973   1          01 : Genitop serial flash
5974   1          10 : User-defined Font
5975   1          */
5976   1          unsigned char temp;
5977   1          LCD_CmdWrite(0xCC);
5978   1          temp = LCD_DataRead();
5979   1          temp &= cClrb7;
5980   1          temp |= cSetb6;
5981   1          LCD_DataWrite(temp);
5982   1      }
5983          
5984          void Font_Select_8x16_16x16(void)
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 98  

5985          {
5986   1          //[bit5-4]
5987   1          // Font Height Setting
5988   1          // 00b : 8x16 / 16x16.
5989   1          // 01b : 12x24 / 24x24.
5990   1          // 10b : 16x32 / 32x32.
5991   1          //*** User-defined Font width is decided by font code.
5992   1          // Genitop serial flash’s font width is decided by font code or GT Font ROM control register.
5993   1      
5994   1          unsigned char temp;
5995   1          LCD_CmdWrite(0xCC);
5996   1          temp = LCD_DataRead();
5997   1          temp &= cClrb5;
5998   1          temp &= cClrb4;
5999   1          LCD_DataWrite(temp);
6000   1      } //*/
6001          void Font_Select_12x24_24x24(void)
6002          {
6003   1          /*[bit5-4]
6004   1          Font Height Setting
6005   1          00b : 8x16 / 16x16.
6006   1          01b : 12x24 / 24x24.
6007   1          10b : 16x32 / 32x32.
6008   1          *** User-defined Font width is decided by font code. Genitop
6009   1          serial flash’s font width is decided by font code or GT Font ROM
6010   1          control register.
6011   1          */
6012   1          unsigned char temp;
6013   1          LCD_CmdWrite(0xCC);
6014   1          temp = LCD_DataRead();
6015   1          temp &= cClrb5;
6016   1          temp |= cSetb4;
6017   1          LCD_DataWrite(temp);
6018   1      }
6019          void Font_Select_16x32_32x32(void)
6020          {
6021   1          //[bit5-4]
6022   1          // Font Height Setting
6023   1          // 00b : 8x16 / 16x16.
6024   1          // 01b : 12x24 / 24x24.
6025   1          // 10b : 16x32 / 32x32.
6026   1          //*** User-defined Font width is decided by font code.
6027   1          // Genitop serial flash’s font width is decided by font code or GT Font ROM control register.
6028   1      
6029   1          unsigned char temp;
6030   1          LCD_CmdWrite(0xCC);
6031   1          temp = LCD_DataRead();
6032   1          temp |= cSetb5;
6033   1          temp &= cClrb4;
6034   1          LCD_DataWrite(temp);
6035   1      } //*/
6036          
6037          void Internal_CGROM_Select_ISOIEC8859_1(void)
6038          {
6039   1          /*
6040   1          Font Selection for internal CGROM
6041   1          When FNCR0 B7 = 0 and B5 = 0, Internal CGROM supports the
6042   1          8x16 character sets with the standard coding of ISO/IEC 8859-1,2,4,5,
6043   1          which supports English and most of European country languages.
6044   1          00b : ISO/IEC 8859-1.
6045   1          01b : ISO/IEC 8859-2.
6046   1          10b : ISO/IEC 8859-4.
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 99  

6047   1          11b : ISO/IEC 8859-5.
6048   1          */
6049   1          unsigned char temp;
6050   1          LCD_CmdWrite(0xCC);
6051   1          temp = LCD_DataRead();
6052   1          temp &= cClrb1;
6053   1          temp &= cClrb0;
6054   1          LCD_DataWrite(temp);
6055   1      }
6056          void Internal_CGROM_Select_ISOIEC8859_2(void)
6057          {
6058   1          /*
6059   1          Font Selection for internal CGROM
6060   1          When FNCR0 B7 = 0 and B5 = 0, Internal CGROM supports the
6061   1          8x16 character sets with the standard coding of ISO/IEC 8859-1,2,4,5,
6062   1          which supports English and most of European country languages.
6063   1          00b : ISO/IEC 8859-1.
6064   1          01b : ISO/IEC 8859-2.
6065   1          10b : ISO/IEC 8859-4.
6066   1          11b : ISO/IEC 8859-5.
6067   1          */
6068   1          unsigned char temp;
6069   1          LCD_CmdWrite(0xCC);
6070   1          temp = LCD_DataRead();
6071   1          temp &= cClrb1;
6072   1          temp |= cSetb0;
6073   1          LCD_DataWrite(temp);
6074   1      }
6075          void Internal_CGROM_Select_ISOIEC8859_4(void)
6076          {
6077   1          /*
6078   1          Font Selection for internal CGROM
6079   1          When FNCR0 B7 = 0 and B5 = 0, Internal CGROM supports the
6080   1          8x16 character sets with the standard coding of ISO/IEC 8859-1,2,4,5,
6081   1          which supports English and most of European country languages.
6082   1          00b : ISO/IEC 8859-1.
6083   1          01b : ISO/IEC 8859-2.
6084   1          10b : ISO/IEC 8859-4.
6085   1          11b : ISO/IEC 8859-5.
6086   1          */
6087   1          unsigned char temp;
6088   1          LCD_CmdWrite(0xCC);
6089   1          temp = LCD_DataRead();
6090   1          temp |= cSetb1;
6091   1          temp &= cClrb0;
6092   1          LCD_DataWrite(temp);
6093   1      }
6094          void Internal_CGROM_Select_ISOIEC8859_5(void)
6095          {
6096   1          /*
6097   1          Font Selection for internal CGROM
6098   1          When FNCR0 B7 = 0 and B5 = 0, Internal CGROM supports the
6099   1          8x16 character sets with the standard coding of ISO/IEC 8859-1,2,4,5,
6100   1          which supports English and most of European country languages.
6101   1          00b : ISO/IEC 8859-1.
6102   1          01b : ISO/IEC 8859-2.
6103   1          10b : ISO/IEC 8859-4.
6104   1          11b : ISO/IEC 8859-5.
6105   1          */
6106   1          unsigned char temp;
6107   1          LCD_CmdWrite(0xCC);
6108   1          temp = LCD_DataRead();
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 100 

6109   1          temp |= cSetb1;
6110   1          temp |= cSetb0;
6111   1          LCD_DataWrite(temp);
6112   1      }
6113          //[CDh]=========================================================================
6114          void Enable_Font_Alignment(void)
6115          {
6116   1          /*
6117   1          Full Alignment Selection Bit
6118   1          0 : Full alignment disable.
6119   1          1 : Full alignment enable.
6120   1          */
6121   1          unsigned char temp;
6122   1          LCD_CmdWrite(0xCD);
6123   1          temp = LCD_DataRead();
6124   1          temp |= cSetb7;
6125   1          LCD_DataWrite(temp);
6126   1      }
6127          void Disable_Font_Alignment(void)
6128          {
6129   1          /*
6130   1          Full Alignment Selection Bit
6131   1          0 : Full alignment disable.
6132   1          1 : Full alignment enable.
6133   1          */
6134   1          unsigned char temp;
6135   1          LCD_CmdWrite(0xCD);
6136   1          temp = LCD_DataRead();
6137   1          temp &= cClrb7;
6138   1          LCD_DataWrite(temp);
6139   1      }
6140          void Font_Background_select_Original_Canvas(void)
6141          {
6142   1          /*
6143   1          Font Transparency
6144   1          0 : Character?s background displayed with specified color.
6145   1          1 : Character?s background displayed with original canvas background.
6146   1          */
6147   1          unsigned char temp;
6148   1          LCD_CmdWrite(0xCD);
6149   1          temp = LCD_DataRead();
6150   1          temp |= cSetb6;
6151   1          LCD_DataWrite(temp);
6152   1      }
6153          void Font_Background_select_Color(void)
6154          {
6155   1          /*
6156   1          Font Transparency
6157   1          0 : Character?s background displayed with specified color.
6158   1          1 : Character?s background displayed with original canvas background.
6159   1          */
6160   1          unsigned char temp;
6161   1          LCD_CmdWrite(0xCD);
6162   1          temp = LCD_DataRead();
6163   1          temp &= cClrb6;
6164   1          LCD_DataWrite(temp);
6165   1      }
6166          void Font_0_degree(void)
6167          {
6168   1          /*
6169   1          Font Rotation
6170   1          0 : Normal
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 101 

6171   1          Text direction from left to right then from top to bottom
6172   1          1 : Counterclockwise 90 degree & horizontal flip
6173   1          Text direction from top to bottom then from left to right
6174   1          (it should accommodate with set VDIR as 1)
6175   1          This attribute can be changed only when previous font write
6176   1          finished (core_busy = 0)
6177   1          */
6178   1          unsigned char temp;
6179   1          LCD_CmdWrite(0xCD);
6180   1          temp = LCD_DataRead();
6181   1          temp &= cClrb4;
6182   1          LCD_DataWrite(temp);
6183   1      }
6184          void Font_90_degree(void)
6185          {
6186   1          /*
6187   1          Font Rotation
6188   1          0 : Normal
6189   1          Text direction from left to right then from top to bottom
6190   1          1 : Counterclockwise 90 degree & horizontal flip
6191   1          Text direction from top to bottom then from left to right
6192   1          (it should accommodate with set VDIR as 1)
6193   1          This attribute can be changed only when previous font write
6194   1          finished (core_busy = 0)
6195   1          */
6196   1          unsigned char temp;
6197   1          LCD_CmdWrite(0xCD);
6198   1          temp = LCD_DataRead();
6199   1          temp |= cSetb4;
6200   1          LCD_DataWrite(temp);
6201   1      }
6202          void Font_Width_X1(void)
6203          {
6204   1          /*
6205   1          Horizontal Font Enlargement
6206   1          00b : X1.
6207   1          01b : X2.
6208   1          10b : X3.
6209   1          11b : X4.
6210   1          */
6211   1          unsigned char temp;
6212   1          LCD_CmdWrite(0xCD);
6213   1          temp = LCD_DataRead();
6214   1          temp &= cClrb3;
6215   1          temp &= cClrb2;
6216   1          LCD_DataWrite(temp);
6217   1      }
6218          void Font_Width_X2(void)
6219          {
6220   1          /*
6221   1          Horizontal Font Enlargement
6222   1          00b : X1.
6223   1          01b : X2.
6224   1          10b : X3.
6225   1          11b : X4.
6226   1          */
6227   1          unsigned char temp;
6228   1          LCD_CmdWrite(0xCD);
6229   1          temp = LCD_DataRead();
6230   1          temp &= cClrb3;
6231   1          temp |= cSetb2;
6232   1          LCD_DataWrite(temp);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 102 

6233   1      }
6234          void Font_Width_X3(void)
6235          {
6236   1          /*
6237   1          Horizontal Font Enlargement
6238   1          00b : X1.
6239   1          01b : X2.
6240   1          10b : X3.
6241   1          11b : X4.
6242   1          */
6243   1          unsigned char temp;
6244   1          LCD_CmdWrite(0xCD);
6245   1          temp = LCD_DataRead();
6246   1          temp |= cSetb3;
6247   1          temp &= cClrb2;
6248   1          LCD_DataWrite(temp);
6249   1      }
6250          void Font_Width_X4(void)
6251          {
6252   1          /*
6253   1          Horizontal Font Enlargement
6254   1          00b : X1.
6255   1          01b : X2.
6256   1          10b : X3.
6257   1          11b : X4.
6258   1          */
6259   1          unsigned char temp;
6260   1          LCD_CmdWrite(0xCD);
6261   1          temp = LCD_DataRead();
6262   1          temp |= cSetb3;
6263   1          temp |= cSetb2;
6264   1          LCD_DataWrite(temp);
6265   1      }
6266          void Font_Height_X1(void)
6267          {
6268   1          /*
6269   1          Vertical Font Enlargement
6270   1          00b : X1.
6271   1          01b : X2.
6272   1          10b : X3.
6273   1          11b : X4.
6274   1          */
6275   1          unsigned char temp;
6276   1          LCD_CmdWrite(0xCD);
6277   1          temp = LCD_DataRead();
6278   1          temp &= cClrb1;
6279   1          temp &= cClrb0;
6280   1          LCD_DataWrite(temp);
6281   1      }
6282          void Font_Height_X2(void)
6283          {
6284   1          /*
6285   1          Vertical Font Enlargement
6286   1          00b : X1.
6287   1          01b : X2.
6288   1          10b : X3.
6289   1          11b : X4.
6290   1          */
6291   1          unsigned char temp;
6292   1          LCD_CmdWrite(0xCD);
6293   1          temp = LCD_DataRead();
6294   1          temp &= cClrb1;
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 103 

6295   1          temp |= cSetb0;
6296   1          LCD_DataWrite(temp);
6297   1      }
6298          void Font_Height_X3(void)
6299          {
6300   1          /*
6301   1          Vertical Font Enlargement
6302   1          00b : X1.
6303   1          01b : X2.
6304   1          10b : X3.
6305   1          11b : X4.
6306   1          */
6307   1          unsigned char temp;
6308   1          LCD_CmdWrite(0xCD);
6309   1          temp = LCD_DataRead();
6310   1          temp |= cSetb1;
6311   1          temp &= cClrb0;
6312   1          LCD_DataWrite(temp);
6313   1      }
6314          void Font_Height_X4(void)
6315          {
6316   1          /*
6317   1          Vertical Font Enlargement
6318   1          00b : X1.
6319   1          01b : X2.
6320   1          10b : X3.
6321   1          11b : X4.
6322   1          */
6323   1          unsigned char temp;
6324   1          LCD_CmdWrite(0xCD);
6325   1          temp = LCD_DataRead();
6326   1          temp |= cSetb1;
6327   1          temp |= cSetb0;
6328   1          LCD_DataWrite(temp);
6329   1      }
6330          
6331          //[CEh]=========================================================================
6332          void GTFont_Select_GT21L16T1W(void)
6333          {
6334   1          /*
6335   1          GT Serial Font ROM Select
6336   1          000b: GT21L16T1W
6337   1          001b: GT30L16U2W
6338   1          010b: GT30L24T3Y
6339   1          011b: GT30L24M1Z
6340   1          100b: GT30L32S4W
6341   1          101b: GT20L24F6Y
6342   1          110b: GT21L24S1W
6343   1          */
6344   1          unsigned char temp;
6345   1          LCD_CmdWrite(0xCE);
6346   1          temp = LCD_DataRead();
6347   1          temp &= cClrb7;
6348   1          temp &= cClrb6;
6349   1          temp &= cClrb5;
6350   1          LCD_DataWrite(temp);
6351   1      }
6352          void GTFont_Select_GT30L16U2W(void)
6353          {
6354   1          /*
6355   1          GT Serial Font ROM Select
6356   1          000b: GT21L16T1W
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 104 

6357   1          001b: GT30L16U2W
6358   1          010b: GT30L24T3Y
6359   1          011b: GT30L24M1Z
6360   1          100b: GT30L32S4W
6361   1          101b: GT20L24F6Y
6362   1          110b: GT21L24S1W
6363   1          */
6364   1          unsigned char temp;
6365   1          LCD_CmdWrite(0xCE);
6366   1          temp = LCD_DataRead();
6367   1          temp &= cClrb7;
6368   1          temp &= cClrb6;
6369   1          temp |= cSetb5;
6370   1          LCD_DataWrite(temp);
6371   1      }
6372          void GTFont_Select_GT30L24T3Y(void)
6373          {
6374   1          /*
6375   1          GT Serial Font ROM Select
6376   1          000b: GT21L16T1W
6377   1          001b: GT30L16U2W
6378   1          010b: GT30L24T3Y
6379   1          011b: GT30L24M1Z
6380   1          100b: GT30L32S4W
6381   1          101b: GT20L24F6Y
6382   1          110b: GT21L24S1W
6383   1          */
6384   1          unsigned char temp;
6385   1          LCD_CmdWrite(0xCE);
6386   1          temp = LCD_DataRead();
6387   1          temp &= cClrb7;
6388   1          temp |= cSetb6;
6389   1          temp &= cClrb5;
6390   1          LCD_DataWrite(temp);
6391   1      }
6392          void GTFont_Select_GT30L24M1Z(void)
6393          {
6394   1          /*
6395   1          GT Serial Font ROM Select
6396   1          000b: GT21L16T1W
6397   1          001b: GT30L16U2W
6398   1          010b: GT30L24T3Y
6399   1          011b: GT30L24M1Z
6400   1          100b: GT30L32S4W
6401   1          101b: GT20L24F6Y
6402   1          110b: GT21L24S1W
6403   1          */
6404   1          unsigned char temp;
6405   1          LCD_CmdWrite(0xCE);
6406   1          temp = LCD_DataRead();
6407   1          temp &= cClrb7;
6408   1          temp |= cSetb6;
6409   1          temp |= cSetb5;
6410   1          LCD_DataWrite(temp);
6411   1      }
6412          void GTFont_Select_GT30L32S4W(void)
6413          {
6414   1          /*
6415   1          GT Serial Font ROM Select
6416   1          000b: GT21L16T1W
6417   1          001b: GT30L16U2W
6418   1          010b: GT30L24T3Y
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 105 

6419   1          011b: GT30L24M1Z
6420   1          100b: GT30L32S4W
6421   1          101b: GT20L24F6Y
6422   1          110b: GT21L24S1W
6423   1          */
6424   1          unsigned char temp;
6425   1          LCD_CmdWrite(0xCE);
6426   1          temp = LCD_DataRead();
6427   1          temp |= cSetb7;
6428   1          temp &= cClrb6;
6429   1          temp &= cClrb5;
6430   1          LCD_DataWrite(temp);
6431   1      }
6432          void GTFont_Select_GT20L24F6Y(void)
6433          {
6434   1          /*
6435   1          GT Serial Font ROM Select
6436   1          000b: GT21L16T1W
6437   1          001b: GT30L16U2W
6438   1          010b: GT30L24T3Y
6439   1          011b: GT30L24M1Z
6440   1          100b: GT30L32S4W
6441   1          101b: GT20L24F6Y
6442   1          110b: GT21L24S1W
6443   1          */
6444   1          unsigned char temp;
6445   1          LCD_CmdWrite(0xCE);
6446   1          temp = LCD_DataRead();
6447   1          temp |= cSetb7;
6448   1          temp &= cClrb6;
6449   1          temp |= cSetb5;
6450   1          LCD_DataWrite(temp);
6451   1      }
6452          void GTFont_Select_GT21L24S1W(void)
6453          {
6454   1          /*
6455   1          GT Serial Font ROM Select
6456   1          000b: GT21L16T1W
6457   1          001b: GT30L16U2W
6458   1          010b: GT30L24T3Y
6459   1          011b: GT30L24M1Z
6460   1          100b: GT30L32S4W
6461   1          101b: GT20L24F6Y
6462   1          110b: GT21L24S1W
6463   1          */
6464   1          unsigned char temp;
6465   1          LCD_CmdWrite(0xCE);
6466   1          temp = LCD_DataRead();
6467   1          temp |= cSetb7;
6468   1          temp |= cSetb6;
6469   1          temp &= cClrb5;
6470   1          LCD_DataWrite(temp);
6471   1      }
6472          
6473          //[CFh]=========================================================================
6474          void Set_GTFont_Decoder(unsigned char temp)
6475          {
6476   1          /*
6477   1          [bit7-3]
6478   1          FONT ROM Coding Setting
6479   1          For specific GT serial Font ROM, the coding method must be set for decoding.
6480   1          00000b: GB2312
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 106 

6481   1          00001b: GB12345/GB18030
6482   1          00010b: BIG5
6483   1          00011b: UNICODE
6484   1          00100b: ASCII
6485   1          00101b: UNI-Japanese
6486   1          00110b: JIS0208
6487   1          00111b: Latin/Greek/ Cyrillic / Arabic/Thai/Hebrew
6488   1          01000b: Korea
6489   1          10001b: ISO-8859-1
6490   1          10010b: ISO-8859-2
6491   1          10011b: ISO-8859-3
6492   1          10100b: ISO-8859-4
6493   1          10101b: ISO-8859-5
6494   1          10110b: ISO-8859-6
6495   1          10111b: ISO-8859-7
6496   1          11000b: ISO-8859-8
6497   1          11001b: ISO-8859-9
6498   1          11010b: ISO-8859-10
6499   1          11011b: ISO-8859-11
6500   1          11100b: ISO-8859-12
6501   1          11101b: ISO-8859-13
6502   1          11110b: ISO-8859-14
6503   1          11111b: ISO-8859-15
6504   1      
6505   1          [bit1-0]
6506   1          ASCII / Latin/Greek/ Cyrillic / Arabic
6507   1                  (ASCII)   (Latin/Greek/Cyrillic)  (Arabic)
6508   1          00b   Normal      Normal          NA
6509   1          01b   Arial     Variable Width      Presentation Forms-A
6510   1          10b   Roman       NA          Presentation Forms-B
6511   1          11b   Bold      NA            NA
6512   1          */
6513   1          LCD_CmdWrite(0xCF);
6514   1          LCD_DataWrite(temp);
6515   1      }
6516          //[D0h]=========================================================================
6517          void Font_Line_Distance(unsigned char temp)
6518          {
6519   1          /*[bit4-0]
6520   1          Font Line Distance Setting
6521   1          Setting the font character line distance when setting memory font
6522   1          write cursor auto move. (Unit: pixel)
6523   1          */
6524   1          LCD_CmdWrite(0xD0);
6525   1          LCD_DataWrite(temp);
6526   1      }
6527          //[D1h]=========================================================================
6528          void Set_Font_to_Font_Width(unsigned char temp)
6529          {
6530   1          /*[bit5-0]
6531   1          Font to Font Width Setting (Unit: pixel)
6532   1          */
6533   1          LCD_CmdWrite(0xD1);
6534   1          LCD_DataWrite(temp);
6535   1      }
6536          //[D2h]~[D4h]=========================================================================
6537          void Foreground_RGB(unsigned char RED, unsigned char GREEN, unsigned char BLUE)
6538          {
6539   1          /*
6540   1          [D2h] Foreground Color - Red, for draw, text or color expansion
6541   1          [D3h] Foreground Color - Green, for draw, text or color expansion
6542   1          [D4h] Foreground Color - Blue, for draw, text or color expansion
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 107 

6543   1          */
6544   1          LCD_CmdWrite(0xD2);
6545   1          LCD_DataWrite(RED);
6546   1      
6547   1          LCD_CmdWrite(0xD3);
6548   1          LCD_DataWrite(GREEN);
6549   1      
6550   1          LCD_CmdWrite(0xD4);
6551   1          LCD_DataWrite(BLUE);
6552   1      }
6553          
6554          // Input data format:R3G3B2
6555          void Foreground_color_256(unsigned char temp)
6556          {
6557   1          LCD_CmdWrite(0xD2);
6558   1          LCD_DataWrite(temp);
6559   1      
6560   1          LCD_CmdWrite(0xD3);
6561   1          LCD_DataWrite(temp << 3);
6562   1      
6563   1          LCD_CmdWrite(0xD4);
6564   1          LCD_DataWrite(temp << 6);
6565   1      }
6566          
6567          // Input data format:R5G6B5
6568          void Foreground_color_65k(unsigned short temp)
6569          {
6570   1          LCD_CmdWrite(0xD2);
6571   1          LCD_DataWrite(temp >> 8);
6572   1      
6573   1          LCD_CmdWrite(0xD3);
6574   1          LCD_DataWrite(temp >> 3);
6575   1      
6576   1          LCD_CmdWrite(0xD4);
6577   1          LCD_DataWrite(temp << 3);
6578   1      }
6579          
6580          // Input data format:R8G8B8
6581          void Foreground_color_16M(unsigned long temp)
6582          {
6583   1      
6584   1          LCD_CmdWrite(0xD2);
6585   1          LCD_DataWrite(temp >> 16);
6586   1      
6587   1          LCD_CmdWrite(0xD3);
6588   1          LCD_DataWrite(temp >> 8);
6589   1      
6590   1          LCD_CmdWrite(0xD4);
6591   1          LCD_DataWrite(temp);
6592   1      }
6593          
6594          //[D5h]~[D7h]=========================================================================
6595          /*
6596          [D5h] Background Color - Red, for Text or color expansion
6597          [D6h] Background Color - Green, for Text or color expansion
6598          [D7h] Background Color - Blue, for Text or color expansion
6599          */
6600          void Background_RGB(unsigned char RED, unsigned char GREEN, unsigned char BLUE)
6601          {
6602   1      
6603   1          LCD_CmdWrite(0xD5);
6604   1          LCD_DataWrite(RED);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 108 

6605   1      
6606   1          LCD_CmdWrite(0xD6);
6607   1          LCD_DataWrite(GREEN);
6608   1      
6609   1          LCD_CmdWrite(0xD7);
6610   1          LCD_DataWrite(BLUE);
6611   1      }
6612          
6613          // Input data format:R3G3B2
6614          void Background_color_256(unsigned char temp)
6615          {
6616   1          LCD_CmdWrite(0xD5);
6617   1          LCD_DataWrite(temp);
6618   1      
6619   1          LCD_CmdWrite(0xD6);
6620   1          LCD_DataWrite(temp << 3);
6621   1      
6622   1          LCD_CmdWrite(0xD7);
6623   1          LCD_DataWrite(temp << 6);
6624   1      }
6625          
6626          // Input data format:R5G6B6
6627          void Background_color_65k(unsigned short temp)
6628          {
6629   1          LCD_CmdWrite(0xD5);
6630   1          LCD_DataWrite(temp >> 8);
6631   1      
6632   1          LCD_CmdWrite(0xD6);
6633   1          LCD_DataWrite(temp >> 3);
6634   1      
6635   1          LCD_CmdWrite(0xD7);
6636   1          LCD_DataWrite(temp << 3);
6637   1      }
6638          
6639          // Input data format:R8G8B8
6640          void Background_color_16M(unsigned long temp)
6641          {
6642   1          LCD_CmdWrite(0xD5);
6643   1          LCD_DataWrite(temp >> 16);
6644   1      
6645   1          LCD_CmdWrite(0xD6);
6646   1          LCD_DataWrite(temp >> 8);
6647   1      
6648   1          LCD_CmdWrite(0xD7);
6649   1          LCD_DataWrite(temp);
6650   1      }
6651          
6652          //[DBh]~[DEh]=========================================================================
6653          void CGRAM_Start_address(unsigned long Addr)
6654          {
6655   1          /*
6656   1          CGRAM START ADDRESS [31:0]
6657   1          */
6658   1          LCD_CmdWrite(0xDB);
6659   1          LCD_DataWrite(Addr);
6660   1          LCD_CmdWrite(0xDC);
6661   1          LCD_DataWrite(Addr >> 8);
6662   1          LCD_CmdWrite(0xDD);
6663   1          LCD_DataWrite(Addr >> 16);
6664   1          LCD_CmdWrite(0xDE);
6665   1          LCD_DataWrite(Addr >> 24);
6666   1      }
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 109 

6667          
6668          //[DFh]=========================================================================
6669          /*
6670          [bit7] Enter Power saving state
6671          0: Normal state.
6672          1: Enter power saving state.
6673          [bit1][bit0] Power saving Mode definition
6674          00: NA
6675          01: Standby Mode
6676          10: Suspend Mode
6677          11: Sleep Mode
6678          */
6679          void Power_Normal_Mode(void)
6680          {
6681   1          LCD_CmdWrite(0xDF);
6682   1          LCD_DataWrite(0x00);
6683   1          Check_IC_ready();
6684   1      }
6685          void Power_Saving_Standby_Mode(void)
6686          {
6687   1          LCD_CmdWrite(0xDF);
6688   1          //  LCD_DataWrite(0x01);
6689   1          //  LCD_CmdWrite(0xDF);
6690   1          LCD_DataWrite(0x81);
6691   1      }
6692          void Power_Saving_Suspend_Mode(void)
6693          {
6694   1          LCD_CmdWrite(0xDF);
6695   1          //  LCD_DataWrite(0x02);
6696   1          //  LCD_CmdWrite(0xDF);
6697   1          LCD_DataWrite(0x82);
6698   1      }
6699          void Power_Saving_Sleep_Mode(void)
6700          {
6701   1          LCD_CmdWrite(0xDF);
6702   1          LCD_DataWrite(0x03);
6703   1          LCD_CmdWrite(0xDF);
6704   1          LCD_DataWrite(0x83);
6705   1      }
6706          
6707          //[E5h]~[E6h]=========================================================================
6708          void RA8889_I2CM_Clock_Prescale(unsigned short WX)
6709          {
6710   1          /*
6711   1          I2C Master Clock Pre-scale [7:0]
6712   1          I2C Master Clock Pre-scale [15:8]
6713   1          XSCL = CCLK / (5*(prescale + 2))
6714   1          */
6715   1          LCD_CmdWrite(0xE5);
6716   1          LCD_DataWrite(WX);
6717   1          LCD_CmdWrite(0xE6);
6718   1          LCD_DataWrite(WX >> 8);
6719   1      }
6720          //[E7h]=========================================================================
6721          void RA8889_I2CM_Transmit_Data(unsigned char temp)
6722          {
6723   1          /*
6724   1          I2C Master Transmit[7:0]
6725   1          */
6726   1          LCD_CmdWrite(0xE7);
6727   1          LCD_DataWrite(temp);
6728   1      }
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 110 

6729          //[E8h]=========================================================================
6730          unsigned char RA8889_I2CM_Receiver_Data(void)
6731          {
6732   1          /*
6733   1          I2C Master Receiver [7:0]
6734   1          */
6735   1          unsigned char temp;
6736   1          LCD_CmdWrite(0xE8);
6737   1          temp = LCD_DataRead();
6738   1          return temp;
6739   1      }
6740          //[E9h]=========================================================================
6741          /*
6742          [bit7] START
6743              Generate (repeated) start condition and be cleared by hardware automatically
6744              Note : This bit is always read as 0.
6745          [bit6] STOP
6746              Generate stop condition and be cleared by hardware automatically
6747              Note : This bit is always read as 0.
6748          [bit5] READ
6749              READ(READ and WRITE can’t be used simultaneously)
6750              Read form slave and be cleared by hardware automatically
6751              Note : This bit is always read as 0.
6752          [bit4] WRITE
6753              WRITE(READ and WRITE can’t be used simultaneously)
6754              Write to slave and be cleared by hardware automatically
6755              Note : This bit is always read as 0.
6756          [bit3] ACKNOWLEDGE
6757              When as a I2C master receiver
6758              0 : Sent ACK.
6759              1 : Sent NACK.
6760              Note : This bit is always read as 0.
6761          [bit0] Noise Filter
6762              0 : Enable.
6763              1 : Disable.
6764          */
6765          
6766          //[bit7] START
6767          void RA8889_I2CM_Write_With_Start(void)
6768          {
6769   1          LCD_CmdWrite(0xE9);
6770   1      #ifdef Disable_I2CM_Noise_Filter
                  LCD_DataWrite(0x90);
              #endif
6773   1      
6774   1      #ifdef Enable_I2CM_Noise_Filter
                  LCD_DataWrite(0x91);
              #endif
6777   1      }
6778          
6779          //[bit6] STOP
6780          void RA8889_I2CM_Stop(void)
6781          {
6782   1          LCD_CmdWrite(0xE9);
6783   1      #ifdef Disable_I2CM_Noise_Filter
                  LCD_DataWrite(0x40);
              #endif
6786   1      
6787   1      #ifdef Enable_I2CM_Noise_Filter
                  LCD_DataWrite(0x41);
              #endif
6790   1      }
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 111 

6791          
6792          //[bit5] READ
6793          void RA8889_I2CM_Read_With_Ack(void)
6794          {
6795   1          LCD_CmdWrite(0xE9);
6796   1      #ifdef Disable_I2CM_Noise_Filter
                  LCD_DataWrite(0x20);
              #endif
6799   1      #ifdef Enable_I2CM_Noise_Filter
                  LCD_DataWrite(0x21);
              #endif
6802   1      }
6803          
6804          void RA8889_I2CM_Read_With_Nack(void)
6805          {
6806   1          LCD_CmdWrite(0xE9);
6807   1      #ifdef Disable_I2CM_Noise_Filter
                  LCD_DataWrite(0x68);
              #endif
6810   1      #ifdef Enable_I2CM_Noise_Filter
                  LCD_DataWrite(0x69);
              #endif
6813   1      }
6814          
6815          //[bit4] WRITE
6816          void RA8889_I2CM_Write(void)
6817          {
6818   1          LCD_CmdWrite(0xE9);
6819   1      #ifdef Disable_I2CM_Noise_Filter
                  LCD_DataWrite(0x10);
              #endif
6822   1      #ifdef Enable_I2CM_Noise_Filter
                  LCD_DataWrite(0x11);
              #endif
6825   1      }
6826          
6827          //[EAh]=========================================================================
6828          
6829          unsigned char RA8889_I2CM_Check_Slave_ACK(void)
6830          {
6831   1          /*[bit7]
6832   1          Received acknowledge from slave
6833   1          0 : Acknowledge received.
6834   1          1 : No Acknowledge received.
6835   1          */
6836   1          unsigned char temp;
6837   1      
6838   1          LCD_CmdWrite(0xEA);
6839   1          temp = LCD_DataRead();
6840   1          if ((temp & 0x80) == 0x80)
6841   1              return 1;
6842   1          else
6843   1              return 0;
6844   1      }
6845          
6846          unsigned char RA8889_I2CM_Bus_Busy(void)
6847          {
6848   1          /*[bit6]
6849   1          I2C Bus is Busy
6850   1          0 : Idle.
6851   1          1 : Busy.
6852   1          */
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 112 

6853   1          unsigned char temp;
6854   1      
6855   1          LCD_CmdWrite(0xEA);
6856   1          temp = LCD_DataRead();
6857   1          if ((temp & 0x40) == 0x40)
6858   1              return 1;
6859   1          else
6860   1              return 0;
6861   1      }
6862          
6863          unsigned char RA8889_I2CM_transmit_Progress(void)
6864          {
6865   1          /*[bit6]
6866   1           0=Complete
6867   1           1=Transferring
6868   1          */
6869   1          unsigned char temp;
6870   1      
6871   1          LCD_CmdWrite(0xEA);
6872   1          temp = LCD_DataRead();
6873   1          if ((temp & 0x02) == 0x02)
6874   1              return 1;
6875   1          else
6876   1              return 0;
6877   1      }
6878          
6879          unsigned char RA8889_I2CM_Arbitration(void)
6880          {
6881   1          /*[bit6]
6882   1          I2C Bus is Busy
6883   1          0 : Idle.
6884   1          1 : Busy.
6885   1          */
6886   1          unsigned char temp;
6887   1      
6888   1          LCD_CmdWrite(0xEA);
6889   1          temp = LCD_DataRead();
6890   1          temp &= 0x01;
6891   1          return temp;
6892   1      }
6893          
6894          //[F0h]=========================================================================
6895          void Set_GPIO_A_In_Out(unsigned char temp)
6896          {
6897   1          /*
6898   1          GPO-A_dir[7:0] : General Purpose I/O direction control.
6899   1          0: Output
6900   1          1: Input
6901   1          */
6902   1          LCD_CmdWrite(0xF0);
6903   1          LCD_DataWrite(temp);
6904   1      }
6905          //[F1h]=========================================================================
6906          void Write_GPIO_A_7_0(unsigned char temp)
6907          {
6908   1          /*
6909   1          GPI-A[7:0] : General Purpose Input, share with DB[15:8]
6910   1          GPO-A[7:0] : General Purpose Output, share with DB[15:8]
6911   1          */
6912   1          LCD_CmdWrite(0xF1);
6913   1          LCD_DataWrite(temp);
6914   1      }
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 113 

6915          unsigned char Read_GPIO_A_7_0(void)
6916          {
6917   1          /*
6918   1          GPI-A[7:0] : General Purpose Input, share with DB[15:8]
6919   1          GPO-A[7:0] : General Purpose Output, share with DB[15:8]
6920   1          */
6921   1          unsigned char temp;
6922   1          LCD_CmdWrite(0xF1);
6923   1          temp = LCD_DataRead();
6924   1          return temp;
6925   1      }
6926          //[F2h]=========================================================================
6927          void Write_GPIO_B_7_4(unsigned char temp)
6928          {
6929   1          /*
6930   1          Bit [7:4] is port B's General Purpose Output bit [7:4]. They are share with XKOUT[3:0]
6931   1          Bit [3:0] is not writable.
6932   1          */
6933   1          LCD_CmdWrite(0xF2);
6934   1          LCD_DataWrite(temp);
6935   1      }
6936          unsigned char Read_GPIO_B_7_0(void)
6937          {
6938   1          /*
6939   1          Bit[7:0] are share with {XKIN[3:0], XA0, XnWR, XnRD, XnCS}
6940   1          Bit[3:0] are only available in serial MPU I/F, otherwise fix at 0.
6941   1          */
6942   1          unsigned char temp;
6943   1          LCD_CmdWrite(0xF2);
6944   1          temp = LCD_DataRead();
6945   1          return temp;
6946   1      }
6947          
6948          //[F3h]=========================================================================
6949          void Set_GPIO_C_In_Out(unsigned char temp)
6950          {
6951   1          /*
6952   1          GPIO-C_dir[7:0] : General Purpose I/O direction control.
6953   1          0: Output
6954   1          1: Input
6955   1          */
6956   1          LCD_CmdWrite(0xF3);
6957   1          LCD_DataWrite(temp);
6958   1      }
6959          //[F4h]=========================================================================
6960          void Write_GPIO_C_7_0(unsigned char temp)
6961          {
6962   1          /*
6963   1          REG[F4h] GPIO-C
6964   1          GPIO-C[7] : XPWM0,
6965   1          GPIO_C[4:0] : XnSFCS1, XnSFCS0, XMISO, XMOSI, XSCLK.
6966   1          */
6967   1          LCD_CmdWrite(0xF4);
6968   1          LCD_DataWrite(temp);
6969   1      }
6970          unsigned char Read_GPIO_C_7_0(void)
6971          {
6972   1          /*
6973   1          REG[F4h] GPIO-C
6974   1          GPIO-C[7] : XPWM0,
6975   1          GPIO_C[4:0] : XnSFCS1, XnSFCS0, XMISO, XMOSI, XSCLK.
6976   1          */
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 114 

6977   1          unsigned char temp;
6978   1          LCD_CmdWrite(0xF4);
6979   1          temp = LCD_DataRead();
6980   1          return temp;
6981   1      }
6982          //[F5h]=========================================================================
6983          void Set_GPIO_D_In_Out(unsigned char temp)
6984          {
6985   1          /*
6986   1          GPIO-D_dir[7:0] : General Purpose I/O direction control.
6987   1          0: Output
6988   1          1: Input
6989   1          */
6990   1          LCD_CmdWrite(0xF5);
6991   1          LCD_DataWrite(temp);
6992   1      }
6993          //[F6h]=========================================================================
6994          void Write_GPIO_D_7_0(unsigned char temp)
6995          {
6996   1          /*
6997   1          GPIO-D[7:0] : General Purpose Input/Output
6998   1          */
6999   1          LCD_CmdWrite(0xF6);
7000   1          LCD_DataWrite(temp);
7001   1      }
7002          unsigned char Read_GPIO_D_7_0(void)
7003          {
7004   1          /*
7005   1          GPIO-D[7:0] : General Purpose Input/Output
7006   1          */
7007   1          unsigned char temp;
7008   1          LCD_CmdWrite(0xF6);
7009   1          temp = LCD_DataRead();
7010   1          return temp;
7011   1      }
7012          //[F7h]=========================================================================
7013          void Set_GPIO_E_In_Out(unsigned char temp)
7014          {
7015   1          /*
7016   1          GPIO-E_dir[7:0] : General Purpose I/O direction control.
7017   1          0: Output
7018   1          1: Input
7019   1          */
7020   1          LCD_CmdWrite(0xF7);
7021   1          LCD_DataWrite(temp);
7022   1      }
7023          //[F8h]=========================================================================
7024          void Write_GPIO_E_7_0(unsigned char temp)
7025          {
7026   1          /*
7027   1          GPIO-E[7:0] : General Purpose Input/Output.
7028   1          share with {PDAT[23:19], PDAT[15:13]}
7029   1          */
7030   1          LCD_CmdWrite(0xF8);
7031   1          LCD_DataWrite(temp);
7032   1      }
7033          unsigned char Read_GPIO_E_7_0(void)
7034          {
7035   1          /*
7036   1          GPIO-E[7:0] : General Purpose Input/Output.
7037   1          share with {PDAT[23:19], PDAT[15:13]}
7038   1          */
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 115 

7039   1          unsigned char temp;
7040   1          LCD_CmdWrite(0xF8);
7041   1          temp = LCD_DataRead();
7042   1          return temp;
7043   1      }
7044          //[F9h]=========================================================================
7045          void Set_GPIO_F_In_Out(unsigned char temp)
7046          {
7047   1          /*
7048   1          GPIO-F_dir[7:0] : General Purpose I/O direction control.
7049   1          0: Output
7050   1          1: Input
7051   1          */
7052   1          LCD_CmdWrite(0xF9);
7053   1          LCD_DataWrite(temp);
7054   1      }
7055          //[FAh]=========================================================================
7056          void Write_GPIO_F_7_0(unsigned char temp)
7057          {
7058   1          /*
7059   1          GPIO-F[7:0] : General Purpose Input/Output.
7060   1          share with {XPDAT[12:10], XPDAT[7:3]}
7061   1          */
7062   1          LCD_CmdWrite(0xFA);
7063   1          LCD_DataWrite(temp);
7064   1      }
7065          unsigned char Read_GPIO_F_7_0(void)
7066          {
7067   1          /*
7068   1          GPIO-F[7:0] : General Purpose Input/Output.
7069   1          share with {XPDAT[12:10], XPDAT[7:3]}
7070   1          */
7071   1          unsigned char temp;
7072   1          LCD_CmdWrite(0xFA);
7073   1          temp = LCD_DataRead();
7074   1          return temp;
7075   1      }
7076          
7077          //[FBh]=========================================================================
7078          
7079          void Long_Key_enable(void)
7080          {
7081   1          /*
7082   1         Key-Scan Control Register 1
7083   1         [bit6]   LongKey Enable Bit
7084   1         1 : Enable. Long key period is set by KSCR2 bit4-2.
7085   1         0 : Disable.
7086   1         */
7087   1          unsigned char temp;
7088   1          LCD_CmdWrite(0xFB);
7089   1          temp = LCD_DataRead();
7090   1          temp |= cSetb6;
7091   1          LCD_DataWrite(temp);
7092   1      }
7093          
7094          void Key_Scan_Freg(unsigned char setx)
7095          {
7096   1          /*KF2-0: Key-Scan Frequency */
7097   1          unsigned char temp;
7098   1          LCD_CmdWrite(0xFB);
7099   1          temp = LCD_DataRead();
7100   1          temp &= 0xf0;
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 116 

7101   1          temp |= (setx & 0x07);
7102   1          LCD_DataWrite(temp);
7103   1      }
7104          
7105          //[FCh]=========================================================================
7106          
7107          void Key_Scan_Wakeup_Function_Enable(void)
7108          {
7109   1          /*
7110   1          Key-Scan Controller Register 2
7111   1          [bit7]
7112   1          Key-Scan Wakeup Function Enable Bit
7113   1          0: Key-Scan Wakeup function is disabled.
7114   1          1: Key-Scan Wakeup function is enabled.
7115   1          */
7116   1          unsigned char temp;
7117   1          LCD_CmdWrite(0xFC);
7118   1          temp = LCD_DataRead();
7119   1          temp |= cSetb7;
7120   1          LCD_DataWrite(temp);
7121   1      }
7122          
7123          void Long_Key_Timing_Adjustment(unsigned char setx)
7124          {
7125   1          /*Long Key Timing Adjustment*/
7126   1          unsigned char temp, temp1;
7127   1          temp = setx & 0x1c;
7128   1          LCD_CmdWrite(0xFC);
7129   1          temp1 = LCD_DataRead();
7130   1          temp1 |= temp;
7131   1          LCD_DataWrite(temp1);
7132   1      }
7133          
7134          unsigned char Numbers_of_Key_Hit(void)
7135          {
7136   1          unsigned char temp;
7137   1          LCD_CmdWrite(0xFC);
7138   1          temp = LCD_DataRead(); // read key touch number
7139   1          temp = temp & 0x03;    // _J有按I被按下
7140   1          return temp;
7141   1      }
7142          
7143          //[FDh][FEh][FFh]=========================================================================
7144          unsigned char Read_Key_Strobe_Data_0(void)
7145          {
7146   1          /*
7147   1          Key Strobe Data 0
7148   1          The corresponding key code 0 that is pressed.
7149   1          */
7150   1          unsigned char temp;
7151   1          LCD_CmdWrite(0xFD);
7152   1          temp = LCD_DataRead();
7153   1          return temp;
7154   1      }
7155          unsigned char Read_Key_Strobe_Data_1(void)
7156          {
7157   1          /*
7158   1          Key Strobe Data 1
7159   1          The corresponding key code 1 that is pressed.
7160   1          */
7161   1          unsigned char temp;
7162   1          LCD_CmdWrite(0xFE);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 117 

7163   1          temp = LCD_DataRead();
7164   1          return temp;
7165   1      }
7166          unsigned char Read_Key_Strobe_Data_2(void)
7167          {
7168   1          /*
7169   1          Key Strobe Data 2
7170   1          The corresponding key code 2 that is pressed.
7171   1          */
7172   1          unsigned char temp;
7173   1          LCD_CmdWrite(0xFF);
7174   1          temp = LCD_DataRead();
7175   1          return temp;
7176   1      }
7177          
7178          /*------------------------------------//------------------------------------
7179          //------------------------------------//----------------------------------*/
7180          
7181          void Set_LCD_Panel(void)
7182          {
7183   1      #ifdef EJ080NA_04B // ##INNOLUX_1024x768_EJ080NA-04B
              
                  //**[03h]**//
                  LVDS_Format1(); //(VESA format)//only for RA8877
                                  //  LVDS_Format2();//(JEIDA format) //only for RA8877
              
                  //**[10h]**//
                  //  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
                  HSYNC_Low_Active();
                  //  HSYNC_High_Active();
              
                  VSYNC_Low_Active();
                  //  VSYNC_High_Active();
              
                  //  DE_Low_Active();
                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(1024, 768); // INNOLUX 1024x768。
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 118 

                  */
                  LCD_Horizontal_Non_Display(96); // Blank=90~376, TYP.=320。
                  LCD_HSYNC_Start_Position(96);   // Start Position or Front-Porch
                  LCD_HSYNC_Pulse_Width(128);     // Pulse Width
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(10); // Non Display or Back-Porch  //Blank=10~77, TYP.=38。
                  LCD_VSYNC_Start_Position(10); // Start Position or Front-Porch
                  LCD_VSYNC_Pulse_Width(16);    // Pulse Width
              
              #endif
7239   1      
7240   1      #ifdef LQ150X1LGN2C // ##SHARP_LQ150X1LGN2C_LVDS1 & LVDS2
              
                  //**[03h]**//
                  LVDS_Format1(); //(VESA format)//only for RA8877
                                  //  LVDS_Format2();//(JEIDA format) //only for RA8877
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                                          //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
                  HSYNC_Low_Active();
                  //  HSYNC_High_Active();
              
                  VSYNC_Low_Active();
                  //  VSYNC_High_Active();
              
                  //  DE_Low_Active();
                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(1024, 768); // SHARP1024x768。
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(30); // SHARP1024x768，Blank=32~320~696。
                  LCD_HSYNC_Start_Position(10);   // SHARP1024x768。
                  LCD_HSYNC_Pulse_Width(10);      // SHARP1024x768。
              
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 119 

                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(20); // SHARP1024x768，Blank=5~38~222。
                  LCD_VSYNC_Start_Position(10); // SHARP1024x768。
                  LCD_VSYNC_Pulse_Width(10);    // SHARP1024x768。
              #endif
7295   1      
7296   1      #ifdef N070ICG_LD1 // ##INNOLUX_1280x800_N070ICG-LD1
              
                  //**[03h]**//
                  LVDS_Format1(); //(VESA format)//only for RA8877
                                  //  LVDS_Format2();//(JEIDA format) //only for RA8877
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                                          //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
                  HSYNC_Low_Active();
                  //  HSYNC_High_Active();
              
                  VSYNC_Low_Active();
                  //  VSYNC_High_Active();
              
                  //  DE_Low_Active();
                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(1280, 800); //
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(50); //
                  LCD_HSYNC_Start_Position(32);   //
                  LCD_HSYNC_Pulse_Width(80);      //
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(24); //
                  LCD_VSYNC_Start_Position(4);  //
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 120 

                  LCD_VSYNC_Pulse_Width(24);    //
              
              #endif
7352   1      
7353   1      #ifdef B116XW03_V0 // ##AUO1366x768_B116XW03 V0
              
                  //**[03h]**//
                  LVDS_Format1(); //(VESA format)//only for RA8877
                                  //  LVDS_Format2();//(JEIDA format) //only for RA8877
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                                          //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
                  //  HSYNC_Low_Active();
                  //  HSYNC_High_Active();
              
                  //  VSYNC_Low_Active();
                  //  VSYNC_High_Active();
              
                  //  DE_Low_Active();
                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(1366, 768); //
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(10); //
                  LCD_HSYNC_Start_Position(10);   //
                  LCD_HSYNC_Pulse_Width(100);     // 刻意加大o 76+ 用
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(4); //
                  LCD_VSYNC_Start_Position(4); //
                  LCD_VSYNC_Pulse_Width(50);   // 刻意加大o 76+ 用
              #endif
7408   1      
7409   1      #ifdef G121XN01_V0 // ##AUO1366x768_B116XW03 V0
              
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 121 

                  //**[03h]**//
                  LVDS_Format1(); //(VESA format)//only for RA8877
                                  //  LVDS_Format2();//(JEIDA format) //only for RA8877
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                                          //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
                  //  HSYNC_Low_Active();
                  //  HSYNC_High_Active();
              
                  //  VSYNC_Low_Active();
                  //  VSYNC_High_Active();
              
                  //  DE_Low_Active();
                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(1024, 768); //
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(60); //
                  LCD_HSYNC_Start_Position(60);   //
                  LCD_HSYNC_Pulse_Width(240);     //
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(8); //
                  LCD_VSYNC_Start_Position(8); //
                  LCD_VSYNC_Pulse_Width(16);   //
              #endif
7464   1      
7465   1      #ifdef LQ121S1LG81 // ##SHARP_LQ121S1LG81
              
                  //**[03h]**//
                  LVDS_Format1(); //(VESA format)//only for RA8877
                                  //  LVDS_Format2();//(JEIDA format) //only for RA8877
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 122 

                                          //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
                  HSYNC_Low_Active();
                  //  HSYNC_High_Active();
              
                  VSYNC_Low_Active();
                  //  VSYNC_High_Active();
              
                  //  DE_Low_Active();
                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(800, 600); //
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(88); //
                  LCD_HSYNC_Start_Position(40);   //
                  LCD_HSYNC_Pulse_Width(128);     //
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(23); //
                  LCD_VSYNC_Start_Position(39); //
                  LCD_VSYNC_Pulse_Width(4);     //
              
              #endif
7521   1      
7522   1      #ifdef LQ035NC111
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                  //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  // PCLK_Falling();
                  PCLK_Rising();
              
                  VSCAN_T_to_B();
                  PDATA_Set_RGB();
              
                  // HSYNC_High_Active();
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 123 

                  // VSYNC_High_Active();
              
                  HSYNC_Low_Active();
                  VSYNC_Low_Active();
                  // DE_High_Active();
                  DE_Low_Active();
              
                  LCD_HorizontalWidth_VerticalHeight(320, 240); //
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(28); //
                  LCD_HSYNC_Start_Position(20);   //
                  LCD_HSYNC_Pulse_Width(40);      //  non_display + pulse width = 68
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(8); //
                  LCD_VSYNC_Start_Position(2); //
                  LCD_VSYNC_Pulse_Width(8);    //
              
              #endif
7561   1      
7562   1      #ifdef EJ080NA_05B
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                  //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  PCLK_Falling();
                  // PCLK_Rising();
              
                  VSCAN_T_to_B();
                  PDATA_Set_RGB();
              
                  HSYNC_Low_Active();
                  VSYNC_Low_Active();
                  DE_High_Active();
                  // DE_Low_Active();
              
                  LCD_HorizontalWidth_VerticalHeight(800, 600); // INNOLUX 800x600。
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(38); // INNOLUX800x600，46。
                  LCD_HSYNC_Start_Position(210);  // INNOLUX800x600，16~354。
                  LCD_HSYNC_Pulse_Width(8);       // INNOLUX800x600，1~40C
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(15); // INNOLUX800x600，23。
                  LCD_VSYNC_Start_Position(12); // INNOLUX800x600，1~77。
                  LCD_VSYNC_Pulse_Width(8);     // INNOLUX800x600，1~20C
              
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 124 

              #endif
7598   1      
7599   1      #ifdef AWY_800480T70N02
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                  //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  PCLK_Falling();
                  // PCLK_Rising();
              
                  VSCAN_T_to_B();
                  PDATA_Set_RGB();
              
                  HSYNC_Low_Active();
                  VSYNC_Low_Active();
                  DE_High_Active();
                  // DE_Low_Active();
              
                  LCD_HorizontalWidth_VerticalHeight(800, 480);
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(40);
                  LCD_HSYNC_Start_Position(40);
                  LCD_HSYNC_Pulse_Width(48);
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(24);
                  LCD_VSYNC_Start_Position(13);
                  LCD_VSYNC_Pulse_Width(8);
              
              #endif
7635   1      
7636   1      #ifdef DH320x960 // ##
              
                  //**[10h]**//
                  //      Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 125 

                  HSYNC_Low_Active();
                  //  HSYNC_High_Active();
              
                  VSYNC_Low_Active();
                  //  VSYNC_High_Active();
              
                  //  DE_Low_Active();
                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(320, 960);
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(110); // Blank=204x2。
                  LCD_HSYNC_Start_Position(110);   //
                  LCD_HSYNC_Pulse_Width(110);      //
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(15); // Blank=42。
                  LCD_VSYNC_Start_Position(15); //
                  LCD_VSYNC_Pulse_Width(12);    //
              
              #endif
7688   1      
7689   1      #ifdef AWT_1024600L7N03
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                  //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  PCLK_Falling();
                  // PCLK_Rising();
              
                  VSCAN_T_to_B();
                  PDATA_Set_RGB();
              
                  HSYNC_Low_Active();
                  VSYNC_Low_Active();
                  DE_High_Active();
                  // DE_Low_Active();
              
                  LCD_HorizontalWidth_VerticalHeight(1024, 600);
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(80);
                  LCD_HSYNC_Start_Position(80);
                  LCD_HSYNC_Pulse_Width(160);
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(8);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 126 

                  LCD_VSYNC_Start_Position(5);
                  LCD_VSYNC_Pulse_Width(8);
              
              #endif
7725   1      
7726   1      #ifdef AT043TN25
              
                  //**[10h]**//
                  //      Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //  PCLK_Rising();
                  PCLK_Falling();
                  VSCAN_T_to_B();
                  PDATA_Set_RGB();
              
                  //**[13h]**//
                  HSYNC_Low_Active();
                  VSYNC_Low_Active();
                  DE_High_Active();
                  //  DE_Low_Active();
                  //------------------------------------
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(480, 272); // LCD Resolution 480x272。
                  //**[16h][17h]**//
                  LCD_Horizontal_Non_Display(38); // 480x272，HSYNC Back Porch=38。
                  //**[18h]**//
                  LCD_HSYNC_Start_Position(20); // 480x272 HSYNC Front Porch = 20。
                  //**[19h]**//
                  LCD_HSYNC_Pulse_Width(20); // 480x272，HSYNC Pulse Width=5~30,set 20。
                  //**[1Ch][1Dh]**//
                  LCD_Vertical_Non_Display(4); // 480x272，VSYNC Back Porch =4。
                  //**[1Eh]**//
                  LCD_VSYNC_Start_Position(15); // 480x272，VSYNC Front Porch =15。
                  //**[1Fh]**//
                  LCD_VSYNC_Pulse_Width(3); // 480x272，VSYNC Pulse Width =3。
              
              #endif
7759   1      
7760   1      #ifdef AT070TN92
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                  //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  PCLK_Falling();
                  // PCLK_Rising();
              
                  VSCAN_T_to_B();
                  //    VSCAN_B_to_T();
                  PDATA_Set_RGB();
              
                  HSYNC_Low_Active();
                  VSYNC_Low_Active();
                  DE_High_Active();
                  // DE_Low_Active();
              
                  LCD_HorizontalWidth_VerticalHeight(800, 480); // INNOLUX 800x480。
                  LCD_Horizontal_Non_Display(30);               // INNOLUX800x600，46。
                  LCD_HSYNC_Start_Position(210);                // INNOLUX800x600，16~354。
                  LCD_HSYNC_Pulse_Width(16);                    // INNOLUX800x600，1~40。
                  LCD_Vertical_Non_Display(13);                 // INNOLUX800x600，23。
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 127 

                  LCD_VSYNC_Start_Position(22);                 // INNOLUX800x600，1~147。
                  LCD_VSYNC_Pulse_Width(10);                    // INNOLUX800x600，1~20。
              
              #endif
7787   1        
7788   1      
7789   1      #ifdef L10600R70
              
                  //**[03h]**//
                  LVDS_Format1(); //(VESA format)//only for RA8877
                                  //  LVDS_Format2();//(JEIDA format) //only for RA8877
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                                          //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
                  HSYNC_Low_Active();
                  //  HSYNC_High_Active();
              
                  VSYNC_Low_Active();
                  //  VSYNC_High_Active();
              
                  //  DE_Low_Active();
                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(1024, 600); // 1024x600
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(40); // Blank=320。
                  LCD_HSYNC_Start_Position(48);   //
                  LCD_HSYNC_Pulse_Width(120);     //
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(9); // Blank=35。
                  LCD_VSYNC_Start_Position(7); //
                  LCD_VSYNC_Pulse_Width(14);   //
              
              #endif
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 128 

7845   1      
7846   1      #ifdef L80480R70
7847   1      
7848   1        //**[10h]**//
7849   1        Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
7850   1      //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
7851   1        
7852   1        PCLK_Falling();
7853   1      //  PCLK_Rising();
7854   1      
7855   1        VSCAN_T_to_B();
7856   1        PDATA_Set_RGB();
7857   1      
7858   1        HSYNC_Low_Active();
7859   1        VSYNC_Low_Active();
7860   1        DE_High_Active();
7861   1      //  DE_Low_Active();
7862   1      
7863   1        LCD_HorizontalWidth_VerticalHeight(800,480);
7864   1        LCD_Horizontal_Non_Display(64);
7865   1        LCD_HSYNC_Start_Position(208);
7866   1        LCD_HSYNC_Pulse_Width(24);
7867   1        LCD_Vertical_Non_Display(16);
7868   1        LCD_VSYNC_Start_Position(22);
7869   1        LCD_VSYNC_Pulse_Width(16);
7870   1      
7871   1      #endif
7872   1      
7873   1      #ifdef ET101000DM6 // ##EDT_1024x600_ET101000DM6
              
                  //**[03h]**//
                  LVDS_Format1(); //(VESA format)//only for RA8877
                                  //  LVDS_Format2();//(JEIDA format) //only for RA8877
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                                          //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
                  HSYNC_Low_Active();
                  //  HSYNC_High_Active();
              
                  VSYNC_Low_Active();
                  //  VSYNC_High_Active();
              
                  //  DE_Low_Active();
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 129 

                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(1024, 600); // EDT_1024x600???
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(160); // EDT_1024x600???Blank=90~376@320???
                  LCD_HSYNC_Start_Position(160);   // EDT_1024x600???Blank=90~376@320???
                  LCD_HSYNC_Pulse_Width(60);       // EDT_1024x600???Blank=90~376@320???
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(23); // EDT_1024x600???Blank=10~200@35???
                  LCD_VSYNC_Start_Position(12); // EDT_1024x600???Blank=10~200@35???
                  LCD_VSYNC_Pulse_Width(5);     // EDT_1024x600???Blank=10~200@35???
              
              #endif
7929   1      
7930   1      #ifdef AT043TN25
              
                  //**[10h]**//
                  //  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //  PCLK_Rising();
                  PCLK_Falling();
                  VSCAN_T_to_B();
                  PDATA_Set_RGB();
              
                  //**[13h]**//
                  HSYNC_Low_Active();
                  VSYNC_Low_Active();
                  DE_High_Active();
                  //  DE_Low_Active();
                  //------------------------------------
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(480, 272); // LCD Resolution 480x272。
                  //**[16h][17h]**//
                  LCD_Horizontal_Non_Display(38); // 480x272，HSYNC Back Porch=38。
                  //**[18h]**//
                  LCD_HSYNC_Start_Position(20); // 480x272 HSYNC Front Porch = 20。
                  //**[19h]**//
                  LCD_HSYNC_Pulse_Width(20); // 480x272，HSYNC Pulse Width=5~30,set 20。
                  //**[1Ch][1Dh]**//
                  LCD_Vertical_Non_Display(4); // 480x272，VSYNC Back Porch =4。
                  //**[1Eh]**//
                  LCD_VSYNC_Start_Position(15); // 480x272，VSYNC Front Porch =15。
                  //**[1Fh]**//
                  LCD_VSYNC_Pulse_Width(3); // 480x272，VSYNC Pulse Width =3。
              
              #endif
7963   1      
7964   1      #ifdef LQ035NC111
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                                          //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 130 

              
                  PCLK_Rising();
                  //  PCLK_Falling();
                  VSCAN_T_to_B();
                  PDATA_Set_RGB();
              
                  //**[13h]**//
                  HSYNC_Low_Active();
                  VSYNC_Low_Active();
                  //  DE_High_Active();
                  DE_Low_Active();
                  //------------------------------------
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(320, 240); // LCD Resolution 320x240。
                  //**[16h][17h]**//
                  LCD_Horizontal_Non_Display(38); // 320x240，HSYNC Back Porch=38。
                  //**[18h]**//
                  LCD_HSYNC_Start_Position(20); // 320x240 HSYNC Front Porch = 20。
                  //**[19h]**//
                  LCD_HSYNC_Pulse_Width(20); // 320x240，HSYNC Pulse Width=5~30,set 20。
                  //**[1Ch][1Dh]**//
                  LCD_Vertical_Non_Display(4); // 320x240，VSYNC Back Porch =4。
                  //**[1Eh]**//
                  LCD_VSYNC_Start_Position(15); // 320x240，VSYNC Front Porch =15。
                  //**[1Fh]**//
                  LCD_VSYNC_Pulse_Width(3); // 320x240，VSYNC Pulse Width =3。
              
              #endif
7997   1      
7998   1      #ifdef ET101000DM6 // ##EDT_1024x600_ET101000DM6
              
                  //**[03h]**//
                  LVDS_Format1(); //(VESA format)//only for RA8877
                                  //  LVDS_Format2();//(JEIDA format) //only for RA8877
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                                          //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
                  HSYNC_Low_Active();
                  //  HSYNC_High_Active();
              
                  VSYNC_Low_Active();
                  //  VSYNC_High_Active();
              
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 131 

                  //  DE_Low_Active();
                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(1024, 600); // EDT_1024x600。
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(160); // EDT_1024x600，Blank=90~376@320。
                  LCD_HSYNC_Start_Position(160);   // EDT_1024x600，Blank=90~376@320。
                  LCD_HSYNC_Pulse_Width(60);       // EDT_1024x600，Blank=90~376@320。
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(23); // EDT_1024x600，Blank=10~200@35。
                  LCD_VSYNC_Start_Position(12); // EDT_1024x600，Blank=10~200@35。
                  LCD_VSYNC_Pulse_Width(5);     // EDT_1024x600，Blank=10~200@35。
              
              #endif
8054   1      
8055   1      #ifdef G190SVT01 // ##AUO_1680x342_G190SVT01
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                                          //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
                  HSYNC_Low_Active();
                  //  HSYNC_High_Active();
              
                  VSYNC_Low_Active();
                  //  VSYNC_High_Active();
              
                  //  DE_Low_Active();
                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(1680, 350); // 1680x342
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 132 

                  */
                  LCD_Horizontal_Non_Display(30); // Blank=288。
                  LCD_HSYNC_Start_Position(30);   //
                  LCD_HSYNC_Pulse_Width(30);      //
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(6); // Blank=16。
                  LCD_VSYNC_Start_Position(6); //
                  LCD_VSYNC_Pulse_Width(6);    //
              
              #endif
8107   1      
8108   1      #ifdef ZJ070NA_01B // ##INNOLUX_1024x600_ZJ070NA_01B
              
                  //**[03h]**//
                  LVDS_Format1(); //(VESA format)//only for RA8877
                                  //  LVDS_Format2();//(JEIDA format) //only for RA8877
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                                          //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
                  HSYNC_Low_Active();
                  //  HSYNC_High_Active();
              
                  VSYNC_Low_Active();
                  //  VSYNC_High_Active();
              
                  //  DE_Low_Active();
                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(1024, 600); // 1024x600
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(50); // Blank=320。
                  LCD_HSYNC_Start_Position(50);   //
                  LCD_HSYNC_Pulse_Width(220);     //
              
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 133 

                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(8); // Blank=35。
                  LCD_VSYNC_Start_Position(7); //
                  LCD_VSYNC_Pulse_Width(20);   //
              
              #endif
8164   1      
8165   1      #ifdef LQ190E1LW52 // ##SHARP_1280x1024_LQ190E1LW52
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                                          //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
                  HSYNC_Low_Active();
                  //  HSYNC_High_Active();
              
                  VSYNC_Low_Active();
                  //  VSYNC_High_Active();
              
                  //  DE_Low_Active();
                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(1280, 1024); // 1024x600
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(110); // Blank=204x2。
                  LCD_HSYNC_Start_Position(110);   //
                  LCD_HSYNC_Pulse_Width(110);      //
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(15); // Blank=42。
                  LCD_VSYNC_Start_Position(15); //
                  LCD_VSYNC_Pulse_Width(12);    //
              
              #endif
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 134 

8217   1      
8218   1      #ifdef HJ070IA_02F // ##INNOLUX_1280x800_HJ070IA_02F
              
                  //**[03h]**//
                  LVDS_Format1(); //(VESA format)//only for RA8877
                                  //  LVDS_Format2();//(JEIDA format) //only for RA8877
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                                          //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
                  HSYNC_Low_Active();
                  //  HSYNC_High_Active();
              
                  VSYNC_Low_Active();
                  //  VSYNC_High_Active();
              
                  //  DE_Low_Active();
                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(1280, 800); // 1280x800
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(30); // Blank=160。
                  LCD_HSYNC_Start_Position(30);   //
                  LCD_HSYNC_Pulse_Width(100);     //
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(3); // Blank=23。
                  LCD_VSYNC_Start_Position(3); //
                  LCD_VSYNC_Pulse_Width(18);   //
              #endif
8273   1      
8274   1      #ifdef LQ156M1LG21 // ##SHARP_1920x1080_LQ156M1LG21
              
                  //**[03h]**//
                  LVDS_Format1(); //(VESA format)//only for RA8877
                                  //  LVDS_Format2();//(JEIDA format) //only for RA8877
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 135 

              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                                          //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
                  //  HSYNC_Low_Active();
                  HSYNC_High_Active();
              
                  //  VSYNC_Low_Active();
                  VSYNC_High_Active();
              
                  //  DE_Low_Active();
                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(1920, 1080); // 1280x800
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(40); // Blank min.=140。
                  LCD_HSYNC_Start_Position(20);   //
                  LCD_HSYNC_Pulse_Width(100);     //
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(3); // Blank min.=31。
                  LCD_VSYNC_Start_Position(3); //
                  LCD_VSYNC_Pulse_Width(20);   //
              #endif
8329   1      
8330   1      #ifdef LQ201U1LW32 // ##SHARP_1600x1200_LQ201U1LW32
              
                  //**[03h]**//
                  LVDS_Format1(); //(VESA format)//only for RA8877
                                  //  LVDS_Format2();//(JEIDA format) //only for RA8877
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                                          //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 136 

                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
                  //  HSYNC_Low_Active();
                  HSYNC_High_Active();
              
                  //  VSYNC_Low_Active();
                  VSYNC_High_Active();
              
                  //  DE_Low_Active();
                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(1600, 1200); //
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(15);
                  LCD_HSYNC_Start_Position(15);
                  LCD_HSYNC_Pulse_Width(40);
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(5);
                  LCD_VSYNC_Start_Position(5);
                  LCD_VSYNC_Pulse_Width(5);
              #endif
8385   1      
8386   1      #ifdef WF52ATLASDNN0 // ## 480x128 WF52ATLASDNN0
              
                  //**[03h]**//
                  LVDS_Format1(); //(VESA format)//only for RA8877
                                  //  LVDS_Format2();//(JEIDA format) //only for RA8877
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                                          //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 137 

                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
                  HSYNC_Low_Active();
                  //  HSYNC_High_Active();
              
                  VSYNC_Low_Active();
                  //  VSYNC_High_Active();
              
                  //  DE_Low_Active();
                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(480, 272); //
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(27); //
                  LCD_HSYNC_Start_Position(16);   //
                  LCD_HSYNC_Pulse_Width(16);      //
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(8); //
                  LCD_VSYNC_Start_Position(8); //
                  LCD_VSYNC_Pulse_Width(4);    //
              
              #endif
8442   1      
8443   1      #ifdef WF39ATIASDNN0 // ## 480x128 WF39ATIASDNN0
              
                  //**[03h]**//
                  LVDS_Format1(); //(VESA format)//only for RA8877
                                  //  LVDS_Format2();//(JEIDA format) //only for RA8877
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                                          //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 138 

                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
                  HSYNC_Low_Active();
                  //  HSYNC_High_Active();
              
                  VSYNC_Low_Active();
                  //  VSYNC_High_Active();
              
                  //  DE_Low_Active();
                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(480, 272);
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(32); //
                  LCD_HSYNC_Start_Position(8);    //
                  LCD_HSYNC_Pulse_Width(8);       //
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(4); //
                  LCD_VSYNC_Start_Position(4); //
                  LCD_VSYNC_Pulse_Width(4);    //
              
              #endif
8499   1      
8500   1      #ifdef ATM1040L3A_T1 // ## 800x600 ATM1040L3A-T1
              
                  //**[03h]**//
                  LVDS_Format1(); //(VESA format)//only for RA8877
                                  //  LVDS_Format2();//(JEIDA format) //only for RA8877
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                  //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  PCLK_Falling();
                  // PCLK_Rising();
              
                  VSCAN_T_to_B();
                  PDATA_Set_RGB();
              
                  HSYNC_Low_Active();
                  VSYNC_Low_Active();
                  DE_High_Active();
                  // DE_Low_Active();
              
                  LCD_HorizontalWidth_VerticalHeight(800, 600); // ATM1040L3A-T1 800x600。
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 139 

                  LCD_Horizontal_Non_Display(38); // ATM1040L3A-T1 800x600，46。
                  LCD_HSYNC_Start_Position(210);  // ATM1040L3A-T1 800x600，16~354。
                  LCD_HSYNC_Pulse_Width(8);       // ATM1040L3A-T1 800x600，1~40C
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(15); // ATM1040L3A-T1 800x600，23。
                  LCD_VSYNC_Start_Position(12); // ATM1040L3A-T1 800x600，1~77。
                  LCD_VSYNC_Pulse_Width(8);     // ATM1040L3A-T1 800x600，1~20C
              
              #endif
8540   1      
8541   1      #ifdef G121I1_L01 // INNOLUX_1280x800_G121I1_L01
              
                  //**[03h]**//
                  LVDS_Format1(); //(VESA format)//only for RA8877
                                  //  LVDS_Format2();//(JEIDA format) //only for RA8877
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                                          //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
                  HSYNC_Low_Active();
                  //  HSYNC_High_Active();
              
                  VSYNC_Low_Active();
                  //  VSYNC_High_Active();
              
                  //  DE_Low_Active();
                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(1280, 800); //
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(40); // 80~160~
                  LCD_HSYNC_Start_Position(40);
                  LCD_HSYNC_Pulse_Width(40);
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 140 

                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(7); // 10~23~
                  LCD_VSYNC_Start_Position(7);
                  LCD_VSYNC_Pulse_Width(7);
              #endif
8596   1      
8597   1      #ifdef BA104S01_100 // BOE_800x600(京|方)// 18bpp LVDS
              
                  //**[03h]**//
                  //  LVDS_Format1();//(VESA format)//only for RA8877
                  LVDS_Format2(); //(JEIDA format) //only for RA8877
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                                          //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  //**[12h]**//
                  //  PCLK_Rising();
                  PCLK_Falling();
              
                  VSCAN_T_to_B();
                  //  VSCAN_B_to_T();
              
                  PDATA_Set_RGB();
                  //  PDATA_Set_RBG();
                  //  PDATA_Set_GRB();
                  //  PDATA_Set_GBR();
                  //  PDATA_Set_BRG();
                  //  PDATA_Set_BGR();
                  //  PDATA_Set_Gray();
                  //  PDATA_IDLE_STATE();
              
                  //**[13h]**//
                  //  HSYNC_Low_Active();
                  HSYNC_High_Active();
              
                  //  VSYNC_Low_Active();
                  VSYNC_High_Active();
              
                  //  DE_Low_Active();
                  DE_High_Active();
              
                  //**[14h][15h][1Ah][1Bh]**//
                  LCD_HorizontalWidth_VerticalHeight(800, 600); //
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(70); // 200
                  LCD_HSYNC_Start_Position(70);
                  LCD_HSYNC_Pulse_Width(70);
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(20); // 60
                  LCD_VSYNC_Start_Position(20);
                  LCD_VSYNC_Pulse_Width(20);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 141 

              #endif
8652   1      
8653   1      #ifdef ET0700B3DMA
              
                  //**[10h]**//
                  Select_LCD_Sync_Mode(); // Enable XVSYNC, XHSYNC, XDE.
                  //  Select_LCD_DE_Mode(); // XVSYNC & XHSYNC in idle state.
              
                  PCLK_Falling();
                  // PCLK_Rising();
              
                  VSCAN_T_to_B();
                  PDATA_Set_RGB();
              
                  HSYNC_Low_Active();
                  VSYNC_Low_Active();
                  DE_High_Active();
                  // DE_Low_Active();
              
                  LCD_HorizontalWidth_VerticalHeight(800, 480); // 800x480。
              
                  /*  [16h][17h] : Figure 19-3 [HND]  Non Display or Back porch (pixels)    = (HNDR + 1) * 8 + HNDFTR
                      [18h] :    Figure 19-3 [HST]  Start Position or Front porch (pixels)  = (HSTR + 1)x8
                      [19h] :    Figure 19-3 [HPW]  Pulse Width(pixels)           = (HPW + 1)x8
                  */
                  LCD_Horizontal_Non_Display(46);
                  LCD_HSYNC_Start_Position(210);
                  LCD_HSYNC_Pulse_Width(10);
              
                  /*  [1Ch][1Dh] : Figure 19-3 [VND]  Non-Display Period(Line)  = (VNDR + 1)
                      [1Eh] :    Figure 19-3 [VST]  Start Position(Line)    = (VSTR + 1)
                      [1Fh] :    Figure 19-3 [VPW]  Pulse Width(Line)     = (VPWR + 1)
                  */
                  LCD_Vertical_Non_Display(25);
                  LCD_VSYNC_Start_Position(20);
                  LCD_VSYNC_Pulse_Width(10);
              
              #endif
8689   1      }
8690          
8691          void Set_Serial_Flash_IF(void)
8692          {
8693   1      
8694   1          //(*) Using Serial Flash
8695   1      #ifdef MX25L25635E
                  Enable_SFlash_SPI();
              #endif
8698   1      #ifdef W25Q256FV
                  Enable_SFlash_SPI();
              #endif
8701   1          //(*) Using GT_ROM
8702   1      #ifdef GT21L16T1W
                  GTFont_Select_GT21L16T1W();
                  Enable_SFlash_SPI();
              #endif
8706   1      #ifdef GT30L16U2W
                  GTFont_Select_GT30L16U2W();
                  Enable_SFlash_SPI();
              #endif
8710   1      #ifdef GT30L24T3Y
                  GTFont_Select_GT30L24T3Y();
                  Enable_SFlash_SPI();
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 142 

              #endif
8714   1      #ifdef GT30L24M1Z
                  GTFont_Select_GT30L24M1Z();
                  Enable_SFlash_SPI();
              #endif
8718   1      #ifdef GT30L32S4W
                  GTFont_Select_GT30L32S4W();
                  Enable_SFlash_SPI();
              #endif
8722   1      #ifdef GT20L24F6Y
                  GTFont_Select_GT20L24F6Y();
                  Enable_SFlash_SPI();
              #endif
8726   1      #ifdef GT21L24S1W
                  GTFont_Select_GT21L24S1W();
                  Enable_SFlash_SPI();
              #endif
8730   1      
8731   1          //(*)
8732   1          Select_SFI_24bit_Address();
8733   1          //  Select_SFI_32bit_Address();
8734   1      
8735   1          //(*)
8736   1          Select_standard_SPI_Mode0_or_Mode3();
8737   1          // Select_RA8875_SPI_Mode0_and_Mode3();
8738   1      
8739   1          //(*)
8740   1          Select_SFI_Single_Mode_Dummy_0T_03h();
8741   1          //  Select_SFI_Single_Mode_Dummy_8T_0Bh();
8742   1          //  Select_SFI_Single_Mode_Dummy_16T_1Bh();
8743   1          //  Select_SFI_Dual_Mode_Dummy_8T_3Bh();
8744   1          //  Select_SFI_Dual_Mode_Dummy_4T_BBh();
8745   1          //  Select_SFI_Quad_Mode_Dummy_8T_6Bh();
8746   1          //  Select_SFI_Quad_Mode_Dummy_4T_EBh();
8747   1      
8748   1          //(*)
8749   1      
8750   1          Set_CPOL();
8751   1          Set_CPHA();
8752   1      
8753   1          Reset_CPOL();
8754   1          Reset_CPHA();
8755   1      
8756   1          //(*) clock speed
8757   1          SPI_Clock_Period(3);
8758   1      
8759   1          /******************************/
8760   1      }
8761          
8762          void RA8889_SDRAM_initial(void)
8763          {
8764   1          unsigned char CAS_Latency;
8765   1          unsigned short Auto_Refresh;
8766   1          //
8767   1          // Auto_Refresh=(64*DRAM_FREQ*1000)/(8192);
8768   1      
8769   1          CAS_Latency  = 3;
8770   1          Auto_Refresh = (64 * DRAM_FREQ * 1000) / (4096);
8771   1          Auto_Refresh = Auto_Refresh - 2; // 提前refresh，避免好碰到O限。// Start [refresh] in advan
             -ce to avoid just reaching the limits.
8772   1      
8773   1          LCD_RegisterWrite(0xe0, 0x29);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 143 

8774   1          LCD_RegisterWrite(0xe1, CAS_Latency); // CAS:2=0x02，CAS:3=0x03
8775   1          LCD_RegisterWrite(0xe2, Auto_Refresh);
8776   1          LCD_RegisterWrite(0xe3, Auto_Refresh >> 8);
8777   1          LCD_RegisterWrite(0xe4, 0x01);
8778   1      
8779   1          Check_SDRAM_Ready();
8780   1      }
8781          
8782          /*------------------------------------//------------------------------------
8783          //------------------------------------//----------------------------------*/
8784          void RA8889_PLL(unsigned short DRAM_clock, unsigned short CORE_clock, unsigned short SCAN_clock)
8785          {
8786   1          /*
8787   1          [A]
8788   1          DRAM_clock maximum 166 MHz
8789   1          CORE_clock maximum 133 MHz
8790   1          SCAN_clock maximum 100 MHz
8791   1      
8792   1          [B]
8793   1          (1) 10MHz <= OSC_FREQ <= 15MHz
8794   1          (2) 10MHz <= (OSC_FREQ/PLLDIVM) <= 40MHz
8795   1          (3) 250MHz <= [OSC_FREQ/(PLLDIVM+1)]x(PLLDIVN+1) <= 500MHz
8796   1          (4) In addition, please pay special attention to:
8797   1              [DRAM_clock] >= [CORE_clock],
8798   1              [CORE_clock] >= 2x[SCAN_clock].
8799   1          PLLDIVM:0
8800   1          PLLDIVN:1~63
8801   1          PLLDIVK:CPLL & MPLL = 1/2/4/8.SPLL = 1/2/4/8/16/32/64/128.
8802   1          ex:
8803   1           OSC_FREQ = 10MHz
8804   1           Set X_DIVK=2
8805   1           Set X_DIVM=0
8806   1           => (X_DIVN+1)=(XPLLx4)/10
8807   1          */
8808   1      
8809   1          unsigned short x_Divide, PLLC1, PLLC2;
8810   1          unsigned short pll_m_lo, pll_m_hi;
8811   1          unsigned char temp;
8812   1      
8813   1          // Set DRAM clock
8814   1          if ((DRAM_clock >= 125) && (DRAM_clock <= 166)) {
8815   2              LCD_RegisterWrite(0x07, 0x02); // PLL Divided by 2
8816   2              LCD_RegisterWrite(0x08, (DRAM_clock * 2 / OSC_FREQ) - 1);
8817   2          } else if ((DRAM_clock >= 63) && (DRAM_clock <= 124)) {
8818   2              LCD_RegisterWrite(0x07, 0x04); // PLL Divided by 4
8819   2              LCD_RegisterWrite(0x08, (DRAM_clock * 4 / OSC_FREQ) - 1);
8820   2          } else if ((DRAM_clock >= 32) && (DRAM_clock <= 62)) {
8821   2              LCD_RegisterWrite(0x07, 0x06); // PLL Divided by 8
8822   2              LCD_RegisterWrite(0x08, (DRAM_clock * 8 / OSC_FREQ) - 1);
8823   2          } else // if(DRAM_clock<32)
8824   1          {
8825   2              LCD_RegisterWrite(0x07, 0x06);                    // PLL Divided by 8
8826   2              LCD_RegisterWrite(0x08, (32 * 8 / OSC_FREQ) - 1); //
8827   2          }
8828   1      
8829   1          // Set Core clock
8830   1          if ((CORE_clock >= 125) && (CORE_clock <= 133)) {
8831   2              LCD_RegisterWrite(0x09, 0x02); // PLL Divided by 2
8832   2              LCD_RegisterWrite(0x0A, (CORE_clock * 2 / OSC_FREQ) - 1);
8833   2          } else if ((CORE_clock >= 63) && (CORE_clock <= 124)) {
8834   2              LCD_RegisterWrite(0x09, 0x04); // PLL Divided by 4
8835   2              LCD_RegisterWrite(0x0A, (CORE_clock * 4 / OSC_FREQ) - 1);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 144 

8836   2          } else if ((CORE_clock >= 32) && (CORE_clock <= 62)) {
8837   2              LCD_RegisterWrite(0x09, 0x06); // PLL Divided by 8
8838   2              LCD_RegisterWrite(0x0A, (CORE_clock * 8 / OSC_FREQ) - 1);
8839   2          } else // if(CORE_clock<32)
8840   1          {
8841   2              LCD_RegisterWrite(0x09, 0x06);                    // PLL Divided by 8
8842   2              LCD_RegisterWrite(0x0A, (32 * 8 / OSC_FREQ) - 1); //
8843   2          }
8844   1      
8845   1          // Set pixel clock
8846   1          if ((SCAN_clock >= 63) && (SCAN_clock <= 100)) {
8847   2              LCD_RegisterWrite(0x05, 0x04); // PLL Divided by 4
8848   2              LCD_RegisterWrite(0x06, (SCAN_clock * 4 / OSC_FREQ) - 1);
8849   2          } else if ((SCAN_clock >= 32) && (SCAN_clock <= 62)) {
8850   2              LCD_RegisterWrite(0x05, 0x06); // PLL Divided by 8
8851   2              LCD_RegisterWrite(0x06, (SCAN_clock * 8 / OSC_FREQ) - 1);
8852   2          } else if ((SCAN_clock >= 16) && (SCAN_clock <= 31)) {
8853   2              LCD_RegisterWrite(0x05, 0x16); // PLL Divided by 16
8854   2              LCD_RegisterWrite(0x06, (SCAN_clock * 16 / OSC_FREQ) - 1);
8855   2          } else if ((SCAN_clock >= 8) && (SCAN_clock <= 15)) {
8856   2              LCD_RegisterWrite(0x05, 0x26); // PLL Divided by 32
8857   2              LCD_RegisterWrite(0x06, (SCAN_clock * 32 / OSC_FREQ) - 1);
8858   2          } else if ((SCAN_clock > 0) && (SCAN_clock <= 7)) {
8859   2              LCD_RegisterWrite(0x05, 0x36); // PLL Divided by 64
8860   2              LCD_RegisterWrite(0x06, (SCAN_clock * 64 / OSC_FREQ) - 1);
8861   2          } else // if out of range, set 32MHz for debug.
8862   1          {
8863   2              LCD_RegisterWrite(0x05, 0x06);
8864   2              LCD_RegisterWrite(0x06, (32 * 8 / OSC_FREQ) - 1);
8865   2          }
8866   1      
8867   1          Enable_PLL();
8868   1          delay_ms(100);
8869   1      }
*** WARNING C280 IN LINE 8809 OF RA8889_01_Kernel\RA8889_51.c: 'x_Divide': unreferenced local variable
*** WARNING C280 IN LINE 8809 OF RA8889_01_Kernel\RA8889_51.c: 'PLLC1': unreferenced local variable
*** WARNING C280 IN LINE 8809 OF RA8889_01_Kernel\RA8889_51.c: 'PLLC2': unreferenced local variable
*** WARNING C280 IN LINE 8810 OF RA8889_01_Kernel\RA8889_51.c: 'pll_m_lo': unreferenced local variable
*** WARNING C280 IN LINE 8810 OF RA8889_01_Kernel\RA8889_51.c: 'pll_m_hi': unreferenced local variable
*** WARNING C280 IN LINE 8811 OF RA8889_01_Kernel\RA8889_51.c: 'temp': unreferenced local variable
8870          
8871          //[46h]=========================================================================
8872          void SPIM_Clock_Divided_2(void) //(default)
8873          {
8874   1          /*
8875   1          REG[46h] [bit2] Spi master frequency eliminator
8876   1          0: SPIM_clock = ( Core clock / 2 ) / ( frequency eliminator )
8877   1          1: SPIM_clock = ( Core clock / 1 ) / ( frequency eliminator )
8878   1          */
8879   1          unsigned char temp;
8880   1      
8881   1          REG_Switch_to_REG1();
8882   1      
8883   1          LCD_CmdWrite(0x46);
8884   1          temp = LCD_DataRead();
8885   1          temp &= cClrb2;
8886   1          LCD_DataWrite(temp);
8887   1      
8888   1          REG_Switch_to_REG0();
8889   1      }
8890          void SPIM_Clock_Divided_1(void) //
8891          {
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 145 

8892   1          /*
8893   1          REG[46h] [bit2] Spi master frequency eliminator
8894   1      
8895   1          0: SPIM_clock = ( Core clock / 2 ) / ( frequency eliminator )
8896   1          1: SPIM_clock = ( Core clock / 1 ) / ( frequency eliminator )
8897   1          */
8898   1          unsigned char temp;
8899   1      
8900   1          REG_Switch_to_REG1();
8901   1      
8902   1          LCD_CmdWrite(0x46);
8903   1          temp = LCD_DataRead();
8904   1          temp |= cSetb2;
8905   1          LCD_DataWrite(temp);
8906   1      
8907   1          REG_Switch_to_REG0();
8908   1      }
8909          
8910          void SPIM_Selectable_Bus_mode(void) //(default)
8911          {
8912   1          /*
8913   1          REG[46h] [bit1] SPI_Master_Separate
8914   1          0: bus ???(可x)
8915   1          1: bus ???(Bus0: CS0 CS1 / Bus1: CS2 CS3)
8916   1          */
8917   1          unsigned char temp;
8918   1          LCD_CmdWrite(0x46);
8919   1          temp = LCD_DataRead();
8920   1          temp &= cClrb1;
8921   1          LCD_DataWrite(temp);
8922   1      }
8923          void SPIM_Fixed_Bus_mode(void) //
8924          {
8925   1          /*
8926   1          REG[46h] [bit1] SPI_Master_Separate
8927   1          0: bus ???(可x)
8928   1          1: bus ???(Bus0: CS0 CS1 / Bus1: CS2 CS3)
8929   1          */
8930   1          unsigned char temp;
8931   1          LCD_CmdWrite(0x46);
8932   1          temp = LCD_DataRead();
8933   1          temp |= cSetb1;
8934   1          LCD_DataWrite(temp);
8935   1      }
8936          
8937          void REG_Switch_to_REG0(void) //(default)
8938          {
8939   1          /*
8940   1          REG[46h] [bit0] Page switch, and SPIM bus switch.
8941   1          0: page 0, SPIM bus 0.
8942   1          1: page 1, SPIM bus 1.
8943   1          */
8944   1          unsigned char temp;
8945   1          LCD_CmdWrite(0x46);
8946   1          temp = LCD_DataRead();
8947   1          temp &= cClrb0;
8948   1          LCD_DataWrite(temp);
8949   1      
8950   1          delay_ms(1); // for test
8951   1      }
8952          void REG_Switch_to_REG1(void) //
8953          {
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 146 

8954   1          /*
8955   1          REG[46h] [bit0] Page switch, and SPIM bus switch.
8956   1          0: page 0, SPIM bus 0.
8957   1          1: page 1, SPIM bus 1.
8958   1          */
8959   1          unsigned char temp;
8960   1          LCD_CmdWrite(0x46);
8961   1          temp = LCD_DataRead();
8962   1          temp |= cSetb0;
8963   1          LCD_DataWrite(temp);
8964   1      
8965   1          delay_ms(1); // for test
8966   1      }
8967          
8968          //[B7h]=========================================================================
8969          void Select_SFI_0(void)
8970          {
8971   1          /*[bit7]
8972   1          Serial Flash/ROM I/F # Select
8973   1          0: Serial Flash/ROM 0 I/F is selected.
8974   1          1: Serial Flash/ROM 1 I/F is selected.
8975   1          */
8976   1          unsigned char temp;
8977   1      
8978   1          REG_Switch_to_REG1();
8979   1      
8980   1          LCD_CmdWrite(0xB7);
8981   1          temp = LCD_DataRead();
8982   1          temp &= cClrb7;
8983   1          LCD_DataWrite(temp);
8984   1      
8985   1          REG_Switch_to_REG0();
8986   1      
8987   1          LCD_CmdWrite(0xB7);
8988   1          temp = LCD_DataRead();
8989   1          temp &= cClrb7;
8990   1          LCD_DataWrite(temp);
8991   1      }
8992          void Select_SFI_1(void)
8993          {
8994   1          /*[bit7]
8995   1          Serial Flash/ROM I/F # Select
8996   1          0: Serial Flash/ROM 0 I/F is selected.
8997   1          1: Serial Flash/ROM 1 I/F is selected.
8998   1          */
8999   1          unsigned char temp;
9000   1      
9001   1          REG_Switch_to_REG1();
9002   1      
9003   1          LCD_CmdWrite(0xB7);
9004   1          temp = LCD_DataRead();
9005   1          temp &= cClrb7;
9006   1          LCD_DataWrite(temp);
9007   1      
9008   1          REG_Switch_to_REG0();
9009   1      
9010   1          LCD_CmdWrite(0xB7);
9011   1          temp = LCD_DataRead();
9012   1          temp |= cSetb7;
9013   1          LCD_DataWrite(temp);
9014   1      }
9015          void Select_SFI_2(void)
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 147 

9016          {
9017   1          /*[bit7]
9018   1          Serial Flash/ROM I/F # Select
9019   1          0: Serial Flash/ROM 0 I/F is selected.
9020   1          1: Serial Flash/ROM 1 I/F is selected.
9021   1          */
9022   1          unsigned char temp;
9023   1      
9024   1          REG_Switch_to_REG1();
9025   1      
9026   1          LCD_CmdWrite(0xB7);
9027   1          temp = LCD_DataRead();
9028   1          temp |= cSetb7;
9029   1          LCD_DataWrite(temp);
9030   1      
9031   1          REG_Switch_to_REG0();
9032   1      
9033   1          LCD_CmdWrite(0xB7);
9034   1          temp = LCD_DataRead();
9035   1          temp &= cClrb7;
9036   1          LCD_DataWrite(temp);
9037   1      }
9038          void Select_SFI_3(void)
9039          {
9040   1          /*[bit7]
9041   1          Serial Flash/ROM I/F # Select
9042   1          0: Serial Flash/ROM 0 I/F is selected.
9043   1          1: Serial Flash/ROM 1 I/F is selected.
9044   1          */
9045   1          unsigned char temp;
9046   1      
9047   1          REG_Switch_to_REG1();
9048   1      
9049   1          LCD_CmdWrite(0xB7);
9050   1          temp = LCD_DataRead();
9051   1          temp |= cSetb7;
9052   1          LCD_DataWrite(temp);
9053   1      
9054   1          REG_Switch_to_REG0();
9055   1      
9056   1          LCD_CmdWrite(0xB7);
9057   1          temp = LCD_DataRead();
9058   1          temp |= cSetb7;
9059   1          LCD_DataWrite(temp);
9060   1      }
9061          
9062          //[B9h]=========================================================================
9063          // REG[B9h] SPI master Control Register (SPIMCR2)
9064          
9065          void Select_nSS_drive_on_xnsfcs0(void)
9066          {
9067   1          unsigned char temp;
9068   1          LCD_CmdWrite(0xB9);
9069   1          temp = LCD_DataRead();
9070   1          temp &= cClrb7;
9071   1          temp &= cClrb5;
9072   1          LCD_DataWrite(temp);
9073   1      }
9074          
9075          void Select_nSS_drive_on_xnsfcs1(void)
9076          {
9077   1          unsigned char temp;
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 148 

9078   1          LCD_CmdWrite(0xB9);
9079   1          temp = LCD_DataRead();
9080   1          temp &= cClrb7;
9081   1          temp |= cSetb5;
9082   1          LCD_DataWrite(temp);
9083   1      }
9084          void Select_nSS_drive_on_xnsfcs2(void)
9085          {
9086   1          unsigned char temp;
9087   1          LCD_CmdWrite(0xB9);
9088   1          temp = LCD_DataRead();
9089   1          temp |= cSetb7;
9090   1          temp &= cClrb5;
9091   1          LCD_DataWrite(temp);
9092   1      }
9093          
9094          void Select_nSS_drive_on_xnsfcs3(void)
9095          {
9096   1          unsigned char temp;
9097   1          LCD_CmdWrite(0xB9);
9098   1          temp = LCD_DataRead();
9099   1          temp |= cSetb7;
9100   1          temp |= cSetb5;
9101   1          LCD_DataWrite(temp);
9102   1      }
9103          
9104          //[REG PAGE 1]
9105          //[0Bh]=========================================================================
9106          void Disable_IDEC_Interrupt(void)
9107          {
9108   1          /* [REG PAGE 1], [0Bh]
9109   1          [bit0] IDEC Interrupt Enable Bit
9110   1          0: Disable Interrupt.
9111   1          1: Enable Interrupt.
9112   1          */
9113   1          unsigned char temp;
9114   1      
9115   1          REG_Switch_to_REG1();
9116   1      
9117   1          LCD_CmdWrite(0x0B);
9118   1          temp = LCD_DataRead();
9119   1          temp &= cClrb0;
9120   1          LCD_DataWrite(temp);
9121   1      
9122   1          REG_Switch_to_REG0();
9123   1      }
9124          void Enable_IDEC_Interrupt(void)
9125          {
9126   1          /* [REG PAGE 1], [0Bh]
9127   1          [bit0] IDEC Interrupt Enable Bit
9128   1          0: Disable Interrupt.
9129   1          1: Enable Interrupt.
9130   1          */
9131   1          unsigned char temp;
9132   1      
9133   1          REG_Switch_to_REG1();
9134   1      
9135   1          LCD_CmdWrite(0x0B);
9136   1          temp = LCD_DataRead();
9137   1          temp |= cSetb0;
9138   1          LCD_DataWrite(temp);
9139   1      
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 149 

9140   1          REG_Switch_to_REG0();
9141   1      }
9142          
9143          //[REG PAGE 1]
9144          //[0Ch]=========================================================================
9145          void Clear_IDEC_Interrupt(void)
9146          {
9147   1          /* [REG PAGE 1], [0Ch]
9148   1          [bit0] IDEC Interrupt flag
9149   1          Write Function?膏nterrupt Clear Bit
9150   1          0: No operation.
9151   1          1: Clear IDEC interrupt.
9152   1          Read Function?膏nterrupt Status
9153   1          0: No IDEC interrupt happens.
9154   1          1: IDEC interrupt happens.
9155   1          */
9156   1          unsigned char temp;
9157   1      
9158   1          REG_Switch_to_REG1();
9159   1      
9160   1          LCD_CmdWrite(0x0C);
9161   1          temp = LCD_DataRead();
9162   1          temp |= cSetb0;
9163   1          LCD_DataWrite(temp);
9164   1      
9165   1          REG_Switch_to_REG0();
9166   1      }
9167          
9168          //[REG PAGE 1]
9169          //[0Dh]=========================================================================
9170          void Unmask_IDEC_Interrupt(void)
9171          {
9172   1          /* [REG PAGE 1], [0Dh]
9173   1          [bit0] Mask IDEC Interrupt Flag
9174   1          0: Unmask.
9175   1          1: Mask.
9176   1          */
9177   1          unsigned char temp;
9178   1      
9179   1          REG_Switch_to_REG1();
9180   1      
9181   1          LCD_CmdWrite(0x0D);
9182   1          temp = LCD_DataRead();
9183   1          temp &= cClrb0;
9184   1          LCD_DataWrite(temp);
9185   1      
9186   1          REG_Switch_to_REG0();
9187   1      }
9188          void Mask_IDEC_Interrupt(void)
9189          {
9190   1          /* [REG PAGE 1], [0Dh]
9191   1          [bit0] Mask IDEC Interrupt Flag
9192   1          0: Unmask.
9193   1          1: Mask.
9194   1          */
9195   1          unsigned char temp;
9196   1      
9197   1          REG_Switch_to_REG1();
9198   1      
9199   1          LCD_CmdWrite(0x0D);
9200   1          temp = LCD_DataRead();
9201   1          temp |= cSetb0;
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 150 

9202   1          LCD_DataWrite(temp);
9203   1      
9204   1          REG_Switch_to_REG0();
9205   1      }
9206          
9207          //[REG PAGE 1]
9208          //[2Eh]~[31h]=========================================================================
9209          // AVI shadow pip start address
9210          void AVI_Shadow_PIP_Start_Address(unsigned long Addr)
9211          {
9212   1          /*[REG PAGE 1]
9213   1          [2Eh] AVI shadow PIP Start Address[7:2]
9214   1          [2Fh] AVI shadow PIP Start Address[15:8]
9215   1          [30h] AVI shadow PIP Start Address [23:16]
9216   1          [31h] AVI shadow PIP Start Address [31:24]
9217   1          */
9218   1      
9219   1          unsigned char temp;
9220   1      
9221   1          REG_Switch_to_REG1();
9222   1      
9223   1          LCD_CmdWrite(0x2E);
9224   1          LCD_DataWrite(Addr);
9225   1          LCD_CmdWrite(0x2F);
9226   1          LCD_DataWrite(Addr >> 8);
9227   1          LCD_CmdWrite(0x30);
9228   1          LCD_DataWrite(Addr >> 16);
9229   1          LCD_CmdWrite(0x31);
9230   1          LCD_DataWrite(Addr >> 24);
9231   1      
9232   1          REG_Switch_to_REG0();
9233   1      }
*** WARNING C280 IN LINE 9219 OF RA8889_01_Kernel\RA8889_51.c: 'temp': unreferenced local variable
9234          
9235          //[REG PAGE 1]
9236          //[A0h] C Video Control (VC)=========================================================================
9237          unsigned char MediaFile_ErrorFlag(void)
9238          {
9239   1          /*[REG PAGE 1], REG[A0h],
9240   1          [bit7] Media error, indicate either the unsupported image format or header format error.
9241   1          */
9242   1          unsigned char temp;
9243   1      
9244   1          REG_Switch_to_REG1();
9245   1      
9246   1          LCD_CmdWrite(0xA0);
9247   1          temp = LCD_DataRead();
9248   1          temp &= 0x80;
9249   1      
9250   1          REG_Switch_to_REG0();
9251   1      
9252   1          return temp;
9253   1      }
9254          
9255          void Check_Busy_Media_Decode(void)
9256          {
9257   1          /*[REG PAGE 1], REG[A0h],
9258   1          [bit6] Media decode busy
9259   1          */
9260   1          unsigned char temp;
9261   1      
9262   1          REG_Switch_to_REG1();
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 151 

9263   1      
9264   1          // case4: check AVI
9265   1          LCD_CmdWrite(0xA0);
9266   1          do {
9267   2              temp = LCD_DataRead();
9268   2          } while (temp & 0x40);
9269   1      
9270   1          REG_Switch_to_REG0();
9271   1      }
9272          
9273          unsigned char Read_Media_Decode_Busy(void)
9274          {
9275   1          /*[REG PAGE 1], REG[A0h],
9276   1          [bit6] Media decode busy
9277   1          */
9278   1          unsigned char temp;
9279   1      
9280   1          REG_Switch_to_REG1();
9281   1      
9282   1          // case4: check AVI
9283   1          LCD_CmdWrite(0xA0);
9284   1          temp = LCD_DataRead();
9285   1      
9286   1          REG_Switch_to_REG0();
9287   1      
9288   1          return temp;
9289   1      }
9290          
9291          unsigned char Check_Media_Fifo_Flag(void)
9292          {
9293   1          /*[REG PAGE 1], REG[A0h],
9294   1          [bit5] Media fifo empty
9295   1          */
9296   1          unsigned char temp;
9297   1      
9298   1          REG_Switch_to_REG1();
9299   1      
9300   1          LCD_CmdWrite(0xA0);
9301   1          temp = LCD_DataRead();
9302   1          temp &= 0x20;
9303   1      
9304   1          REG_Switch_to_REG0();
9305   1      
9306   1          return temp;
9307   1      }
9308          
9309          //[REG PAGE 1]
9310          //[A1h]~[A8h]=========================================================================
9311          unsigned short Read_Media_Height(void)
9312          {
9313   1          /*[REG PAGE 1],
9314   1          REG[A1h]  Extracted from media (BMP/JPEG/AVI) header Height[15:8]
9315   1          REG[A2h]  Extracted from media (BMP/JPEG/AVI) header Height[7:0]
9316   1          */
9317   1          unsigned short temp, Media_height;
9318   1      
9319   1          REG_Switch_to_REG1();
9320   1      
9321   1          LCD_CmdWrite(0xA1);
9322   1          temp = LCD_DataRead();
9323   1      
9324   1          LCD_CmdWrite(0xA2);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 152 

9325   1          Media_height = LCD_DataRead();
9326   1      
9327   1          Media_height = (temp << 8) + Media_height;
9328   1      
9329   1          REG_Switch_to_REG0();
9330   1      
9331   1          return Media_height;
9332   1      }
9333          unsigned short Read_Media_Width(void)
9334          {
9335   1          /*[REG PAGE 1],
9336   1          REG[A3h]  Extracted from media (BMP/JPEG/AVI) header Width[15:8]
9337   1          REG[A4h]  Extracted from media (BMP/JPEG/AVI) header Width[7:0]
9338   1          */
9339   1          unsigned short temp, Media_Width;
9340   1      
9341   1          REG_Switch_to_REG1();
9342   1      
9343   1          LCD_CmdWrite(0xA3);
9344   1          temp = LCD_DataRead();
9345   1      
9346   1          LCD_CmdWrite(0xA4);
9347   1          Media_Width = LCD_DataRead();
9348   1      
9349   1          Media_Width = (temp << 8) + Media_Width;
9350   1      
9351   1          REG_Switch_to_REG0();
9352   1      
9353   1          return Media_Width;
9354   1      }
9355          
9356          unsigned long Read_Media_Data_Amount(void)
9357          {
9358   1          /*[REG PAGE 1],
9359   1          REG[A5h]  Extracted from AVI header VFPB[31:24]
9360   1          REG[A6h]  Extracted from AVI header VFPB[23:16]
9361   1          REG[A7h]  Extracted from AVI header VFPB[15:8]
9362   1          REG[A8h]  Extracted from AVI header VFPB[7:0]
9363   1          */
9364   1          unsigned char temp1, temp2, temp3, temp4;
9365   1          unsigned long Media_Data_Amount;
9366   1      
9367   1          REG_Switch_to_REG1();
9368   1      
9369   1          LCD_CmdWrite(0xA5);
9370   1          temp4 = LCD_DataRead();
9371   1      
9372   1          LCD_CmdWrite(0xA6);
9373   1          temp3 = LCD_DataRead();
9374   1      
9375   1          LCD_CmdWrite(0xA7);
9376   1          temp2 = LCD_DataRead();
9377   1      
9378   1          LCD_CmdWrite(0xA8);
9379   1          temp1 = LCD_DataRead();
9380   1      
9381   1          Media_Data_Amount = (temp4 << 24) + (temp3 << 16) + (temp2 << 8) + temp1;
9382   1      
9383   1          REG_Switch_to_REG0();
9384   1      
9385   1          return Media_Data_Amount;
9386   1      }
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 153 

9387          
9388          //[REG PAGE 1]
9389          //[A9h]=========================================================================
9390          void Reset_IDEC(void)
9391          {
9392   1          /*[REG PAGE 1], REG[A9h], Idec reset , clear Idec circuit
9393   1          1: no active
9394   1          0: reset
9395   1          */
9396   1          unsigned char temp;
9397   1      
9398   1          REG_Switch_to_REG1();
9399   1      
9400   1          LCD_CmdWrite(0xA9);
9401   1          LCD_DataWrite(0x02);
9402   1      
9403   1          REG_Switch_to_REG0();
9404   1      }
*** WARNING C280 IN LINE 9396 OF RA8889_01_Kernel\RA8889_51.c: 'temp': unreferenced local variable
9405          
9406          //[REG PAGE 1]
9407          //[B6h]=========================================================================
9408          void IDEC_Select_SFI_0(void)
9409          {
9410   1          /*[REG PAGE 1], REG[B6h],
9411   1          [bit7-6]
9412   1          00: Serial Flash/ROM 0 I/F is selected.
9413   1          01: Serial Flash/ROM 1 I/F is selected.
9414   1          10: Serial Flash/ROM 2 I/F is selected.
9415   1          11: Serial Flash/ROM 3 I/F is selected.
9416   1          */
9417   1          unsigned char temp;
9418   1      
9419   1          REG_Switch_to_REG1();
9420   1      
9421   1          LCD_CmdWrite(0xB6);
9422   1          temp = LCD_DataRead();
9423   1          temp &= 0x3E; // if bit0=1, IDEC will start .
9424   1          LCD_DataWrite(temp);
9425   1      
9426   1          REG_Switch_to_REG0();
9427   1      }
9428          
9429          void IDEC_Select_SFI_1(void)
9430          {
9431   1          /*[REG PAGE 1], REG[B6h],
9432   1          [bit7-6]
9433   1          00: Serial Flash/ROM 0 I/F is selected.
9434   1          01: Serial Flash/ROM 1 I/F is selected.
9435   1          10: Serial Flash/ROM 2 I/F is selected.
9436   1          11: Serial Flash/ROM 3 I/F is selected.
9437   1          */
9438   1          unsigned char temp;
9439   1      
9440   1          REG_Switch_to_REG1();
9441   1      
9442   1          LCD_CmdWrite(0xB6);
9443   1          temp = LCD_DataRead();
9444   1          temp &= 0x3E; // if bit0=1, IDEC will start .
9445   1          temp |= 0x40;
9446   1          LCD_DataWrite(temp);
9447   1      
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 154 

9448   1          REG_Switch_to_REG0();
9449   1      }
9450          void IDEC_Select_SFI_2(void)
9451          {
9452   1          /*[REG PAGE 1], REG[B6h],
9453   1          [bit7-6]
9454   1          00: Serial Flash/ROM 0 I/F is selected.
9455   1          01: Serial Flash/ROM 1 I/F is selected.
9456   1          10: Serial Flash/ROM 2 I/F is selected.
9457   1          11: Serial Flash/ROM 3 I/F is selected.
9458   1          */
9459   1          unsigned char temp;
9460   1      
9461   1          REG_Switch_to_REG1();
9462   1      
9463   1          LCD_CmdWrite(0xB6);
9464   1          temp = LCD_DataRead();
9465   1          temp &= 0x3E; // if bit0=1, IDEC will start .
9466   1          temp |= 0x80;
9467   1          LCD_DataWrite(temp);
9468   1      
9469   1          REG_Switch_to_REG0();
9470   1      }
9471          void IDEC_Select_SFI_3(void)
9472          {
9473   1          /*[REG PAGE 1], REG[B6h],
9474   1          [bit7-6]
9475   1          00: Serial Flash/ROM 0 I/F is selected.
9476   1          01: Serial Flash/ROM 1 I/F is selected.
9477   1          10: Serial Flash/ROM 2 I/F is selected.
9478   1          11: Serial Flash/ROM 3 I/F is selected.
9479   1          */
9480   1          unsigned char temp;
9481   1      
9482   1          REG_Switch_to_REG1();
9483   1      
9484   1          LCD_CmdWrite(0xB6);
9485   1          temp = LCD_DataRead();
9486   1          temp &= 0x3E; // if bit0=1, IDEC will start .
9487   1          temp |= 0xC0;
9488   1          LCD_DataWrite(temp);
9489   1      
9490   1          REG_Switch_to_REG0();
9491   1      }
9492          
9493          //[B6h][bit4-3]====
9494          void FONT_DMA_Select_Bus_0(void)
9495          {
9496   1          /*[REG PAGE 1], REG[B6h],
9497   1          [bit4] FONT/DMA serial flash sck and data bus select
9498   1          0: SPI bus 0 is selected and the relative pins (xmosi, xmiso, xsio2, xsio3) are active.
9499   1          1: SPI bus 1 is selected and the relative pins (xsp1_msio0, xsp1_msio1, xsp1_msio2, xsp1_msio3) are ac
             -tive.
9500   1          */
9501   1          unsigned char temp;
9502   1      
9503   1          REG_Switch_to_REG1();
9504   1      
9505   1          LCD_CmdWrite(0xB6);
9506   1          temp = LCD_DataRead();
9507   1          temp &= 0xEE; // if bit0=1, IDEC will start .
9508   1          LCD_DataWrite(temp);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 155 

9509   1      
9510   1          REG_Switch_to_REG0();
9511   1      }
9512          void FONT_DMA_Select_Bus_1(void)
9513          {
9514   1          /*[REG PAGE 1], REG[B6h],
9515   1          [bit4] FONT/DMA serial flash sck and data bus select
9516   1          0: SPI bus 0 is selected and the relative pins (xmosi, xmiso, xsio2, xsio3) are active.
9517   1          1: SPI bus 1 is selected and the relative pins (xsp1_msio0, xsp1_msio1, xsp1_msio2, xsp1_msio3) are ac
             -tive.
9518   1          */
9519   1          unsigned char temp;
9520   1      
9521   1          REG_Switch_to_REG1();
9522   1      
9523   1          LCD_CmdWrite(0xB6);
9524   1          temp = LCD_DataRead();
9525   1          temp &= 0xEE; // if bit0=1, IDEC will start .
9526   1          temp |= 0x10;
9527   1          LCD_DataWrite(temp);
9528   1      
9529   1          REG_Switch_to_REG0();
9530   1      }
9531          void IDEC_Select_Bus_0(void)
9532          {
9533   1          /*[REG PAGE 1], REG[B6h],
9534   1          [bit3]
9535   1          IDEC sck and data bus select
9536   1          0: SPI bus 0 is selected and the relative pins (xmosi, xmiso, xsio2, xsio3) are active.
9537   1          1: SPI bus 1 is selected and the relative pins (xsp1_msio0, xsp1_msio1, xsp1_msio2, xsp1_msio3) are ac
             -tive.
9538   1          */
9539   1          unsigned char temp;
9540   1      
9541   1          REG_Switch_to_REG1();
9542   1      
9543   1          LCD_CmdWrite(0xB6);
9544   1          temp = LCD_DataRead();
9545   1          temp &= 0xF6; // if bit0=1, IDEC will start .
9546   1          LCD_DataWrite(temp);
9547   1      
9548   1          REG_Switch_to_REG0();
9549   1      }
9550          void IDEC_Select_Bus_1(void)
9551          {
9552   1          /*[REG PAGE 1], REG[B6h],
9553   1          [bit3]
9554   1          IDEC sck and data bus select
9555   1          0: SPI bus 0 is selected and the relative pins (xmosi, xmiso, xsio2, xsio3) are active.
9556   1          1: SPI bus 1 is selected and the relative pins (xsp1_msio0, xsp1_msio1, xsp1_msio2, xsp1_msio3) are ac
             -tive.
9557   1          */
9558   1          unsigned char temp;
9559   1      
9560   1          REG_Switch_to_REG1();
9561   1      
9562   1          LCD_CmdWrite(0xB6);
9563   1          temp = LCD_DataRead();
9564   1          temp &= 0xF6; // if bit0=1, IDEC will start .
9565   1          temp |= 0x08;
9566   1          LCD_DataWrite(temp);
9567   1      
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 156 

9568   1          REG_Switch_to_REG0();
9569   1      }
9570          
9571          //[B6h][bit2-1]====
9572          void IDEC_Destination_Color_8bpp(void)
9573          {
9574   1          /*[REG PAGE 1], REG[B6h],
9575   1          [bit2-1]
9576   1          IDEC destination Color depth:
9577   1          00: 8bit
9578   1          01: 16 bit
9579   1          10: 24bit
9580   1          */
9581   1          unsigned char temp;
9582   1      
9583   1          REG_Switch_to_REG1();
9584   1      
9585   1          LCD_CmdWrite(0xB6);
9586   1          temp = LCD_DataRead();
9587   1          temp &= 0xF8; // if bit0=1, IDEC will start .
9588   1          LCD_DataWrite(temp);
9589   1      
9590   1          REG_Switch_to_REG0();
9591   1      }
9592          void IDEC_Destination_Color_16bpp(void)
9593          {
9594   1          /*[REG PAGE 1], REG[B6h],
9595   1          [bit2-1]
9596   1          IDEC destination Color depth:
9597   1          00: 8bit
9598   1          01: 16 bit
9599   1          10: 24bit
9600   1          */
9601   1          unsigned char temp;
9602   1      
9603   1          REG_Switch_to_REG1();
9604   1      
9605   1          LCD_CmdWrite(0xB6);
9606   1          temp = LCD_DataRead();
9607   1          temp &= 0xF8; // if bit0=1, IDEC will start .
9608   1          temp |= 0x02;
9609   1          LCD_DataWrite(temp);
9610   1      
9611   1          REG_Switch_to_REG0();
9612   1      }
9613          void IDEC_Destination_Color_24bpp(void)
9614          {
9615   1          /*[REG PAGE 1], REG[B6h],
9616   1          [bit2-1]
9617   1          IDEC destination Color depth:
9618   1          00: 8bit
9619   1          01: 16 bit
9620   1          10: 24bit
9621   1          */
9622   1          unsigned char temp;
9623   1      
9624   1          REG_Switch_to_REG1();
9625   1      
9626   1          LCD_CmdWrite(0xB6);
9627   1          temp = LCD_DataRead();
9628   1          temp &= 0xF8; // if bit0=1, IDEC will start .
9629   1          temp |= 0x04;
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 157 

9630   1          LCD_DataWrite(temp);
9631   1      
9632   1          REG_Switch_to_REG0();
9633   1      }
9634          
9635          //[B6h][bit0]====
9636          void IDEC_Starts_Decoding(void)
9637          {
9638   1          /*[REG PAGE 1], REG[B6h],
9639   1          [bit0]
9640   1          Write Function: IDEC Start Bit
9641   1          Set to 1 by MPU and reset to 0 automatically
9642   1          It cannot start when fontwr_busy is 1. And if IDEC is enabled,
9643   1          serial flash I/F can’t be set as text mode & send character code.
9644   1          Read Function: IDEC Busy Check Bit
9645   1          0: Idle
9646   1          1: Busy
9647   1          */
9648   1          unsigned char temp;
9649   1      
9650   1          REG_Switch_to_REG1();
9651   1      
9652   1          LCD_CmdWrite(0xB6);
9653   1          temp = LCD_DataRead();
9654   1          temp |= cSetb0;
9655   1          LCD_DataWrite(temp);
9656   1      
9657   1          REG_Switch_to_REG0();
9658   1      }
9659          
9660          void Check_Busy_IDEC(void)
9661          {
9662   1          /*[REG PAGE 1], REG[B6h],
9663   1          [bit0]
9664   1          Write Function: IDEC Start Bit
9665   1          Set to 1 by MPU and reset to 0 automatically
9666   1          It cannot start when fontwr_busy is 1. And if IDEC is enabled,
9667   1          serial flash I/F can’t be set as text mode & send character code.
9668   1          Read Function: IDEC Busy Check Bit
9669   1          0: Idle
9670   1          1: Busy
9671   1          */
9672   1          unsigned char temp;
9673   1      
9674   1          REG_Switch_to_REG1();
9675   1      
9676   1          do {
9677   2              LCD_CmdWrite(0xB6);
9678   2              temp = LCD_DataRead();
9679   2          } while (temp & 0x01);
9680   1      
9681   1          REG_Switch_to_REG0();
9682   1      }
9683          
9684          unsigned char Read_IDEC_Busy(void)
9685          {
9686   1          /*[REG PAGE 1], REG[B6h],
9687   1          [bit0]
9688   1          Write Function: IDEC Start Bit
9689   1          Set to 1 by MPU and reset to 0 automatically
9690   1          It cannot start when fontwr_busy is 1. And if IDEC is enabled,
9691   1          serial flash I/F can’t be set as text mode & send character code.
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 158 

9692   1          Read Function: IDEC Busy Check Bit
9693   1          0: Idle
9694   1          1: Busy
9695   1          */
9696   1          unsigned char temp;
9697   1      
9698   1          REG_Switch_to_REG1();
9699   1      
9700   1          LCD_CmdWrite(0xB6);
9701   1          temp = LCD_DataRead();
9702   1          temp &= 0x01;
9703   1          REG_Switch_to_REG0();
9704   1      
9705   1          return temp;
9706   1      }
9707          
9708          //[REG PAGE 1]
9709          //[B7h]=========================================================================
9710          
9711          void IDEC_Select_SFI_24bit_Address(void)
9712          {
9713   1          /*[REG PAGE 1],[B7h] [bit5]
9714   1          IDEC Serial Flash/ROM Address Mode
9715   1          0: 24 bits address mode
9716   1          1: 32 bits address mode
9717   1          */
9718   1          unsigned char temp;
9719   1      
9720   1          REG_Switch_to_REG1();
9721   1      
9722   1          LCD_CmdWrite(0xB7);
9723   1          temp = LCD_DataRead();
9724   1          temp &= cClrb5;
9725   1          LCD_DataWrite(temp);
9726   1      
9727   1          REG_Switch_to_REG0();
9728   1      }
9729          void IDEC_Select_SFI_32bit_Address(void)
9730          {
9731   1          /*[REG PAGE 1],[B7h] [bit5]
9732   1          IDEC Serial Flash/ROM Address Mode
9733   1          0: 24 bits address mode
9734   1          1: 32 bits address mode
9735   1          */
9736   1          unsigned char temp;
9737   1      
9738   1          REG_Switch_to_REG1();
9739   1      
9740   1          LCD_CmdWrite(0xB7);
9741   1          temp = LCD_DataRead();
9742   1          temp |= cSetb5;
9743   1          LCD_DataWrite(temp);
9744   1      
9745   1          REG_Switch_to_REG0();
9746   1      }
9747          
9748          void IDEC_Select_standard_SPI_Mode0_or_Mode3(void)
9749          {
9750   1          /*[REG PAGE 1],[B7h] [bit4]
9751   1          IDEC Serial Interface
9752   1          0: standard SPI mode 0 or mode 3 timing
9753   1          1: Follow RA8875 mode 0 & mode 3 timing
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 159 

9754   1          */
9755   1          unsigned char temp;
9756   1      
9757   1          REG_Switch_to_REG1();
9758   1      
9759   1          LCD_CmdWrite(0xB7);
9760   1          temp = LCD_DataRead();
9761   1          temp &= cClrb4;
9762   1          LCD_DataWrite(temp);
9763   1      
9764   1          REG_Switch_to_REG0();
9765   1      }
9766          void IDEC_Select_RA8875_SPI_Mode0_and_Mode3(void)
9767          {
9768   1          /*[REG PAGE 1],[B7h] [bit4]
9769   1          IDEC Serial Interface
9770   1          0: standard SPI mode 0 or mode 3 timing
9771   1          1: Follow RA8875 mode 0 & mode 3 timing
9772   1          */
9773   1          unsigned char temp;
9774   1      
9775   1          REG_Switch_to_REG1();
9776   1      
9777   1          LCD_CmdWrite(0xB7);
9778   1          temp = LCD_DataRead();
9779   1          temp |= cSetb4;
9780   1          LCD_DataWrite(temp);
9781   1      
9782   1          REG_Switch_to_REG0();
9783   1      }
9784          
9785          void IDEC_Select_SFI_Single_Mode_Dummy_0T_03h(void) //
9786          {
9787   1          /*[REG PAGE 1],[B7h]
9788   1          [bit3-0]
9789   1          0000b: 1x read command code = 03h. Without dummy cycle between address and data.
9790   1          0010b: 1x read command code = 0Bh. 8 dummy cycles inserted between address and data.
9791   1          0100b: 1x read command code = 1Bh. 16 dummy cycles inserted between address and data.
9792   1          */
9793   1          unsigned char temp;
9794   1      
9795   1          REG_Switch_to_REG1();
9796   1      
9797   1          LCD_CmdWrite(0xB7);
9798   1          temp = LCD_DataRead();
9799   1          temp &= 0xF0;
9800   1          LCD_DataWrite(temp);
9801   1      
9802   1          REG_Switch_to_REG0();
9803   1      }
9804          void IDEC_Select_SFI_Single_Mode_Dummy_8T_0Bh(void) //
9805          {
9806   1          /*[REG PAGE 1],[B7h]
9807   1          [bit3-0]
9808   1          0000b: 1x read command code = 03h. Without dummy cycle between address and data.
9809   1          0010b: 1x read command code = 0Bh. 8 dummy cycles inserted between address and data.
9810   1          0100b: 1x read command code = 1Bh. 16 dummy cycles inserted between address and data.
9811   1          */
9812   1          unsigned char temp;
9813   1      
9814   1          REG_Switch_to_REG1();
9815   1      
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 160 

9816   1          LCD_CmdWrite(0xB7);
9817   1          temp = LCD_DataRead();
9818   1          temp &= 0xF0;
9819   1          temp |= 0x02;
9820   1          LCD_DataWrite(temp);
9821   1      
9822   1          REG_Switch_to_REG0();
9823   1      }
9824          void IDEC_Select_SFI_Single_Mode_Dummy_16T_1Bh(void) //
9825          {
9826   1          /*[REG PAGE 1],[B7h]
9827   1          [bit3-0]
9828   1          0000b: 1x read command code = 03h. Without dummy cycle between address and data.
9829   1          0010b: 1x read command code = 0Bh. 8 dummy cycles inserted between address and data.
9830   1          0100b: 1x read command code = 1Bh. 16 dummy cycles inserted between address and data.
9831   1          */
9832   1          unsigned char temp;
9833   1      
9834   1          REG_Switch_to_REG1();
9835   1      
9836   1          LCD_CmdWrite(0xB7);
9837   1          temp = LCD_DataRead();
9838   1          temp &= 0xF0;
9839   1          temp |= 0x04;
9840   1          LCD_DataWrite(temp);
9841   1      
9842   1          REG_Switch_to_REG0();
9843   1      }
9844          void IDEC_Select_SFI_Dual_Mode_Dummy_8T_3Bh(void) //
9845          {
9846   1          /*[REG PAGE 1],[B7h]
9847   1          [bit3-0]
9848   1          0110b: 2x read command code = 3Bh. 8 dummy cycles inserted between address and data phase. (mode 0)
9849   1          1000b: 2x read command code = BBh. 4 dummy cycles inserted between address and data phase. (mode 1)
9850   1          */
9851   1          unsigned char temp;
9852   1      
9853   1          REG_Switch_to_REG1();
9854   1      
9855   1          LCD_CmdWrite(0xB7);
9856   1          temp = LCD_DataRead();
9857   1          temp &= 0xF0;
9858   1          temp |= 0x06;
9859   1          LCD_DataWrite(temp);
9860   1      
9861   1          REG_Switch_to_REG0();
9862   1      }
9863          void IDEC_Select_SFI_Dual_Mode_Dummy_4T_BBh(void) //
9864          {
9865   1          /*[REG PAGE 1],[B7h]
9866   1          [bit3-0]
9867   1          0110b: 2x read command code = 3Bh. 8 dummy cycles inserted between address and data phase. (mode 0)
9868   1          1000b: 2x read command code = BBh. 4 dummy cycles inserted between address and data phase. (mode 1)
9869   1          */
9870   1          unsigned char temp;
9871   1      
9872   1          REG_Switch_to_REG1();
9873   1      
9874   1          LCD_CmdWrite(0xB7);
9875   1          temp = LCD_DataRead();
9876   1          temp &= 0xF0;
9877   1          temp |= 0x08;
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 161 

9878   1          LCD_DataWrite(temp);
9879   1      
9880   1          REG_Switch_to_REG0();
9881   1      }
9882          
9883          void IDEC_Select_SFI_Quad_Mode_Dummy_8T_6Bh(void) //
9884          {
9885   1          /*[REG PAGE 1],[B7h]
9886   1          [bit3-0]
9887   1          1010b: 4x read command code C 6Bh.
9888   1          1100b: 4x read command code C EBh.
9889   1          */
9890   1          unsigned char temp;
9891   1      
9892   1          REG_Switch_to_REG1();
9893   1      
9894   1          LCD_CmdWrite(0xB7);
9895   1          temp = LCD_DataRead();
9896   1          temp &= 0xF0;
9897   1          temp |= 0x0A;
9898   1          LCD_DataWrite(temp);
9899   1      
9900   1          REG_Switch_to_REG0();
9901   1      }
9902          void IDEC_Select_SFI_Quad_Mode_Dummy_4T_EBh(void) //
9903          {
9904   1          /*[REG PAGE 1],[B7h]
9905   1          [bit3-0]
9906   1          1010b: 4x read command code C 6Bh.
9907   1          1100b: 4x read command code C EBh.
9908   1          */
9909   1          unsigned char temp;
9910   1      
9911   1          REG_Switch_to_REG1();
9912   1      
9913   1          LCD_CmdWrite(0xB7);
9914   1          temp = LCD_DataRead();
9915   1          temp &= 0xF0;
9916   1          temp |= 0x0C;
9917   1          LCD_DataWrite(temp);
9918   1      
9919   1          REG_Switch_to_REG0();
9920   1      }
9921          
9922          //[REG PAGE 1]
9923          //[BBh]=========================================================================
9924          void IDEC_SPI_Clock_Divide(unsigned char IDEC_SPIclock_divide) //
9925          {
9926   1          /*[REG PAGE 1],[BBh] idec SF Clock divide
9927   1          [bit 1-0]
9928   1          00: idec_SF clock = cclk
9929   1          01: idec_SF clock = cclk/2
9930   1          10: idec SF clock  = cclk/4
9931   1          11: reverse
9932   1      
9933   1          NOTE: IDEC_clock must be more than 2 times OSC clock. IDEC_clock must be > 2 x OSC_clock.
9934   1          */
9935   1          unsigned char temp;
9936   1      
9937   1          REG_Switch_to_REG1();
9938   1      
9939   1          LCD_CmdWrite(0xBB);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 162 

9940   1          LCD_DataWrite(IDEC_SPIclock_divide);
9941   1      
9942   1          REG_Switch_to_REG0();
9943   1      }
*** WARNING C280 IN LINE 9935 OF RA8889_01_Kernel\RA8889_51.c: 'temp': unreferenced local variable
9944          
9945          //[REG PAGE 1]
9946          //[BCh]~[BFh]=========================================================================
9947          void IDEC_Source_Start_Address(unsigned long Addr) // AVI,JPG,BMP //
9948          {
9949   1          /*[REG PAGE 1]
9950   1          [BCh] Serial flash IDEC Source START ADDRESS [7:0]
9951   1          [BDh] Serial flash IDEC Source START ADDRESS [15:8]
9952   1          [BEh] Serial flash IDEC Source START ADDRESS [23:16]
9953   1          [BFh] Serial flash IDEC Source START ADDRESS [31:24]
9954   1          */
9955   1      
9956   1          REG_Switch_to_REG1();
9957   1      
9958   1          LCD_CmdWrite(0xBC);
9959   1          LCD_DataWrite(Addr);
9960   1          LCD_CmdWrite(0xBD);
9961   1          LCD_DataWrite(Addr >> 8);
9962   1          LCD_CmdWrite(0xBE);
9963   1          LCD_DataWrite(Addr >> 16);
9964   1          LCD_CmdWrite(0xBF);
9965   1          LCD_DataWrite(Addr >> 24);
9966   1      
9967   1          REG_Switch_to_REG0();
9968   1      }
9969          //[REG PAGE 1]
9970          //[C0h][C1h][C2h][C3h]=========================================================================
9971          void IDEC_Destination_Upper_Left_Corner(unsigned short WX, unsigned short HY)
9972          {
9973   1          /*
9974   1          [C0h][C1h]: IDEC_Destination X-coordinates [7:0][15:8]
9975   1          [C2h][C3h]: IDEC_Destination Y-coordinates [7:0][15:8]
9976   1          */
9977   1      
9978   1          REG_Switch_to_REG1();
9979   1      
9980   1          LCD_CmdWrite(0xC0);
9981   1          LCD_DataWrite(WX);
9982   1          LCD_CmdWrite(0xC1);
9983   1          LCD_DataWrite(WX >> 8);
9984   1      
9985   1          LCD_CmdWrite(0xC2);
9986   1          LCD_DataWrite(HY);
9987   1          LCD_CmdWrite(0xC3);
9988   1          LCD_DataWrite(HY >> 8);
9989   1      
9990   1          REG_Switch_to_REG0();
9991   1      }
9992          
9993          //[REG PAGE 1]
9994          //[C5h]=========================================================================
9995          void IDEC_AVI_Decoding_to_PIP1_and_Shadow(void)
9996          {
9997   1          /*[REG PAGE 1],[C5h]
9998   1          [bit1-0]
9999   1          00b: AVI_Decoding_to_PIP1_and_Shadow
10000  01          01b: AVI_Decoding_to_PIP2_and_Shadow
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 163 

10001  01          1xb: AVI_Decoding_to_PIP1_no_Shadow
10002  01          */
10003  01          REG_Switch_to_REG1();
10004  01      
10005  01          LCD_CmdWrite(0xC5);
10006  01          LCD_DataWrite(0x00);
10007  01      
10008  01          REG_Switch_to_REG0();
10009  01      }
10010  00      void IDEC_AVI_Decoding_to_PIP2_and_Shadow(void)
10011  00      {
10012  01          /*[REG PAGE 1],[C5h]
10013  01          [bit1-0]
10014  01          00b: AVI_Decoding_to_PIP1_and_Shadow
10015  01          01b: AVI_Decoding_to_PIP2_and_Shadow
10016  01          1xb: AVI_Decoding_to_PIP1_no_Shadow
10017  01          */
10018  01          REG_Switch_to_REG1();
10019  01      
10020  01          LCD_CmdWrite(0xC5);
10021  01          LCD_DataWrite(0x01);
10022  01      
10023  01          REG_Switch_to_REG0();
10024  01      }
10025  00      void IDEC_AVI_Decoding_to_PIP1_no_Shadow(void)
10026  00      {
10027  01          /*[REG PAGE 1],[C5h]
10028  01          [bit1-0]
10029  01          00b: AVI_Decoding_to_PIP1_and_Shadow
10030  01          01b: AVI_Decoding_to_PIP2_and_Shadow
10031  01          1xb: AVI_Decoding_to_PIP1_no_Shadow
10032  01          */
10033  01          REG_Switch_to_REG1();
10034  01      
10035  01          LCD_CmdWrite(0xC5);
10036  01          LCD_DataWrite(0x02);
10037  01      
10038  01          REG_Switch_to_REG0();
10039  01      }
10040  00      
10041  00      //[REG PAGE 1]
10042  00      //[C6h][C7h][C8h][C9h]=========================================================================
10043  00      void IDEC_Transfer_Number(unsigned long Num)
10044  00      {
10045  01          /*
10046  01          IDEC Transfer Number [7:0][15:8][23:16][31:24]
10047  01          */
10048  01          REG_Switch_to_REG1();
10049  01      
10050  01          LCD_CmdWrite(0xC6);
10051  01          LCD_DataWrite(Num);
10052  01          LCD_CmdWrite(0xC7);
10053  01          LCD_DataWrite(Num >> 8);
10054  01          LCD_CmdWrite(0xC8);
10055  01          LCD_DataWrite(Num >> 16);
10056  01          LCD_CmdWrite(0xC9);
10057  01          LCD_DataWrite(Num >> 24);
10058  01      
10059  01          REG_Switch_to_REG0();
10060  01      }
10061  00      
10062  00      //[REG PAGE 1]
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 164 

10063  00      //[CAh][CBh][CCh][CDh]=========================================================================
10064  00      void IDEC_Destination_Start_Address(unsigned long Addr) // ,JPG,BMP  //
10065  00      {
10066  01          /*[REG PAGE 1]
10067  01          REG[CAh] IDEC (JPG/BMP) Destination start addr 0 [7:0]
10068  01          REG[CBh] IDEC (JPG/BMP) Destination start addr 1 [15:8]
10069  01          REG[CCh] IDEC (JPG/BMP) Destination start addr 2 [23:16]
10070  01          REG[CDh] IDEC (JPG/BMP) Destination start addr 3 [31:24]
10071  01          Note: just only for JPG/BMP
10072  01          */
10073  01      
10074  01          REG_Switch_to_REG1();
10075  01      
10076  01          LCD_CmdWrite(0xCA);
10077  01          LCD_DataWrite(Addr);
10078  01          LCD_CmdWrite(0xCB);
10079  01          LCD_DataWrite(Addr >> 8);
10080  01          LCD_CmdWrite(0xCC);
10081  01          LCD_DataWrite(Addr >> 16);
10082  01          LCD_CmdWrite(0xCD);
10083  01          LCD_DataWrite(Addr >> 24);
10084  01      
10085  01          REG_Switch_to_REG0();
10086  01      }
10087  00      
10088  00      //[REG PAGE 1]
10089  00      //[CEh][CFh]=========================================================================
10090  00      void IDEC_Destination_Image_Width(unsigned short WX) // ,JPG,BMP //
10091  00      {
10092  01          /*[REG PAGE 1]
10093  01          REG[CEh] IDEC (JPG/BMP) Destination Image_Width [7:0]
10094  01          REG[CFh] IDEC (JPG/BMP) Destination Image_Width [12:8]
10095  01          Note: just only for JPG/BMP
10096  01          */
10097  01      
10098  01          REG_Switch_to_REG1();
10099  01      
10100  01          LCD_CmdWrite(0xCE);
10101  01          LCD_DataWrite(WX);
10102  01          LCD_CmdWrite(0xCF);
10103  01          LCD_DataWrite(WX >> 8);
10104  01      
10105  01          REG_Switch_to_REG0();
10106  01      }
10107  00      
10108  00      //[REG PAGE 0]
10109  00      //[C5h]=========================================================================
10110  00      void SPIM_Select_Bus_0(void)
10111  00      {
10112  01          /*[REG PAGE 0],[C5h]
10113  01          [bit7] SPI master bus select
10114  01          0b:  Bus 0
10115  01          1b:  Bus 1
10116  01          */
10117  01          unsigned char temp;
10118  01      
10119  01          REG_Switch_to_REG0();
10120  01      
10121  01          LCD_CmdWrite(0xC5);
10122  01          temp = LCD_DataRead();
10123  01          temp &= 0x7F; // O定REG c5h, bit 7=0
10124  01          LCD_DataWrite(temp);
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 165 

10125  01      }
10126  00      void SPIM_Select_Bus_1(void) //
10127  00      {
10128  01          /*[REG PAGE 0],[C5h]
10129  01          [bit7] SPI master bus select
10130  01          0b:  Bus 0
10131  01          1b:  Bus 1
10132  01          */
10133  01          unsigned char temp;
10134  01      
10135  01          REG_Switch_to_REG0();
10136  01      
10137  01          LCD_CmdWrite(0xC5);
10138  01          temp = LCD_DataRead();
10139  01          temp |= 0x80; // O定REG c5h, bit 7=1
10140  01          LCD_DataWrite(temp);
10141  01      }
10142  00      
10143  00      void SPI_Master_LatchEdge_Select_Rising(void)
10144  00      {
10145  01          /*[REG PAGE 0],[C5h]
10146  01          [bit5] SPI master rx register latch edge
10147  01          0: cclk rising edge
10148  01          1: cclk falling edge
10149  01          */
10150  01          unsigned char temp;
10151  01      
10152  01          REG_Switch_to_REG0();
10153  01      
10154  01          LCD_CmdWrite(0xC5);
10155  01          temp = LCD_DataRead();
10156  01          temp &= 0xDF; // O定REG c5h, bit 5=0, B1101_1111.
10157  01          LCD_DataWrite(temp);
10158  01      }
10159  00      void SPI_Master_LatchEdge_Select_Falling(void)
10160  00      {
10161  01          /*[REG PAGE 0],[C5h]
10162  01          [bit5] SPI master rx register latch edge
10163  01          0: cclk rising edge
10164  01          1: cclk falling edge
10165  01          */
10166  01          unsigned char temp;
10167  01      
10168  01          REG_Switch_to_REG0();
10169  01      
10170  01          LCD_CmdWrite(0xC5);
10171  01          temp = LCD_DataRead();
10172  01          temp |= 0x20; // O定REG c5h, bit 5=1, B0010_0000.
10173  01          LCD_DataWrite(temp);
10174  01      }
10175  00      
10176  00      //[REG PAGE 1]
10177  00      //[D3h]=========================================================================
10178  00      void Press_AVI_Pause(void)
10179  00      {
10180  01          /*[REG PAGE 1], REG[D3h],
10181  01          [bit0] Pause, the video will be paused when the bit is set
10182  01          Write  : 1: entire pause / exit pause.
10183  01          Read : 1: AVI pause;
10184  01                      0:AVI display.
10185  01          */
10186  01          // unsigned char temp;
C51 COMPILER V9.55   RA8889_51                                                             07/12/2024 14:46:12 PAGE 166 

10187  01      
10188  01          REG_Switch_to_REG1();
10189  01      
10190  01          LCD_CmdWrite(0xD3);
10191  01          LCD_DataWrite(0x01);
10192  01      
10193  01          REG_Switch_to_REG0();
10194  01      }
10195  00      
10196  00      //[REG PAGE 1]
10197  00      //[D4h]=========================================================================
10198  00      void Stop_AVI(void)
10199  00      {
10200  01          /*[REG PAGE 1], REG[D4h],
10201  01          [bit0] Stop, the video will be stopped and exited when the bit is set
10202  01          1: stop enable
10203  01          0: no operation
10204  01          */
10205  01          // unsigned char temp;
10206  01      
10207  01          REG_Switch_to_REG1();
10208  01      
10209  01          LCD_CmdWrite(0xD4);
10210  01          LCD_DataWrite(0x01);
10211  01      
10212  01          REG_Switch_to_REG0();
10213  01      }
10214  00      


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  12389    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----     342
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  22 WARNING(S),  0 ERROR(S)
